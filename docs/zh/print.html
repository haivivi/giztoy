<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Giztoy æ–‡æ¡£</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Giztoy æ–‡æ¡£</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/haivivi/giztoy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="giztoy-æ ¸å¿ƒåŒ…æ–‡æ¡£"><a class="header" href="#giztoy-æ ¸å¿ƒåŒ…æ–‡æ¡£">Giztoy æ ¸å¿ƒåŒ…æ–‡æ¡£</a></h1>
<p>æœ¬ç›®å½•åŒ…å« Giztoy æ‰€æœ‰æ ¸å¿ƒåŒ…çš„è®¾è®¡æ–‡æ¡£ã€å®ç°è¯´æ˜å’Œå·²çŸ¥é—®é¢˜ã€‚
åº“æ–‡æ¡£ä½äº <code>docs/lib/</code> ç›®å½•ä¸‹ã€‚</p>
<h2 id="æ–‡æ¡£ç»“æ„"><a class="header" href="#æ–‡æ¡£ç»“æ„">æ–‡æ¡£ç»“æ„</a></h2>
<p>æ¯ä¸ªæ¨¡å—åœ¨ <code>docs/lib/</code> ä¸‹éƒ½æœ‰ç‹¬ç«‹ç›®å½•ï¼ŒåŒ…å«ä»¥ä¸‹æ–‡ä»¶ï¼š</p>
<pre><code>lib/{mod}/
â”œâ”€â”€ doc.md      # ä¸»æ–‡æ¡£ï¼šè®¾è®¡ç›®æ ‡ã€ç‰¹æ€§ã€ç”¨æ³•ç¤ºä¾‹
â”œâ”€â”€ go.md       # Go å®ç°ï¼šæ¥å£è®¾è®¡ã€ç±»å‹å®šä¹‰ã€ä½¿ç”¨æ–¹æ³•
â”œâ”€â”€ rust.md     # Rust å®ç°ï¼štrait è®¾è®¡ã€ç±»å‹å®šä¹‰ã€è¿›åº¦
â”œâ”€â”€ issues.md   # å·²çŸ¥é—®é¢˜ï¼šbugã€å¾…æ”¹è¿›ã€è®¾è®¡ç¼ºé™·
â””â”€â”€ {submod}/   # å­æ¨¡å—ï¼ˆå¦‚æœ‰ï¼‰
    â”œâ”€â”€ doc.md
    â”œâ”€â”€ go.md
    â”œâ”€â”€ rust.md
    â””â”€â”€ issues.md
</code></pre>
<hr />
<h2 id="åŒ…åˆ—è¡¨"><a class="header" href="#åŒ…åˆ—è¡¨">åŒ…åˆ—è¡¨</a></h2>
<h3 id="åŸºç¡€å±‚"><a class="header" href="#åŸºç¡€å±‚">åŸºç¡€å±‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒ…</th><th>æè¿°</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td><a href="./lib/buffer/">buffer</a></td><td>Buffer å·¥å…·åº“</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/encoding/">encoding</a></td><td>ç¼–ç å·¥å…·ï¼ˆBase64, Hexï¼‰</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/jsontime/">jsontime</a></td><td>JSON æ—¶é—´ç±»å‹åºåˆ—åŒ–</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/trie/">trie</a></td><td>å‰ç¼€æ ‘æ•°æ®ç»“æ„</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/cli/">cli</a></td><td>CLI å·¥å…·åº“</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
</tbody></table>
</div>
<h3 id="éŸ³é¢‘å¤„ç†å±‚"><a class="header" href="#éŸ³é¢‘å¤„ç†å±‚">éŸ³é¢‘å¤„ç†å±‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒ…</th><th>æè¿°</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td><a href="./lib/audio/">audio</a></td><td>éŸ³é¢‘å¤„ç†æ¡†æ¶</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/audio/codec/">audio/codec</a></td><td>ç¼–è§£ç å™¨ï¼ˆOpus, MP3, OGGï¼‰</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/audio/pcm/">audio/pcm</a></td><td>PCM å¤„ç†ã€æ··éŸ³å™¨</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/audio/resampler/">audio/resampler</a></td><td>é‡‡æ ·ç‡è½¬æ¢ï¼ˆsoxrï¼‰</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/audio/opusrt/">audio/opusrt</a></td><td>Opus å®æ—¶æµ</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td></tr>
</tbody></table>
</div>
<h3 id="api-å®¢æˆ·ç«¯å±‚"><a class="header" href="#api-å®¢æˆ·ç«¯å±‚">API å®¢æˆ·ç«¯å±‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒ…</th><th>æè¿°</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td><a href="./lib/minimax/">minimax</a></td><td>MiniMax AI SDK</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/dashscope/">dashscope</a></td><td>é˜¿é‡Œäº‘ DashScope SDK</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/doubaospeech/">doubaospeech</a></td><td>è±†åŒ…è¯­éŸ³ SDK</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/jiutian/">jiutian</a></td><td>ä¹å¤© SDK</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
</tbody></table>
</div>
<h3 id="é€šä¿¡å±‚"><a class="header" href="#é€šä¿¡å±‚">é€šä¿¡å±‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒ…</th><th>æè¿°</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td><a href="./lib/mqtt0/">mqtt0</a></td><td>MQTT å®¢æˆ·ç«¯</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/chatgear/">chatgear</a></td><td>èŠå¤©åè®®æ¡†æ¶</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
</tbody></table>
</div>
<h3 id="ai-åº”ç”¨å±‚"><a class="header" href="#ai-åº”ç”¨å±‚">AI åº”ç”¨å±‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒ…</th><th>æè¿°</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td><a href="./lib/speech/">speech</a></td><td>è¯­éŸ³å¤„ç†</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="./lib/genx/">genx</a></td><td>LLM é€šç”¨æ¥å£</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="esp32-å¼€å‘"><a class="header" href="#esp32-å¼€å‘">ESP32 å¼€å‘</a></h2>
<ul>
<li><a href="./esp/esp32-dev-comparison.html">ESP32 å¼€å‘æ–¹æ¡ˆå¯¹æ¯”</a> - å¯¹æ¯”åˆ†æ ESP32 åµŒå…¥å¼å¼€å‘çš„äº”ç§æŠ€æœ¯æ–¹æ¡ˆ</li>
<li><a href="./esp/esp-rs-migration.html">ESP-RS è¿ç§»æŒ‡å—</a> - å°† C/ESP-IDF å›ºä»¶è¿ç§»åˆ° Rust çš„æŠ€æœ¯æ–¹æ¡ˆ</li>
</ul>
<hr />
<h2 id="é™„å½•"><a class="header" href="#é™„å½•">é™„å½•</a></h2>
<ul>
<li><a href="./packages-comparison.html">Go vs Rust åŒ…å¯¹æ¯”</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffer-package"><a class="header" href="#buffer-package">Buffer Package</a></h1>
<p>Thread-safe streaming buffer implementations for producer-consumer patterns.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h2>
<ol>
<li><strong>Type Safety</strong>: Generic buffers supporting any element type (not just bytes)</li>
<li><strong>Thread Safety</strong>: All operations are safe for concurrent access</li>
<li><strong>Blocking Semantics</strong>: Support for blocking reads/writes with proper shutdown</li>
<li><strong>Flow Control</strong>: Different strategies for handling full buffers</li>
</ol>
<h2 id="buffer-types"><a class="header" href="#buffer-types">Buffer Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Full Behavior</th><th>Empty Behavior</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Buffer</strong></td><td>Grows</td><td>Blocks</td><td>Variable-size data, unknown total size</td></tr>
<tr><td><strong>BlockBuffer</strong></td><td>Blocks</td><td>Blocks</td><td>Flow control, bounded memory</td></tr>
<tr><td><strong>RingBuffer</strong></td><td>Overwrites</td><td>Blocks</td><td>Sliding window, recent data only</td></tr>
</tbody></table>
</div>
<h3 id="buffer-growable"><a class="header" href="#buffer-growable">Buffer (Growable)</a></h3>
<p>A dynamically growing buffer that never blocks on write. Ideal for scenarios where:</p>
<ul>
<li>Data size is unknown in advance</li>
<li>Memory is not constrained</li>
<li>Writer should never be blocked</li>
</ul>
<pre><code>Writer â”€â”€â–º [grow as needed] â”€â”€â–º Reader (blocks when empty)
</code></pre>
<h3 id="blockbuffer-fixed-blocking"><a class="header" href="#blockbuffer-fixed-blocking">BlockBuffer (Fixed, Blocking)</a></h3>
<p>A fixed-size circular buffer that blocks both readers and writers. Provides backpressure for flow control:</p>
<ul>
<li>Writer blocks when buffer is full</li>
<li>Reader blocks when buffer is empty</li>
<li>Predictable memory usage</li>
</ul>
<pre><code>Writer (blocks when full) â”€â”€â–º [fixed size] â”€â”€â–º Reader (blocks when empty)
</code></pre>
<h3 id="ringbuffer-fixed-overwriting"><a class="header" href="#ringbuffer-fixed-overwriting">RingBuffer (Fixed, Overwriting)</a></h3>
<p>A fixed-size circular buffer that overwrites oldest data when full. Perfect for:</p>
<ul>
<li>Maintaining a sliding window of recent data</li>
<li>Real-time data where old samples are obsolete</li>
<li>Bounded memory with data freshness priority</li>
</ul>
<pre><code>Writer â”€â”€â–º [overwrites oldest] â”€â”€â–º Reader (blocks when empty)
</code></pre>
<h2 id="common-interface"><a class="header" href="#common-interface">Common Interface</a></h2>
<p>All buffer types share a consistent interface:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Write([]T)</code></td><td>Write slice of elements</td></tr>
<tr><td><code>Read([]T)</code></td><td>Read into slice</td></tr>
<tr><td><code>Add(T)</code></td><td>Add single element</td></tr>
<tr><td><code>Next()</code></td><td>Read single element (iterator pattern)</td></tr>
<tr><td><code>Discard(n)</code></td><td>Skip n elements without reading</td></tr>
<tr><td><code>Len()</code></td><td>Current element count</td></tr>
<tr><td><code>Reset()</code></td><td>Clear all data</td></tr>
<tr><td><code>CloseWrite()</code></td><td>Graceful shutdown (drain allowed)</td></tr>
<tr><td><code>CloseWithError(err)</code></td><td>Immediate shutdown with error</td></tr>
<tr><td><code>Close()</code></td><td>Close both ends</td></tr>
<tr><td><code>Error()</code></td><td>Get close error if any</td></tr>
</tbody></table>
</div>
<h2 id="shutdown-semantics"><a class="header" href="#shutdown-semantics">Shutdown Semantics</a></h2>
<h3 id="closewrite---graceful-shutdown"><a class="header" href="#closewrite---graceful-shutdown">CloseWrite() - Graceful Shutdown</a></h3>
<ul>
<li>Prevents new writes (returns error)</li>
<li>Allows reading existing data</li>
<li>Returns EOF/Done when empty</li>
</ul>
<h3 id="closewitherrorerr---immediate-shutdown"><a class="header" href="#closewitherrorerr---immediate-shutdown">CloseWithError(err) - Immediate Shutdown</a></h3>
<ul>
<li>Immediately closes both ends</li>
<li>All operations return the error</li>
<li>Clears internal buffer</li>
</ul>
<h2 id="examples-directory"><a class="header" href="#examples-directory">Examples Directory</a></h2>
<ul>
<li><code>examples/go/buffer/</code> - Go usage examples</li>
<li><code>examples/rust/buffer/</code> - Rust usage examples</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<h3 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h3>
<pre><code>Buffer:      [dynamic slice] â”€â”€â–º grows via append
BlockBuffer: [fixed circular] â”€â”€â–º head/tail pointers wrap
RingBuffer:  [fixed circular] â”€â”€â–º overwrites when head catches tail
</code></pre>
<h3 id="notification-mechanism"><a class="header" href="#notification-mechanism">Notification Mechanism</a></h3>
<ul>
<li><strong>Go</strong>: Channel-based (<code>writeNotify chan struct{}</code>) or Cond variable</li>
<li><strong>Rust</strong>: Condvar-based (<code>Condvar::notify_one/all</code>)</li>
</ul>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h3>
<ul>
<li><strong>Go</strong>: <code>sync.Mutex</code> + <code>sync.Cond</code> / channel</li>
<li><strong>Rust</strong>: <code>Mutex&lt;State&gt;</code> + <code>Condvar</code>, wrapped in <code>Arc</code> for cloning</li>
</ul>
<h2 id="related-packages"><a class="header" href="#related-packages">Related Packages</a></h2>
<ul>
<li><code>audio/pcm</code> - Uses buffers for PCM audio streaming</li>
<li><code>chatgear</code> - Uses buffers for audio frame transport</li>
<li><code>opusrt</code> - Uses RingBuffer for jitter buffering</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffer-package---go-implementation"><a class="header" href="#buffer-package---go-implementation">Buffer Package - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/buffer</code></p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="buffert"><a class="header" href="#buffert">Buffer[T]</a></h3>
<p>Growable buffer with generic type support.</p>
<pre><code class="language-go">type Buffer[T any] struct {
    writeNotify chan struct{}
    mu          sync.Mutex
    closeWrite  bool
    closeErr    error
    buf         []T
}
</code></pre>
<p><strong>Key Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>N</code></td><td><code>func N[T any](n int) *Buffer[T]</code></td><td>Create with initial capacity</td></tr>
<tr><td><code>Write</code></td><td><code>(b *Buffer[T]) Write(p []T) (int, error)</code></td><td>Append elements</td></tr>
<tr><td><code>Read</code></td><td><code>(b *Buffer[T]) Read(p []T) (int, error)</code></td><td>Read elements (blocks)</td></tr>
<tr><td><code>Add</code></td><td><code>(b *Buffer[T]) Add(t T) error</code></td><td>Add single element</td></tr>
<tr><td><code>Next</code></td><td><code>(b *Buffer[T]) Next() (T, error)</code></td><td>Pop from end (LIFO)</td></tr>
<tr><td><code>Bytes</code></td><td><code>(b *Buffer[T]) Bytes() []T</code></td><td>Get internal slice (unsafe)</td></tr>
</tbody></table>
</div>
<h3 id="blockbuffert"><a class="header" href="#blockbuffert">BlockBuffer[T]</a></h3>
<p>Fixed-size circular buffer with blocking semantics.</p>
<pre><code class="language-go">type BlockBuffer[T any] struct {
    cond       *sync.Cond
    mu         sync.Mutex
    buf        []T
    head, tail int64
    closeWrite bool
    closeErr   error
}
</code></pre>
<p><strong>Key Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Block</code></td><td><code>func Block[T any](buf []T) *BlockBuffer[T]</code></td><td>Create from existing slice</td></tr>
<tr><td><code>BlockN</code></td><td><code>func BlockN[T any](size int) *BlockBuffer[T]</code></td><td>Create with size</td></tr>
<tr><td><code>Write</code></td><td><code>(bb *BlockBuffer[T]) Write(p []T) (int, error)</code></td><td>Write (blocks when full)</td></tr>
<tr><td><code>Read</code></td><td><code>(bb *BlockBuffer[T]) Read(p []T) (int, error)</code></td><td>Read (blocks when empty)</td></tr>
<tr><td><code>Next</code></td><td><code>(bb *BlockBuffer[T]) Next() (T, error)</code></td><td>Read single (FIFO)</td></tr>
</tbody></table>
</div>
<h3 id="ringbuffert"><a class="header" href="#ringbuffert">RingBuffer[T]</a></h3>
<p>Fixed-size circular buffer with overwrite semantics.</p>
<pre><code class="language-go">type RingBuffer[T any] struct {
    writeNotify chan struct{}
    mu          sync.Mutex
    buf         []T
    head, tail  int64
    closeWrite  bool
    closeErr    error
}
</code></pre>
<p><strong>Key Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RingN</code></td><td><code>func RingN[T any](size int) *RingBuffer[T]</code></td><td>Create with size</td></tr>
<tr><td><code>Write</code></td><td><code>(rb *RingBuffer[T]) Write(p []T) (int, error)</code></td><td>Write (overwrites oldest)</td></tr>
<tr><td><code>Add</code></td><td><code>(rb *RingBuffer[T]) Add(t T) error</code></td><td>Add single (overwrites)</td></tr>
</tbody></table>
</div>
<h3 id="bytesbuffer-interface"><a class="header" href="#bytesbuffer-interface">BytesBuffer Interface</a></h3>
<p>Common interface for byte buffers:</p>
<pre><code class="language-go">type BytesBuffer interface {
    Write(p []byte) (n int, err error)
    Read(p []byte) (n int, err error)
    Discard(n int) (err error)
    Close() error
    CloseWrite() error
    CloseWithError(err error) error
    Error() error
    Reset()
    Bytes() []byte
    Len() int
}
</code></pre>
<h3 id="convenience-functions"><a class="header" href="#convenience-functions">Convenience Functions</a></h3>
<pre><code class="language-go">func Bytes16KB() *BlockBuffer[byte]  // 16KB blocking buffer
func Bytes4KB() *BlockBuffer[byte]   // 4KB blocking buffer
func Bytes1KB() *BlockBuffer[byte]   // 1KB blocking buffer
func Bytes256B() *BlockBuffer[byte]  // 256B blocking buffer
func Bytes() *Buffer[byte]           // 1KB growable buffer
func BytesRing(size int) *RingBuffer[byte]  // Ring buffer
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre><code class="language-go">var ErrIteratorDone = errors.New("iterator done")
</code></pre>
<ul>
<li><code>ErrIteratorDone</code>: Returned by <code>Next()</code> when buffer is closed and empty</li>
<li><code>io.EOF</code>: Returned by <code>Read()</code> when buffer is closed and empty</li>
<li><code>io.ErrClosedPipe</code>: Default error for closed buffers</li>
</ul>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="producer-consumer-with-blockbuffer"><a class="header" href="#producer-consumer-with-blockbuffer">Producer-Consumer with BlockBuffer</a></h3>
<pre><code class="language-go">buf := buffer.Bytes4KB()

// Producer goroutine
go func() {
    for data := range source {
        _, err := buf.Write(data)
        if err != nil {
            return
        }
    }
    buf.CloseWrite()
}()

// Consumer goroutine
tmp := make([]byte, 1024)
for {
    n, err := buf.Read(tmp)
    if err == io.EOF {
        break
    }
    process(tmp[:n])
}
</code></pre>
<h3 id="sliding-window-with-ringbuffer"><a class="header" href="#sliding-window-with-ringbuffer">Sliding Window with RingBuffer</a></h3>
<pre><code class="language-go">buf := buffer.RingN[float64](100)  // Keep last 100 samples

// Streaming producer
go func() {
    for sample := range stream {
        buf.Add(sample)  // Overwrites oldest when full
    }
    buf.CloseWrite()
}()

// Periodic consumer
ticker := time.NewTicker(time.Second)
for range ticker.C {
    samples := buf.Bytes()  // Get current window
    average := computeAverage(samples)
}
</code></pre>
<h3 id="iterator-pattern"><a class="header" href="#iterator-pattern">Iterator Pattern</a></h3>
<pre><code class="language-go">buf := buffer.N[Event](100)

// Using Next() for iteration
for {
    event, err := buf.Next()
    if errors.Is(err, buffer.ErrIteratorDone) {
        break
    }
    if err != nil {
        log.Error(err)
        break
    }
    handleEvent(event)
}
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="circular-buffer-arithmetic"><a class="header" href="#circular-buffer-arithmetic">Circular Buffer Arithmetic</a></h3>
<p>BlockBuffer and RingBuffer use virtual counters for head/tail:</p>
<pre><code class="language-go">// Position in physical buffer
pos := head % int64(len(buf))

// Available data
available := tail - head

// Check if full (BlockBuffer only)
isFull := tail - head == int64(len(buf))
</code></pre>
<h3 id="notification-mechanism-1"><a class="header" href="#notification-mechanism-1">Notification Mechanism</a></h3>
<ul>
<li><strong>Buffer</strong>: Uses buffered channel <code>make(chan struct{}, 1)</code> for non-blocking notification</li>
<li><strong>BlockBuffer</strong>: Uses <code>sync.Cond</code> for precise signal/broadcast control</li>
<li><strong>RingBuffer</strong>: Uses buffered channel (same as Buffer)</li>
</ul>
<h3 id="lock-patterns"><a class="header" href="#lock-patterns">Lock Patterns</a></h3>
<p>All types use <code>sync.Mutex</code> with deferred unlock:</p>
<pre><code class="language-go">func (b *Buffer[T]) Read(p []T) (n int, err error) {
    b.mu.Lock()
    defer b.mu.Unlock()
    
    // Wait loop with unlock/relock
    for len(b.buf) == 0 {
        if b.closeWrite {
            return 0, io.EOF
        }
        b.mu.Unlock()
        &lt;-b.writeNotify  // Wait for notification
        b.mu.Lock()
        // Re-check state after relock
    }
    // ... read logic
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffer-package---rust-implementation"><a class="header" href="#buffer-package---rust-implementation">Buffer Package - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-buffer</code></p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<h3 id="buffer"><a class="header" href="#buffer">Buffer<T></a></h3>
<p>Growable buffer using <code>VecDeque&lt;T&gt;</code> for O(1) front operations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Buffer&lt;T&gt; {
    inner: Arc&lt;BufferInner&lt;T&gt;&gt;,
}

struct BufferInner&lt;T&gt; {
    state: Mutex&lt;BufferState&lt;T&gt;&gt;,
    write_notify: Condvar,
}

struct BufferState&lt;T&gt; {
    buf: VecDeque&lt;T&gt;,
    close_write: bool,
    close_err: Option&lt;Arc&lt;dyn Error + Send + Sync&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new() -&gt; Self</code></td><td>Create empty buffer</td></tr>
<tr><td><code>with_capacity</code></td><td><code>fn with_capacity(capacity: usize) -&gt; Self</code></td><td>Create with capacity hint</td></tr>
<tr><td><code>write</code></td><td><code>fn write(&amp;self, data: &amp;[T]) -&gt; Result&lt;usize, BufferError&gt;</code></td><td>Append elements</td></tr>
<tr><td><code>read</code></td><td><code>fn read(&amp;self, buf: &amp;mut [T]) -&gt; Result&lt;usize, BufferError&gt;</code></td><td>Read elements (blocks)</td></tr>
<tr><td><code>add</code></td><td><code>fn add(&amp;self, item: T) -&gt; Result&lt;(), BufferError&gt;</code></td><td>Add single element</td></tr>
<tr><td><code>next</code></td><td><code>fn next(&amp;self) -&gt; Result&lt;T, Done&gt;</code></td><td>Pop from front (FIFO)</td></tr>
<tr><td><code>to_vec</code></td><td><code>fn to_vec(&amp;self) -&gt; Vec&lt;T&gt;</code></td><td>Copy to Vec</td></tr>
</tbody></table>
</div>
<h3 id="blockbuffer"><a class="header" href="#blockbuffer">BlockBuffer<T></a></h3>
<p>Fixed-size circular buffer with blocking semantics.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlockBuffer&lt;T&gt; {
    inner: Arc&lt;BlockBufferInner&lt;T&gt;&gt;,
}

struct BlockBufferInner&lt;T&gt; {
    state: Mutex&lt;BlockBufferState&lt;T&gt;&gt;,
    not_full: Condvar,
    not_empty: Condvar,
}

struct BlockBufferState&lt;T&gt; {
    buf: Vec&lt;Option&lt;T&gt;&gt;,
    head: usize,
    tail: usize,
    count: usize,
    close_write: bool,
    close_err: Option&lt;Arc&lt;dyn Error + Send + Sync&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(capacity: usize) -&gt; Self</code></td><td>Create with capacity</td></tr>
<tr><td><code>from_vec</code></td><td><code>fn from_vec(data: Vec&lt;T&gt;) -&gt; Self</code></td><td>Create from Vec (full)</td></tr>
<tr><td><code>write</code></td><td><code>fn write(&amp;self, data: &amp;[T]) -&gt; Result&lt;usize, BufferError&gt;</code></td><td>Write (blocks when full)</td></tr>
<tr><td><code>read</code></td><td><code>fn read(&amp;self, buf: &amp;mut [T]) -&gt; Result&lt;usize, BufferError&gt;</code></td><td>Read (blocks when empty)</td></tr>
<tr><td><code>capacity</code></td><td><code>fn capacity(&amp;self) -&gt; usize</code></td><td>Get capacity</td></tr>
<tr><td><code>is_full</code></td><td><code>fn is_full(&amp;self) -&gt; bool</code></td><td>Check if full</td></tr>
</tbody></table>
</div>
<h3 id="ringbuffer"><a class="header" href="#ringbuffer">RingBuffer<T></a></h3>
<p>Fixed-size circular buffer with overwrite semantics.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RingBuffer&lt;T&gt; {
    inner: Arc&lt;RingBufferInner&lt;T&gt;&gt;,
}

struct RingBufferInner&lt;T&gt; {
    state: Mutex&lt;RingBufferState&lt;T&gt;&gt;,
    write_notify: Condvar,
}

struct RingBufferState&lt;T&gt; {
    buf: Vec&lt;Option&lt;T&gt;&gt;,
    head: usize,  // virtual counter (wraps)
    tail: usize,  // virtual counter (wraps)
    close_write: bool,
    close_err: Option&lt;Arc&lt;dyn Error + Send + Sync&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(capacity: usize) -&gt; Self</code></td><td>Create with capacity</td></tr>
<tr><td><code>write</code></td><td><code>fn write(&amp;self, data: &amp;[T]) -&gt; Result&lt;usize, BufferError&gt;</code></td><td>Write (overwrites oldest)</td></tr>
<tr><td><code>add</code></td><td><code>fn add(&amp;self, item: T) -&gt; Result&lt;(), BufferError&gt;</code></td><td>Add single (overwrites)</td></tr>
</tbody></table>
</div>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub enum BufferError {
    Closed,
    ClosedWithError(Arc&lt;dyn Error + Send + Sync&gt;),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Done;
<span class="boring">}</span></code></pre></pre>
<h2 id="convenience-functions-1"><a class="header" href="#convenience-functions-1">Convenience Functions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Growable buffers
pub fn bytes() -&gt; Buffer&lt;u8&gt;         // 1KB
pub fn bytes_1kb() -&gt; Buffer&lt;u8&gt;     // 1KB
pub fn bytes_4kb() -&gt; Buffer&lt;u8&gt;     // 4KB
pub fn bytes_16kb() -&gt; Buffer&lt;u8&gt;    // 16KB
pub fn bytes_64kb() -&gt; Buffer&lt;u8&gt;    // 64KB
pub fn bytes_256b() -&gt; Buffer&lt;u8&gt;    // 256B

// Blocking buffers
pub fn block_bytes() -&gt; BlockBuffer&lt;u8&gt;      // 1KB
pub fn block_bytes_1kb() -&gt; BlockBuffer&lt;u8&gt;  // 1KB
pub fn block_bytes_4kb() -&gt; BlockBuffer&lt;u8&gt;  // 4KB
pub fn block_bytes_16kb() -&gt; BlockBuffer&lt;u8&gt; // 16KB
pub fn block_bytes_64kb() -&gt; BlockBuffer&lt;u8&gt; // 64KB

// Ring buffers
pub fn ring_bytes(size: usize) -&gt; RingBuffer&lt;u8&gt;
pub fn ring_bytes_1kb() -&gt; RingBuffer&lt;u8&gt;    // 1KB
pub fn ring_bytes_4kb() -&gt; RingBuffer&lt;u8&gt;    // 4KB
pub fn ring_bytes_16kb() -&gt; RingBuffer&lt;u8&gt;   // 16KB
pub fn ring_bytes_64kb() -&gt; RingBuffer&lt;u8&gt;   // 64KB
<span class="boring">}</span></code></pre></pre>
<h2 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h2>
<p>All types implement <code>Send + Sync</code> and support <code>Clone</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clone shares the underlying buffer via Arc
let buf = Buffer::&lt;i32&gt;::new();
let buf_clone = buf.clone();  // Same underlying buffer

// Safe to send to other threads
std::thread::spawn(move || {
    buf_clone.add(42).unwrap();
});
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-patterns-1"><a class="header" href="#usage-patterns-1">Usage Patterns</a></h2>
<h3 id="producer-consumer"><a class="header" href="#producer-consumer">Producer-Consumer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_buffer::{BlockBuffer, Done};
use std::thread;

let buf = BlockBuffer::&lt;i32&gt;::new(4);
let producer_buf = buf.clone();

let producer = thread::spawn(move || {
    for i in 0..100 {
        producer_buf.add(i).unwrap();
    }
    producer_buf.close_write().unwrap();
});

let mut collected = Vec::new();
loop {
    match buf.next() {
        Ok(item) =&gt; collected.push(item),
        Err(Done) =&gt; break,
    }
}

producer.join().unwrap();
<span class="boring">}</span></code></pre></pre>
<h3 id="sliding-window"><a class="header" href="#sliding-window">Sliding Window</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_buffer::RingBuffer;

let buf = RingBuffer::&lt;f32&gt;::new(100);

// Write more than capacity - old data overwritten
for i in 0..200 {
    buf.add(i as f32).unwrap();
}

// Buffer contains only last 100 values
assert_eq!(buf.len(), 100);
let window = buf.to_vec();  // [100.0, 101.0, ..., 199.0]
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<h3 id="vecdeque-vs-vec"><a class="header" href="#vecdeque-vs-vec">VecDeque vs Vec</a></h3>
<ul>
<li><strong>Buffer</strong>: Uses <code>VecDeque&lt;T&gt;</code> for O(1) <code>pop_front()</code></li>
<li><strong>BlockBuffer/RingBuffer</strong>: Use <code>Vec&lt;Option&lt;T&gt;&gt;</code> for circular buffer</li>
</ul>
<h3 id="wrapping-arithmetic"><a class="header" href="#wrapping-arithmetic">Wrapping Arithmetic</a></h3>
<p>RingBuffer uses <code>wrapping_add</code> for counters to handle overflow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>state.tail = state.tail.wrapping_add(1);
if state.tail.wrapping_sub(state.head) &gt; capacity {
    state.head = state.head.wrapping_add(1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dual-condvar-pattern-blockbuffer"><a class="header" href="#dual-condvar-pattern-blockbuffer">Dual Condvar Pattern (BlockBuffer)</a></h3>
<p>BlockBuffer uses two Condvars for precise signaling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>not_full: Condvar,   // Signals writers when space available
not_empty: Condvar,  // Signals readers when data available
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-implementation"><a class="header" href="#differences-from-go-implementation">Differences from Go Implementation</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Internal storage</td><td><code>[]T</code> slice</td><td><code>Vec&lt;Option&lt;T&gt;&gt;</code> or <code>VecDeque&lt;T&gt;</code></td></tr>
<tr><td><code>Buffer.Next()</code></td><td>LIFO (pops from end)</td><td>FIFO (pops from front)</td></tr>
<tr><td><code>Bytes()</code> / <code>to_vec()</code></td><td>Returns internal slice</td><td>Returns copy</td></tr>
<tr><td>Cloning</td><td>Not supported</td><td>Via <code>Arc</code> (shared)</td></tr>
<tr><td>Error type</td><td><code>error</code> interface</td><td><code>BufferError</code> enum</td></tr>
<tr><td>Default impl</td><td>Via interface</td><td>Via <code>Default</code> trait</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="buffer-package---known-issues"><a class="header" href="#buffer-package---known-issues">Buffer Package - Known Issues</a></h1>
<h2 id="-major-issues"><a class="header" href="#-major-issues">ğŸŸ  Major Issues</a></h2>
<h3 id="buf-001-go-buffernext-uses-lifo-instead-of-fifo"><a class="header" href="#buf-001-go-buffernext-uses-lifo-instead-of-fifo">BUF-001: Go Buffer.Next() uses LIFO instead of FIFO</a></h3>
<p><strong>File:</strong> <code>go/pkg/buffer/buffer.go:259-262</code></p>
<p><strong>Description:</strong><br />
The <code>Next()</code> method reads from the END of the buffer (LIFO behavior), while <code>Read()</code> reads from the front (FIFO). This inconsistency is confusing and likely unintentional.</p>
<pre><code class="language-go">// Current implementation (LIFO)
head := len(b.buf) - 1
t = b.buf[head]
b.buf = b.buf[:head]
</code></pre>
<p><strong>Expected:</strong> Should read from <code>b.buf[0]</code> for FIFO consistency with <code>Read()</code>.</p>
<p><strong>Impact:</strong> Users expecting iterator-style sequential access get reversed order.</p>
<p><strong>Status:</strong> âš ï¸ Documented in code comment but should be fixed.</p>
<hr />
<h3 id="buf-002-go-bufferadd-missing-write-notification"><a class="header" href="#buf-002-go-bufferadd-missing-write-notification">BUF-002: Go Buffer.Add() missing write notification</a></h3>
<p><strong>File:</strong> <code>go/pkg/buffer/buffer.go:280-291</code></p>
<p><strong>Description:</strong><br />
The <code>Add()</code> method appends an element but does NOT send a notification on <code>writeNotify</code>. If a reader is blocked waiting and only <code>Add()</code> is used for writing, the reader may block indefinitely.</p>
<pre><code class="language-go">func (b *Buffer[T]) Add(t T) error {
    // ... error checks ...
    b.buf = append(b.buf, t)
    return nil  // Missing: select { case b.writeNotify &lt;- struct{}{}: default: }
}
</code></pre>
<p><strong>Impact:</strong> Potential deadlock when using <code>Add()</code> exclusively.</p>
<p><strong>Status:</strong> ğŸ”´ Bug - needs fix.</p>
<hr />
<h2 id="-minor-issues"><a class="header" href="#-minor-issues">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="buf-003-go-bufferbytes-returns-internal-slice-reference"><a class="header" href="#buf-003-go-bufferbytes-returns-internal-slice-reference">BUF-003: Go Buffer.Bytes() returns internal slice reference</a></h3>
<p><strong>File:</strong> <code>go/pkg/buffer/buffer.go:335-339</code></p>
<p><strong>Description:</strong><br />
<code>Bytes()</code> returns the internal slice directly, not a copy. Modifications to the returned slice will corrupt the buffer state.</p>
<pre><code class="language-go">func (b *Buffer[T]) Bytes() []T {
    b.mu.Lock()
    defer b.mu.Unlock()
    return b.buf  // Returns internal reference!
}
</code></pre>
<p><strong>Impact:</strong> Data corruption if caller modifies the returned slice.</p>
<p><strong>Workaround:</strong> Document clearly or change to return a copy.</p>
<hr />
<h3 id="buf-004-go-blockbufferbytes-inconsistent-copy-behavior"><a class="header" href="#buf-004-go-blockbufferbytes-inconsistent-copy-behavior">BUF-004: Go BlockBuffer.Bytes() inconsistent copy behavior</a></h3>
<p><strong>File:</strong> <code>go/pkg/buffer/block_buffer.go:356-365</code></p>
<p><strong>Description:</strong><br />
Documentation says "returned slice is a copy" but when <code>h &lt; t</code>, it returns a subslice of the internal buffer directly:</p>
<pre><code class="language-go">if h &lt; t {
    return bb.buf[h:t]  // Not a copy!
}
return slices.Concat(bb.buf[h:], bb.buf[:t])  // This is a copy
</code></pre>
<p><strong>Impact:</strong> Inconsistent behavior depending on buffer state.</p>
<hr />
<h3 id="buf-005-go-ringbufferbytes-same-issue-as-buf-004"><a class="header" href="#buf-005-go-ringbufferbytes-same-issue-as-buf-004">BUF-005: Go RingBuffer.Bytes() same issue as BUF-004</a></h3>
<p><strong>File:</strong> <code>go/pkg/buffer/ring_buffer.go:306-315</code></p>
<p><strong>Description:</strong><br />
Same inconsistent copy behavior as BlockBuffer.</p>
<hr />
<h2 id="-enhancements"><a class="header" href="#-enhancements">ğŸ”µ Enhancements</a></h2>
<h3 id="buf-006-rust-blockbuffer-uses-vecoption-overhead"><a class="header" href="#buf-006-rust-blockbuffer-uses-vecoption-overhead">BUF-006: Rust BlockBuffer uses Vec&lt;Option<T>&gt; overhead</a></h3>
<p><strong>File:</strong> <code>rust/buffer/src/block_buffer.rs:82</code></p>
<p><strong>Description:</strong><br />
Rust implementation uses <code>Vec&lt;Option&lt;T&gt;&gt;</code> which adds memory overhead (size of discriminant per element) compared to Go's direct slice approach.</p>
<p><strong>Suggestion:</strong> Consider using <code>MaybeUninit&lt;T&gt;</code> with careful initialization tracking for zero-cost abstraction.</p>
<hr />
<h3 id="buf-007-gorust-buffernext-semantic-difference"><a class="header" href="#buf-007-gorust-buffernext-semantic-difference">BUF-007: Go/Rust Buffer.Next() semantic difference</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: <code>Next()</code> is LIFO (pops from end)</li>
<li>Rust: <code>next()</code> is FIFO (pops from front via VecDeque)</li>
</ul>
<p>This API inconsistency could cause bugs when porting code between languages.</p>
<p><strong>Suggestion:</strong> Align Go implementation to match Rust (FIFO).</p>
<hr />
<h2 id="-notes"><a class="header" href="#-notes">âšª Notes</a></h2>
<h3 id="buf-008-no-ioreaderiowriter-implementation-in-rust"><a class="header" href="#buf-008-no-ioreaderiowriter-implementation-in-rust">BUF-008: No io.Reader/io.Writer implementation in Rust</a></h3>
<p><strong>Description:</strong><br />
Go buffers implement <code>io.Reader</code> and <code>io.Writer</code> interfaces. Rust buffers don't implement <code>std::io::Read</code> and <code>std::io::Write</code> traits.</p>
<p><strong>Reason:</strong> Rust buffers are generic over <code>T: Clone</code>, not just bytes.</p>
<p><strong>Suggestion:</strong> Add byte-specific wrapper types that implement std::io traits.</p>
<hr />
<h3 id="buf-009-missing-bytes-equivalent-in-go-bytesbuffer-interface"><a class="header" href="#buf-009-missing-bytes-equivalent-in-go-bytesbuffer-interface">BUF-009: Missing Bytes() equivalent in Go BytesBuffer interface</a></h3>
<p><strong>File:</strong> <code>go/pkg/buffer/bytes.go:12-23</code></p>
<p><strong>Description:</strong><br />
The <code>BytesBuffer</code> interface includes <code>Bytes() []byte</code> but this is dangerous given BUF-003/004/005.</p>
<p><strong>Suggestion:</strong> Consider removing from interface or ensuring all implementations return copies.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>BUF-001</td><td>ğŸŸ  Major</td><td>Open</td><td>Go Buffer</td></tr>
<tr><td>BUF-002</td><td>ğŸŸ  Major</td><td>Open</td><td>Go Buffer</td></tr>
<tr><td>BUF-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Buffer</td></tr>
<tr><td>BUF-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go BlockBuffer</td></tr>
<tr><td>BUF-005</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go RingBuffer</td></tr>
<tr><td>BUF-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Rust BlockBuffer</td></tr>
<tr><td>BUF-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go/Rust parity</td></tr>
<tr><td>BUF-008</td><td>âšª Note</td><td>N/A</td><td>Rust</td></tr>
<tr><td>BUF-009</td><td>âšª Note</td><td>N/A</td><td>Go Interface</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="encoding-package"><a class="header" href="#encoding-package">Encoding Package</a></h1>
<p>JSON-serializable encoding types for binary data.</p>
<h2 id="design-goals-1"><a class="header" href="#design-goals-1">Design Goals</a></h2>
<ol>
<li><strong>Seamless JSON Integration</strong>: Binary data that automatically serializes to human-readable formats</li>
<li><strong>Type Safety</strong>: Distinct types for different encodings prevent mixing</li>
<li><strong>Zero-Copy Where Possible</strong>: Minimal allocations during serialization</li>
</ol>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Encoding</th><th>JSON Example</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>StdBase64Data</code></td><td>Standard Base64</td><td><code>"aGVsbG8="</code></td><td>Binary payloads, files</td></tr>
<tr><td><code>HexData</code></td><td>Hexadecimal</td><td><code>"deadbeef"</code></td><td>Hashes, IDs, debugging</td></tr>
</tbody></table>
</div>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="json-serialization"><a class="header" href="#json-serialization">JSON Serialization</a></h3>
<p>Both types implement JSON marshal/unmarshal:</p>
<pre><code class="language-json">{
  "payload": "aGVsbG8gd29ybGQ=",
  "hash": "a1b2c3d4"
}
</code></pre>
<h3 id="null-handling"><a class="header" href="#null-handling">Null Handling</a></h3>
<ul>
<li>JSON <code>null</code> deserializes to empty/nil slice</li>
<li>Empty string <code>""</code> deserializes to empty slice</li>
</ul>
<h3 id="string-representation"><a class="header" href="#string-representation">String Representation</a></h3>
<p>Both types implement <code>String()</code> / <code>Display</code> for easy logging:</p>
<pre><code>StdBase64Data("hello") -&gt; "aGVsbG8="
HexData([0xde, 0xad]) -&gt; "dead"
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="api-payloads"><a class="header" href="#api-payloads">API Payloads</a></h3>
<p>Many APIs return binary data as Base64-encoded JSON strings:</p>
<pre><code class="language-json">{
  "audio_data": "UklGRi4AAABXQVZFZm10IBAAAAABAAEA..."
}
</code></pre>
<h3 id="hash-values"><a class="header" href="#hash-values">Hash Values</a></h3>
<p>Cryptographic hashes are typically represented as hex:</p>
<pre><code class="language-json">{
  "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
}
</code></pre>
<h3 id="binary-protocol-debugging"><a class="header" href="#binary-protocol-debugging">Binary Protocol Debugging</a></h3>
<p>Hex encoding is useful for debugging binary protocols:</p>
<pre><code class="language-json">{
  "raw_frame": "0102030405"
}
</code></pre>
<h2 id="examples-directory-1"><a class="header" href="#examples-directory-1">Examples Directory</a></h2>
<ul>
<li><code>examples/go/encoding/</code> - Go usage examples (if any)</li>
<li><code>examples/rust/encoding/</code> - Rust usage examples (if any)</li>
</ul>
<h2 id="related-packages-1"><a class="header" href="#related-packages-1">Related Packages</a></h2>
<ul>
<li><code>minimax</code> - Uses Base64 for audio data in API responses</li>
<li><code>doubaospeech</code> - Uses Base64 for audio payloads</li>
<li><code>dashscope</code> - Uses Base64 for binary data</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding-package---go-implementation"><a class="header" href="#encoding-package---go-implementation">Encoding Package - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/encoding</code></p>
<h2 id="types-3"><a class="header" href="#types-3">Types</a></h2>
<h3 id="stdbase64data"><a class="header" href="#stdbase64data">StdBase64Data</a></h3>
<pre><code class="language-go">type StdBase64Data []byte
</code></pre>
<p>A byte slice that serializes to/from standard Base64 in JSON.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>MarshalJSON</code></td><td><code>() ([]byte, error)</code></td><td>Encode to JSON Base64 string</td></tr>
<tr><td><code>UnmarshalJSON</code></td><td><code>(data []byte) error</code></td><td>Decode from JSON Base64 string</td></tr>
<tr><td><code>String</code></td><td><code>() string</code></td><td>Return Base64-encoded string</td></tr>
</tbody></table>
</div>
<h3 id="hexdata"><a class="header" href="#hexdata">HexData</a></h3>
<pre><code class="language-go">type HexData []byte
</code></pre>
<p>A byte slice that serializes to/from hexadecimal in JSON.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>MarshalJSON</code></td><td><code>() ([]byte, error)</code></td><td>Encode to JSON hex string</td></tr>
<tr><td><code>UnmarshalJSON</code></td><td><code>(data []byte) error</code></td><td>Decode from JSON hex string</td></tr>
<tr><td><code>String</code></td><td><code>() string</code></td><td>Return hex-encoded string</td></tr>
</tbody></table>
</div>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="in-struct-fields"><a class="header" href="#in-struct-fields">In Struct Fields</a></h3>
<pre><code class="language-go">type Message struct {
    ID      string        `json:"id"`
    Payload StdBase64Data `json:"payload"`
    Hash    HexData       `json:"hash"`
}

msg := Message{
    ID:      "msg-123",
    Payload: StdBase64Data([]byte("hello world")),
    Hash:    HexData([]byte{0xab, 0xcd, 0xef}),
}

// Marshals to:
// {"id":"msg-123","payload":"aGVsbG8gd29ybGQ=","hash":"abcdef"}
data, _ := json.Marshal(msg)
</code></pre>
<h3 id="standalone-encoding"><a class="header" href="#standalone-encoding">Standalone Encoding</a></h3>
<pre><code class="language-go">// Base64
data := StdBase64Data([]byte("hello"))
fmt.Println(data.String())  // "aGVsbG8="

// Hex
hash := HexData([]byte{0xde, 0xad})
fmt.Println(hash.String())  // "dead"
</code></pre>
<h3 id="null-handling-1"><a class="header" href="#null-handling-1">Null Handling</a></h3>
<pre><code class="language-go">var data StdBase64Data
json.Unmarshal([]byte(`null`), &amp;data)  // data is nil

json.Unmarshal([]byte(`""`), &amp;data)    // data is []byte{}
</code></pre>
<h2 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h2>
<h3 id="unmarshaljson-logic"><a class="header" href="#unmarshaljson-logic">UnmarshalJSON Logic</a></h3>
<p>Both types handle multiple JSON input types:</p>
<pre><code class="language-go">func (b *StdBase64Data) UnmarshalJSON(data []byte) error {
    switch data[0] {
    case 'n':  // null
        return nil
    case '"':  // string
        // decode Base64
    default:
        return error
    }
}
</code></pre>
<h3 id="direct-slice-alias"><a class="header" href="#direct-slice-alias">Direct Slice Alias</a></h3>
<p>Go implementation uses direct type alias <code>type StdBase64Data []byte</code>, which means:</p>
<ul>
<li>No wrapper overhead</li>
<li>Can be cast directly to/from <code>[]byte</code></li>
<li>Shares underlying array with original slice</li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<ul>
<li><code>encoding/base64</code> (stdlib)</li>
<li><code>encoding/hex</code> (stdlib)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding-package---rust-implementation"><a class="header" href="#encoding-package---rust-implementation">Encoding Package - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-encoding</code></p>
<h2 id="types-4"><a class="header" href="#types-4">Types</a></h2>
<h3 id="stdbase64data-1"><a class="header" href="#stdbase64data-1">StdBase64Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
pub struct StdBase64Data(Vec&lt;u8&gt;);
<span class="boring">}</span></code></pre></pre>
<p>A newtype wrapper around <code>Vec&lt;u8&gt;</code> that serializes to/from standard Base64.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(data: Vec&lt;u8&gt;) -&gt; Self</code></td><td>Create from Vec</td></tr>
<tr><td><code>empty</code></td><td><code>fn empty() -&gt; Self</code></td><td>Create empty</td></tr>
<tr><td><code>as_bytes</code></td><td><code>fn as_bytes(&amp;self) -&gt; &amp;[u8]</code></td><td>Get byte slice reference</td></tr>
<tr><td><code>as_bytes_mut</code></td><td><code>fn as_bytes_mut(&amp;mut self) -&gt; &amp;mut Vec&lt;u8&gt;</code></td><td>Get mutable reference</td></tr>
<tr><td><code>into_bytes</code></td><td><code>fn into_bytes(self) -&gt; Vec&lt;u8&gt;</code></td><td>Consume and return Vec</td></tr>
<tr><td><code>is_empty</code></td><td><code>fn is_empty(&amp;self) -&gt; bool</code></td><td>Check if empty</td></tr>
<tr><td><code>len</code></td><td><code>fn len(&amp;self) -&gt; usize</code></td><td>Get length</td></tr>
<tr><td><code>encode</code></td><td><code>fn encode(&amp;self) -&gt; String</code></td><td>Encode to Base64 string</td></tr>
<tr><td><code>decode</code></td><td><code>fn decode(s: &amp;str) -&gt; Result&lt;Self, DecodeError&gt;</code></td><td>Decode from Base64</td></tr>
</tbody></table>
</div>
<p><strong>Trait Implementations:</strong></p>
<ul>
<li><code>Serialize</code> / <code>Deserialize</code> (serde)</li>
<li><code>Display</code> (formats as Base64)</li>
<li><code>Deref&lt;Target=[u8]&gt;</code> / <code>DerefMut</code></li>
<li><code>From&lt;Vec&lt;u8&gt;&gt;</code>, <code>From&lt;&amp;[u8]&gt;</code>, <code>From&lt;[u8; N]&gt;</code></li>
<li><code>AsRef&lt;[u8]&gt;</code></li>
</ul>
<h3 id="hexdata-1"><a class="header" href="#hexdata-1">HexData</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
pub struct HexData(Vec&lt;u8&gt;);
<span class="boring">}</span></code></pre></pre>
<p>A newtype wrapper around <code>Vec&lt;u8&gt;</code> that serializes to/from hexadecimal.</p>
<p><strong>Methods:</strong></p>
<p>Same API as <code>StdBase64Data</code>, but with hex encoding:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>encode</code></td><td><code>fn encode(&amp;self) -&gt; String</code></td><td>Encode to hex string</td></tr>
<tr><td><code>decode</code></td><td><code>fn decode(s: &amp;str) -&gt; Result&lt;Self, FromHexError&gt;</code></td><td>Decode from hex</td></tr>
</tbody></table>
</div>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="in-struct-fields-1"><a class="header" href="#in-struct-fields-1">In Struct Fields</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_encoding::{StdBase64Data, HexData};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Message {
    id: String,
    payload: StdBase64Data,
    hash: HexData,
}

let msg = Message {
    id: "msg-123".to_string(),
    payload: StdBase64Data::from(b"hello world".as_slice()),
    hash: HexData::from(vec![0xab, 0xcd, 0xef]),
};

// Serializes to:
// {"id":"msg-123","payload":"aGVsbG8gd29ybGQ=","hash":"abcdef"}
let json = serde_json::to_string(&amp;msg).unwrap();
<span class="boring">}</span></code></pre></pre>
<h3 id="standalone-encoding-1"><a class="header" href="#standalone-encoding-1">Standalone Encoding</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Base64
let data = StdBase64Data::from(b"hello".as_slice());
println!("{}", data);  // "aGVsbG8="
println!("{}", data.encode());  // "aGVsbG8="

// Hex
let hash = HexData::from(vec![0xde, 0xad]);
println!("{}", hash);  // "dead"
<span class="boring">}</span></code></pre></pre>
<h3 id="deref-coercion"><a class="header" href="#deref-coercion">Deref Coercion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = StdBase64Data::from(vec![1, 2, 3]);

// Can use as &amp;[u8] directly
fn process(bytes: &amp;[u8]) { /* ... */ }
process(&amp;data);  // Deref coercion

// Access slice methods
println!("len: {}", data.len());
println!("first: {:?}", data.first());
<span class="boring">}</span></code></pre></pre>
<h3 id="null-handling-2"><a class="header" href="#null-handling-2">Null Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Null deserializes to empty
let data: StdBase64Data = serde_json::from_str("null").unwrap();
assert!(data.is_empty());

// Empty string also empty
let data: StdBase64Data = serde_json::from_str(r#""""#).unwrap();
assert!(data.is_empty());
<span class="boring">}</span></code></pre></pre>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<ul>
<li><code>base64</code> crate (for Base64 encoding)</li>
<li><code>hex</code> crate (for hex encoding)</li>
<li><code>serde</code> crate (for serialization)</li>
</ul>
<h2 id="differences-from-go"><a class="header" href="#differences-from-go">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type structure</td><td>Type alias <code>[]byte</code></td><td>Newtype <code>struct(Vec&lt;u8&gt;)</code></td></tr>
<tr><td>Conversion to bytes</td><td>Direct cast</td><td><code>.as_bytes()</code> or <code>Deref</code></td></tr>
<tr><td>Additional methods</td><td>None</td><td><code>is_empty()</code>, <code>len()</code>, <code>encode()</code>, <code>decode()</code></td></tr>
<tr><td>Hash/Eq traits</td><td>N/A (slice)</td><td>Implemented</td></tr>
<tr><td>Clone</td><td>Implicit</td><td>Explicit (implemented)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="encoding-package---known-issues"><a class="header" href="#encoding-package---known-issues">Encoding Package - Known Issues</a></h1>
<h2 id="-notes-1"><a class="header" href="#-notes-1">âšª Notes</a></h2>
<h3 id="enc-001-gorust-type-structure-difference"><a class="header" href="#enc-001-gorust-type-structure-difference">ENC-001: Go/Rust type structure difference</a></h3>
<p><strong>Description:</strong><br />
Go uses type alias (<code>type StdBase64Data []byte</code>) while Rust uses newtype wrapper (<code>struct StdBase64Data(Vec&lt;u8&gt;)</code>).</p>
<p><strong>Impact:</strong></p>
<ul>
<li>Go: Direct cast to <code>[]byte</code>, shares memory</li>
<li>Rust: Requires <code>.as_bytes()</code> or deref coercion, owns memory</li>
</ul>
<p><strong>Status:</strong> By design - idiomatic in each language.</p>
<hr />
<h3 id="enc-002-rust-has-more-utility-methods"><a class="header" href="#enc-002-rust-has-more-utility-methods">ENC-002: Rust has more utility methods</a></h3>
<p><strong>Description:</strong><br />
Rust implementation has additional methods not present in Go:</p>
<ul>
<li><code>is_empty()</code> / <code>len()</code></li>
<li><code>encode()</code> / <code>decode()</code> (standalone, not just JSON)</li>
<li><code>empty()</code> constructor</li>
<li><code>as_bytes_mut()</code> for mutation</li>
</ul>
<p><strong>Suggestion:</strong> Consider adding these to Go for parity.</p>
<hr />
<h3 id="enc-003-error-handling-difference"><a class="header" href="#enc-003-error-handling-difference">ENC-003: Error handling difference</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: Returns <code>error</code> on unmarshal failure</li>
<li>Rust: Returns <code>Result&lt;T, E&gt;</code> with specific error types (<code>base64::DecodeError</code>, <code>hex::FromHexError</code>)</li>
</ul>
<p><strong>Impact:</strong> Different error inspection patterns in each language.</p>
<hr />
<h2 id="-enhancements-1"><a class="header" href="#-enhancements-1">ğŸ”µ Enhancements</a></h2>
<h3 id="enc-004-missing-url-safe-base64-variant"><a class="header" href="#enc-004-missing-url-safe-base64-variant">ENC-004: Missing URL-safe Base64 variant</a></h3>
<p><strong>Description:</strong><br />
Only standard Base64 is implemented. URL-safe Base64 (<code>base64.URLEncoding</code> / <code>URL_SAFE</code>) is commonly needed for:</p>
<ul>
<li>JWT tokens</li>
<li>URL parameters</li>
<li>Filename-safe identifiers</li>
</ul>
<p><strong>Suggestion:</strong> Add <code>UrlBase64Data</code> type.</p>
<hr />
<h3 id="enc-005-no-raw-base64-no-padding-variant"><a class="header" href="#enc-005-no-raw-base64-no-padding-variant">ENC-005: No raw Base64 (no padding) variant</a></h3>
<p><strong>Description:</strong><br />
Some APIs use raw Base64 without <code>=</code> padding. Neither implementation supports this variant.</p>
<p><strong>Suggestion:</strong> Add <code>RawBase64Data</code> or add encoding options.</p>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>ENC-001</td><td>âšª Note</td><td>By design</td><td>Go/Rust</td></tr>
<tr><td>ENC-002</td><td>âšª Note</td><td>Open</td><td>Go</td></tr>
<tr><td>ENC-003</td><td>âšª Note</td><td>By design</td><td>Go/Rust</td></tr>
<tr><td>ENC-004</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>ENC-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Clean implementation with no bugs found. Minor parity differences between Go and Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsontime-package"><a class="header" href="#jsontime-package">JsonTime Package</a></h1>
<p>JSON-serializable time types for API integrations.</p>
<h2 id="design-goals-2"><a class="header" href="#design-goals-2">Design Goals</a></h2>
<ol>
<li><strong>API Compatibility</strong>: Many APIs use Unix timestamps instead of ISO 8601 strings</li>
<li><strong>Type Safety</strong>: Distinct types prevent mixing seconds/milliseconds</li>
<li><strong>Bidirectional</strong>: Both serialization and deserialization supported</li>
</ol>
<h2 id="types-5"><a class="header" href="#types-5">Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>JSON Format</th><th>Example</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>Unix</code></td><td>Integer (seconds)</td><td><code>1705315800</code></td><td>General timestamps</td></tr>
<tr><td><code>Milli</code></td><td>Integer (milliseconds)</td><td><code>1705315800000</code></td><td>High-precision timestamps</td></tr>
<tr><td><code>Duration</code></td><td>String or Integer</td><td><code>"1h30m"</code> or <code>5400000000000</code></td><td>Time intervals</td></tr>
</tbody></table>
</div>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<h3 id="unix-timestamps"><a class="header" href="#unix-timestamps">Unix Timestamps</a></h3>
<p>Many APIs use Unix epoch timestamps rather than ISO 8601:</p>
<pre><code class="language-json">{
  "created_at": 1705315800,
  "updated_at": 1705316000
}
</code></pre>
<h3 id="millisecond-precision"><a class="header" href="#millisecond-precision">Millisecond Precision</a></h3>
<p>JavaScript/browser APIs often use milliseconds:</p>
<pre><code class="language-json">{
  "timestamp": 1705315800000,
  "expires_at": 1705316000000
}
</code></pre>
<h3 id="flexible-duration-parsing"><a class="header" href="#flexible-duration-parsing">Flexible Duration Parsing</a></h3>
<p>Duration supports both human-readable strings and raw nanoseconds:</p>
<pre><code class="language-json">{
  "timeout": "30s",
  "interval": "1h30m",
  "precise_delay": 5000000000
}
</code></pre>
<h2 id="time-operations"><a class="header" href="#time-operations">Time Operations</a></h2>
<p>Both <code>Unix</code> and <code>Milli</code> support common time operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Before(t)</code></td><td>Is this time before t?</td></tr>
<tr><td><code>After(t)</code></td><td>Is this time after t?</td></tr>
<tr><td><code>Equal(t)</code></td><td>Are these times equal?</td></tr>
<tr><td><code>Sub(t)</code></td><td>Duration between times</td></tr>
<tr><td><code>Add(d)</code></td><td>Add duration to time</td></tr>
<tr><td><code>IsZero()</code></td><td>Is this the zero time?</td></tr>
</tbody></table>
</div>
<h2 id="duration-string-format"><a class="header" href="#duration-string-format">Duration String Format</a></h2>
<p>The Duration type uses Go-style duration strings:</p>
<div class="table-wrapper"><table><thead><tr><th>Unit</th><th>Symbol</th><th>Example</th></tr></thead><tbody>
<tr><td>Hours</td><td><code>h</code></td><td><code>2h</code></td></tr>
<tr><td>Minutes</td><td><code>m</code></td><td><code>30m</code></td></tr>
<tr><td>Seconds</td><td><code>s</code></td><td><code>45s</code></td></tr>
<tr><td>Combined</td><td></td><td><code>1h30m45s</code></td></tr>
</tbody></table>
</div>
<h2 id="examples-directory-2"><a class="header" href="#examples-directory-2">Examples Directory</a></h2>
<ul>
<li><code>examples/go/jsontime/</code> - Go usage examples (if any)</li>
<li><code>examples/rust/jsontime/</code> - Rust usage examples (if any)</li>
</ul>
<h2 id="related-packages-2"><a class="header" href="#related-packages-2">Related Packages</a></h2>
<ul>
<li><code>minimax</code> - Uses Milli for timestamps in API responses</li>
<li><code>doubaospeech</code> - Uses Unix/Milli for audio timestamps</li>
<li><code>dashscope</code> - Uses Duration for timeout configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsontime-package---go-implementation"><a class="header" href="#jsontime-package---go-implementation">JsonTime Package - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/jsontime</code></p>
<h2 id="types-6"><a class="header" href="#types-6">Types</a></h2>
<h3 id="unix"><a class="header" href="#unix">Unix</a></h3>
<pre><code class="language-go">type Unix time.Time
</code></pre>
<p>A <code>time.Time</code> that serializes to/from Unix seconds in JSON.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NowEpoch</code></td><td><code>func NowEpoch() Unix</code></td><td>Current time as Unix</td></tr>
<tr><td><code>Time</code></td><td><code>(ep Unix) Time() time.Time</code></td><td>Get underlying time.Time</td></tr>
<tr><td><code>Before</code></td><td><code>(ep Unix) Before(t Unix) bool</code></td><td>Is ep before t?</td></tr>
<tr><td><code>After</code></td><td><code>(ep Unix) After(t Unix) bool</code></td><td>Is ep after t?</td></tr>
<tr><td><code>Equal</code></td><td><code>(ep Unix) Equal(t Unix) bool</code></td><td>Are times equal?</td></tr>
<tr><td><code>Sub</code></td><td><code>(ep Unix) Sub(t Unix) time.Duration</code></td><td>Duration ep-t</td></tr>
<tr><td><code>Add</code></td><td><code>(ep Unix) Add(d time.Duration) Unix</code></td><td>Return ep+d</td></tr>
<tr><td><code>IsZero</code></td><td><code>(ep Unix) IsZero() bool</code></td><td>Is zero time?</td></tr>
<tr><td><code>String</code></td><td><code>(ep Unix) String() string</code></td><td>Formatted string</td></tr>
</tbody></table>
</div>
<h3 id="milli"><a class="header" href="#milli">Milli</a></h3>
<pre><code class="language-go">type Milli time.Time
</code></pre>
<p>A <code>time.Time</code> that serializes to/from Unix milliseconds in JSON.</p>
<p><strong>Methods:</strong> Same as Unix.</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NowEpochMilli</code></td><td><code>func NowEpochMilli() Milli</code></td><td>Current time as Milli</td></tr>
<tr><td><code>Time</code></td><td><code>(ep Milli) Time() time.Time</code></td><td>Get underlying time.Time</td></tr>
<tr><td>...</td><td></td><td>(same operations as Unix)</td></tr>
</tbody></table>
</div>
<h3 id="duration"><a class="header" href="#duration">Duration</a></h3>
<pre><code class="language-go">type Duration time.Duration
</code></pre>
<p>A <code>time.Duration</code> that serializes to string (e.g., "1h30m") in JSON.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FromDuration</code></td><td><code>func FromDuration(d time.Duration) *Duration</code></td><td>Create Duration pointer</td></tr>
<tr><td><code>Duration</code></td><td><code>(d *Duration) Duration() time.Duration</code></td><td>Get underlying duration</td></tr>
<tr><td><code>String</code></td><td><code>(d Duration) String() string</code></td><td>Formatted string (e.g., "1h30m")</td></tr>
<tr><td><code>Seconds</code></td><td><code>(d Duration) Seconds() float64</code></td><td>As floating point seconds</td></tr>
<tr><td><code>Milliseconds</code></td><td><code>(d Duration) Milliseconds() int64</code></td><td>As integer milliseconds</td></tr>
</tbody></table>
</div>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<h3 id="in-struct-fields-2"><a class="header" href="#in-struct-fields-2">In Struct Fields</a></h3>
<pre><code class="language-go">type Event struct {
    ID        string   `json:"id"`
    CreatedAt Unix     `json:"created_at"`
    ExpiresAt Milli    `json:"expires_at"`
    Timeout   Duration `json:"timeout"`
}

event := Event{
    ID:        "evt-123",
    CreatedAt: NowEpoch(),
    ExpiresAt: NowEpochMilli(),
    Timeout:   Duration(30 * time.Second),
}

// Marshals to:
// {"id":"evt-123","created_at":1705315800,"expires_at":1705315800000,"timeout":"30s"}
</code></pre>
<h3 id="duration-parsing"><a class="header" href="#duration-parsing">Duration Parsing</a></h3>
<p>Duration accepts both string and integer (nanoseconds) when unmarshaling:</p>
<pre><code class="language-go">type Config struct {
    Timeout Duration `json:"timeout"`
}

// String format
json.Unmarshal([]byte(`{"timeout":"1h30m"}`), &amp;cfg)
fmt.Println(cfg.Timeout.Duration())  // 1h30m0s

// Integer format (nanoseconds)
json.Unmarshal([]byte(`{"timeout":5400000000000}`), &amp;cfg)
fmt.Println(cfg.Timeout.Duration())  // 1h30m0s
</code></pre>
<h3 id="time-arithmetic"><a class="header" href="#time-arithmetic">Time Arithmetic</a></h3>
<pre><code class="language-go">now := NowEpoch()
later := now.Add(24 * time.Hour)

if later.After(now) {
    diff := later.Sub(now)
    fmt.Println(diff)  // 24h0m0s
}
</code></pre>
<h3 id="null-handling-3"><a class="header" href="#null-handling-3">Null Handling</a></h3>
<pre><code class="language-go">var d Duration
json.Unmarshal([]byte(`null`), &amp;d)  // d remains zero value
</code></pre>
<h2 id="implementation-details-3"><a class="header" href="#implementation-details-3">Implementation Details</a></h2>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h3>
<p>All types are direct aliases, allowing easy conversion:</p>
<pre><code class="language-go">// Unix -&gt; time.Time
t := time.Time(myUnix)

// time.Time -&gt; Unix
u := Unix(time.Now())

// Duration -&gt; time.Duration
d := time.Duration(myDuration)
</code></pre>
<h3 id="json-marshal-output"><a class="header" href="#json-marshal-output">JSON Marshal Output</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Go Value</th><th>JSON Output</th></tr></thead><tbody>
<tr><td>Unix</td><td><code>Unix(time.Now())</code></td><td><code>1705315800</code></td></tr>
<tr><td>Milli</td><td><code>Milli(time.Now())</code></td><td><code>1705315800000</code></td></tr>
<tr><td>Duration</td><td><code>Duration(90*time.Second)</code></td><td><code>"1m30s"</code></td></tr>
</tbody></table>
</div>
<h2 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h2>
<ul>
<li><code>time</code> (stdlib)</li>
<li><code>encoding/json</code> (stdlib)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsontime-package---rust-implementation"><a class="header" href="#jsontime-package---rust-implementation">JsonTime Package - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-jsontime</code></p>
<h2 id="types-7"><a class="header" href="#types-7">Types</a></h2>
<h3 id="unix-1"><a class="header" href="#unix-1">Unix</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct Unix(DateTime&lt;Utc&gt;);
<span class="boring">}</span></code></pre></pre>
<p>A timestamp that serializes to/from Unix seconds in JSON.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(dt: DateTime&lt;Utc&gt;) -&gt; Self</code></td><td>Create from DateTime</td></tr>
<tr><td><code>now</code></td><td><code>fn now() -&gt; Self</code></td><td>Current time</td></tr>
<tr><td><code>from_secs</code></td><td><code>fn from_secs(secs: i64) -&gt; Self</code></td><td>Create from seconds</td></tr>
<tr><td><code>as_secs</code></td><td><code>fn as_secs(&amp;self) -&gt; i64</code></td><td>Get seconds value</td></tr>
<tr><td><code>datetime</code></td><td><code>fn datetime(&amp;self) -&gt; DateTime&lt;Utc&gt;</code></td><td>Get underlying DateTime</td></tr>
<tr><td><code>before</code></td><td><code>fn before(&amp;self, other: &amp;Self) -&gt; bool</code></td><td>Is this before other?</td></tr>
<tr><td><code>after</code></td><td><code>fn after(&amp;self, other: &amp;Self) -&gt; bool</code></td><td>Is this after other?</td></tr>
<tr><td><code>is_zero</code></td><td><code>fn is_zero(&amp;self) -&gt; bool</code></td><td>Is zero time?</td></tr>
<tr><td><code>sub</code></td><td><code>fn sub(&amp;self, other: &amp;Self) -&gt; Duration</code></td><td>Duration between times</td></tr>
<tr><td><code>add</code></td><td><code>fn add(&amp;self, d: Duration) -&gt; Self</code></td><td>Return self+d</td></tr>
</tbody></table>
</div>
<p><strong>Trait Implementations:</strong></p>
<ul>
<li><code>Serialize</code> / <code>Deserialize</code> (serde)</li>
<li><code>Display</code></li>
<li><code>From&lt;DateTime&lt;Utc&gt;&gt;</code>, <code>From&lt;i64&gt;</code></li>
<li><code>PartialOrd</code>, <code>Ord</code>, <code>Hash</code></li>
</ul>
<h3 id="milli-1"><a class="header" href="#milli-1">Milli</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct Milli(DateTime&lt;Utc&gt;);
<span class="boring">}</span></code></pre></pre>
<p>A timestamp that serializes to/from Unix milliseconds in JSON.</p>
<p><strong>Methods:</strong> Same as Unix, but with milliseconds.</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>from_millis</code></td><td><code>fn from_millis(ms: i64) -&gt; Self</code></td><td>Create from milliseconds</td></tr>
<tr><td><code>as_millis</code></td><td><code>fn as_millis(&amp;self) -&gt; i64</code></td><td>Get milliseconds value</td></tr>
<tr><td>...</td><td></td><td>(same operations as Unix)</td></tr>
</tbody></table>
</div>
<h3 id="duration-1"><a class="header" href="#duration-1">Duration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct Duration(StdDuration);
<span class="boring">}</span></code></pre></pre>
<p>A duration that serializes to string (e.g., "1h30m") and deserializes from string or nanoseconds.</p>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(d: StdDuration) -&gt; Self</code></td><td>Create from std Duration</td></tr>
<tr><td><code>from_secs</code></td><td><code>fn from_secs(secs: u64) -&gt; Self</code></td><td>Create from seconds</td></tr>
<tr><td><code>from_millis</code></td><td><code>fn from_millis(ms: u64) -&gt; Self</code></td><td>Create from milliseconds</td></tr>
<tr><td><code>from_nanos</code></td><td><code>fn from_nanos(nanos: u64) -&gt; Self</code></td><td>Create from nanoseconds</td></tr>
<tr><td><code>as_std</code></td><td><code>fn as_std(&amp;self) -&gt; StdDuration</code></td><td>Get std Duration</td></tr>
<tr><td><code>as_secs</code></td><td><code>fn as_secs(&amp;self) -&gt; u64</code></td><td>Get whole seconds</td></tr>
<tr><td><code>as_secs_f64</code></td><td><code>fn as_secs_f64(&amp;self) -&gt; f64</code></td><td>Get floating seconds</td></tr>
<tr><td><code>as_millis</code></td><td><code>fn as_millis(&amp;self) -&gt; u128</code></td><td>Get milliseconds</td></tr>
<tr><td><code>as_nanos</code></td><td><code>fn as_nanos(&amp;self) -&gt; u128</code></td><td>Get nanoseconds</td></tr>
<tr><td><code>is_zero</code></td><td><code>fn is_zero(&amp;self) -&gt; bool</code></td><td>Is zero duration?</td></tr>
</tbody></table>
</div>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="in-struct-fields-3"><a class="header" href="#in-struct-fields-3">In Struct Fields</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_jsontime::{Unix, Milli, Duration};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Event {
    id: String,
    created_at: Unix,
    expires_at: Milli,
    timeout: Duration,
}

let event = Event {
    id: "evt-123".to_string(),
    created_at: Unix::now(),
    expires_at: Milli::now(),
    timeout: Duration::from_secs(30),
};

// Serializes to:
// {"id":"evt-123","created_at":1705315800,"expires_at":1705315800000,"timeout":"30s"}
<span class="boring">}</span></code></pre></pre>
<h3 id="duration-parsing-1"><a class="header" href="#duration-parsing-1">Duration Parsing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_jsontime::Duration;

// String format
let d: Duration = serde_json::from_str(r#""1h30m""#).unwrap();
assert_eq!(d.as_secs(), 5400);

// Integer format (nanoseconds)
let d: Duration = serde_json::from_str("5400000000000").unwrap();
assert_eq!(d.as_secs(), 5400);
<span class="boring">}</span></code></pre></pre>
<h3 id="time-arithmetic-1"><a class="header" href="#time-arithmetic-1">Time Arithmetic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_jsontime::Unix;
use std::time::Duration;

let now = Unix::now();
let later = now.add(Duration::from_secs(86400));

if later.after(&amp;now) {
    let diff = later.sub(&amp;now);
    println!("{:?}", diff);  // 86400s
}
<span class="boring">}</span></code></pre></pre>
<h3 id="from-conversions"><a class="header" href="#from-conversions">From Conversions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From i64
let unix = Unix::from(1705315800i64);
let milli = Milli::from(1705315800000i64);

// From DateTime&lt;Utc&gt;
let unix = Unix::from(Utc::now());

// From std::time::Duration
let dur = Duration::from(std::time::Duration::from_secs(60));
<span class="boring">}</span></code></pre></pre>
<h2 id="duration-string-format-1"><a class="header" href="#duration-string-format-1">Duration String Format</a></h2>
<p>The parser supports Go-style duration strings:</p>
<div class="table-wrapper"><table><thead><tr><th>Input</th><th>Parsed As</th></tr></thead><tbody>
<tr><td><code>"1h"</code></td><td>3600 seconds</td></tr>
<tr><td><code>"30m"</code></td><td>1800 seconds</td></tr>
<tr><td><code>"45s"</code></td><td>45 seconds</td></tr>
<tr><td><code>"1h30m"</code></td><td>5400 seconds</td></tr>
<tr><td><code>"1h30m45s"</code></td><td>5445 seconds</td></tr>
<tr><td><code>""</code></td><td>0 seconds</td></tr>
</tbody></table>
</div>
<h2 id="dependencies-3"><a class="header" href="#dependencies-3">Dependencies</a></h2>
<ul>
<li><code>chrono</code> crate (for DateTime handling)</li>
<li><code>serde</code> crate (for serialization)</li>
</ul>
<h2 id="differences-from-go-1"><a class="header" href="#differences-from-go-1">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Time type</td><td>Type alias <code>time.Time</code></td><td>Newtype over <code>DateTime&lt;Utc&gt;</code></td></tr>
<tr><td>Duration range</td><td>Signed (int64 ns)</td><td>Unsigned (u64 + u32 ns)</td></tr>
<tr><td>Ordering</td><td>Via method calls</td><td>Via <code>Ord</code> trait</td></tr>
<tr><td>Hash support</td><td>N/A</td><td>Implemented</td></tr>
<tr><td>sub() return</td><td>Signed duration</td><td>Unsigned duration</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="jsontime-package---known-issues"><a class="header" href="#jsontime-package---known-issues">JsonTime Package - Known Issues</a></h1>
<h2 id="-minor-issues-1"><a class="header" href="#-minor-issues-1">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="jt-001-rust-millisub-loses-sign-information"><a class="header" href="#jt-001-rust-millisub-loses-sign-information">JT-001: Rust Milli.sub() loses sign information</a></h3>
<p><strong>File:</strong> <code>rust/jsontime/src/milli.rs:54-57</code></p>
<p><strong>Description:</strong><br />
The <code>sub()</code> method returns an unsigned <code>Duration</code>, losing the sign when the result would be negative:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sub(&amp;self, other: &amp;Self) -&gt; Duration {
    let diff = self.0.signed_duration_since(other.0);
    Duration::from_millis(diff.num_milliseconds().unsigned_abs())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Impact:</strong> Cannot determine if <code>self</code> is before or after <code>other</code> from the result alone.</p>
<p><strong>Workaround:</strong> Use <code>before()</code> or <code>after()</code> methods to check ordering first.</p>
<hr />
<h3 id="jt-002-rust-unixsub-same-issue"><a class="header" href="#jt-002-rust-unixsub-same-issue">JT-002: Rust Unix.sub() same issue</a></h3>
<p><strong>File:</strong> <code>rust/jsontime/src/unix.rs:54-57</code></p>
<p><strong>Description:</strong><br />
Same issue as JT-001 - loses sign information.</p>
<hr />
<h3 id="jt-003-rust-duration-parsing-more-restrictive-than-go"><a class="header" href="#jt-003-rust-duration-parsing-more-restrictive-than-go">JT-003: Rust Duration parsing more restrictive than Go</a></h3>
<p><strong>File:</strong> <code>rust/jsontime/src/duration.rs:123-158</code></p>
<p><strong>Description:</strong><br />
Go's <code>time.ParseDuration</code> supports more units:</p>
<ul>
<li><code>ns</code> (nanoseconds)</li>
<li><code>us</code>/<code>Âµs</code> (microseconds)</li>
<li><code>ms</code> (milliseconds)</li>
</ul>
<p>Rust implementation only supports <code>h</code>, <code>m</code>, <code>s</code>.</p>
<p><strong>Impact:</strong> Duration strings with sub-second units fail to parse in Rust.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">// Go - works
d, _ := time.ParseDuration("100ms")

// Rust - fails
let d: Duration = serde_json::from_str(r#""100ms""#)?;  // Error!
</code></pre>
<hr />
<h3 id="jt-004-rust-duration-cannot-be-negative"><a class="header" href="#jt-004-rust-duration-cannot-be-negative">JT-004: Rust Duration cannot be negative</a></h3>
<p><strong>Description:</strong><br />
Go's <code>time.Duration</code> is signed (int64), Rust's <code>std::time::Duration</code> is unsigned.</p>
<p><strong>Impact:</strong> Cannot represent negative durations in Rust.</p>
<p><strong>Status:</strong> By design (Rust stdlib limitation).</p>
<hr />
<h2 id="-enhancements-2"><a class="header" href="#-enhancements-2">ğŸ”µ Enhancements</a></h2>
<h3 id="jt-005-missing-microsecond-timestamp-type"><a class="header" href="#jt-005-missing-microsecond-timestamp-type">JT-005: Missing microsecond timestamp type</a></h3>
<p><strong>Description:</strong><br />
Some APIs (particularly high-frequency systems) use microsecond timestamps. Neither Go nor Rust implementation provides a <code>Micro</code> type.</p>
<p><strong>Suggestion:</strong> Add <code>Micro</code> type for microsecond precision.</p>
<hr />
<h3 id="jt-006-missing-nanosecond-timestamp-type"><a class="header" href="#jt-006-missing-nanosecond-timestamp-type">JT-006: Missing nanosecond timestamp type</a></h3>
<p><strong>Description:</strong><br />
Some APIs use nanosecond timestamps. No <code>Nano</code> type provided.</p>
<p><strong>Suggestion:</strong> Add <code>Nano</code> type for nanosecond precision.</p>
<hr />
<h3 id="jt-007-go-duration-lacks-explicit-constructors"><a class="header" href="#jt-007-go-duration-lacks-explicit-constructors">JT-007: Go Duration lacks explicit constructors</a></h3>
<p><strong>Description:</strong><br />
Go implementation lacks explicit constructors like Rust has:</p>
<ul>
<li><code>from_secs()</code></li>
<li><code>from_millis()</code></li>
</ul>
<p><strong>Current Go usage:</strong></p>
<pre><code class="language-go">d := Duration(30 * time.Second)
</code></pre>
<p><strong>Suggested addition:</strong></p>
<pre><code class="language-go">func DurationFromSeconds(s int64) Duration
func DurationFromMillis(ms int64) Duration
</code></pre>
<hr />
<h2 id="-notes-2"><a class="header" href="#-notes-2">âšª Notes</a></h2>
<h3 id="jt-008-different-underlying-time-libraries"><a class="header" href="#jt-008-different-underlying-time-libraries">JT-008: Different underlying time libraries</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: Uses stdlib <code>time.Time</code></li>
<li>Rust: Uses <code>chrono::DateTime&lt;Utc&gt;</code></li>
</ul>
<p><strong>Impact:</strong> Rust has hard dependency on <code>chrono</code> crate.</p>
<hr />
<h3 id="jt-009-rust-types-implement-more-traits"><a class="header" href="#jt-009-rust-types-implement-more-traits">JT-009: Rust types implement more traits</a></h3>
<p><strong>Description:</strong><br />
Rust types implement <code>PartialOrd</code>, <code>Ord</code>, <code>Hash</code> which enables use in collections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;
let mut times: HashSet&lt;Unix&gt; = HashSet::new();
times.insert(Unix::now());
<span class="boring">}</span></code></pre></pre>
<p>Go types don't have equivalent functionality.</p>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>JT-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Milli</td></tr>
<tr><td>JT-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Unix</td></tr>
<tr><td>JT-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Duration</td></tr>
<tr><td>JT-004</td><td>ğŸŸ¡ Minor</td><td>By design</td><td>Rust Duration</td></tr>
<tr><td>JT-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>JT-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>JT-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>JT-008</td><td>âšª Note</td><td>N/A</td><td>Rust</td></tr>
<tr><td>JT-009</td><td>âšª Note</td><td>N/A</td><td>Rust</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Functional implementation. Main concern is duration parsing parity between Go and Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trie-package"><a class="header" href="#trie-package">Trie Package</a></h1>
<p>Generic trie data structure for efficient path-based storage and retrieval with MQTT-style wildcard support.</p>
<h2 id="design-goals-3"><a class="header" href="#design-goals-3">Design Goals</a></h2>
<ol>
<li><strong>Efficient Path Matching</strong>: O(k) lookup where k is path depth</li>
<li><strong>Wildcard Support</strong>: MQTT-style single (<code>+</code>) and multi-level (<code>#</code>) wildcards</li>
<li><strong>Generic Storage</strong>: Store any value type at path nodes</li>
<li><strong>Zero-Copy Lookups</strong>: Minimize allocations during get operations</li>
</ol>
<h2 id="wildcard-patterns"><a class="header" href="#wildcard-patterns">Wildcard Patterns</a></h2>
<p>The trie supports MQTT-style topic patterns:</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Description</th><th>Example Match</th></tr></thead><tbody>
<tr><td><code>a/b/c</code></td><td>Exact path</td><td><code>a/b/c</code> only</td></tr>
<tr><td><code>a/+/c</code></td><td>Single-level wildcard</td><td><code>a/X/c</code>, <code>a/Y/c</code></td></tr>
<tr><td><code>a/#</code></td><td>Multi-level wildcard</td><td><code>a/b</code>, <code>a/b/c/d</code></td></tr>
</tbody></table>
</div>
<h3 id="pattern-rules"><a class="header" href="#pattern-rules">Pattern Rules</a></h3>
<ol>
<li>
<p><strong><code>+</code> (Plus)</strong>: Matches exactly one path segment</p>
<ul>
<li><code>device/+/state</code> matches <code>device/gear-001/state</code></li>
<li>Does NOT match <code>device/gear-001/sub/state</code></li>
</ul>
</li>
<li>
<p><strong><code>#</code> (Hash)</strong>: Matches zero or more path segments</p>
<ul>
<li>Must be the last segment in the pattern</li>
<li><code>logs/#</code> matches <code>logs</code>, <code>logs/app</code>, <code>logs/app/debug/line1</code></li>
</ul>
</li>
<li>
<p><strong>Priority</strong>: Exact matches take precedence over wildcards</p>
<ul>
<li>If both <code>device/gear-001/state</code> and <code>device/+/state</code> exist, exact wins</li>
</ul>
</li>
</ol>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="mqtt-topic-routing"><a class="header" href="#mqtt-topic-routing">MQTT Topic Routing</a></h3>
<pre><code>device/+/state     -&gt; state_handler
device/+/command   -&gt; command_handler
logs/#             -&gt; log_handler
</code></pre>
<h3 id="api-path-routing"><a class="header" href="#api-path-routing">API Path Routing</a></h3>
<pre><code>/users/{id}/profile  -&gt; profile_handler
/users/{id}/posts    -&gt; posts_handler
/admin/#             -&gt; admin_handler
</code></pre>
<h3 id="hierarchical-configuration"><a class="header" href="#hierarchical-configuration">Hierarchical Configuration</a></h3>
<pre><code>app/database/host    -&gt; "localhost"
app/database/port    -&gt; 5432
app/cache/#          -&gt; cache_config
</code></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th><th>Notes</th></tr></thead><tbody>
<tr><td>Set</td><td>O(k)</td><td>k = path depth</td></tr>
<tr><td>Get</td><td>O(k)</td><td>Zero allocation in Rust</td></tr>
<tr><td>Walk</td><td>O(n)</td><td>n = total nodes</td></tr>
<tr><td>Len</td><td>O(n)</td><td>Counts all values</td></tr>
</tbody></table>
</div>
<h2 id="examples-directory-3"><a class="header" href="#examples-directory-3">Examples Directory</a></h2>
<ul>
<li><code>examples/go/trie/</code> - Go usage examples (if any)</li>
<li><code>examples/rust/trie/</code> - Rust usage examples (if any)</li>
</ul>
<h2 id="related-packages-3"><a class="header" href="#related-packages-3">Related Packages</a></h2>
<ul>
<li><code>mqtt0</code> - Uses trie for topic subscription matching</li>
<li><code>chatgear</code> - Uses trie for message routing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trie-package---go-implementation"><a class="header" href="#trie-package---go-implementation">Trie Package - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/trie</code></p>
<h2 id="types-8"><a class="header" href="#types-8">Types</a></h2>
<h3 id="triet"><a class="header" href="#triet">Trie[T]</a></h3>
<pre><code class="language-go">type Trie[T any] struct {
    children map[string]*Trie[T] // exact path segment matches
    matchAny *Trie[T]            // single-level wildcard (+)
    matchAll *Trie[T]            // multi-level wildcard (#)
    set      bool                // whether this node has a value
    value    T                   // the value stored
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>New</code></td><td><code>func New[T any]() *Trie[T]</code></td><td>Create empty trie</td></tr>
<tr><td><code>Set</code></td><td><code>(t *Trie[T]) Set(path string, setFunc func(*T, bool) error) error</code></td><td>Set with custom setter</td></tr>
<tr><td><code>SetValue</code></td><td><code>(t *Trie[T]) SetValue(path string, value T) error</code></td><td>Set value directly</td></tr>
<tr><td><code>Get</code></td><td><code>(t *Trie[T]) Get(path string) (*T, bool)</code></td><td>Get value pointer</td></tr>
<tr><td><code>GetValue</code></td><td><code>(t *Trie[T]) GetValue(path string) (T, bool)</code></td><td>Get value copy</td></tr>
<tr><td><code>Match</code></td><td><code>(t *Trie[T]) Match(path string) (route string, value *T, ok bool)</code></td><td>Get with matched route</td></tr>
<tr><td><code>Walk</code></td><td><code>(t *Trie[T]) Walk(f func(path string, value T, set bool))</code></td><td>Visit all nodes</td></tr>
<tr><td><code>Len</code></td><td><code>(t *Trie[T]) Len() int</code></td><td>Count values</td></tr>
<tr><td><code>String</code></td><td><code>(t *Trie[T]) String() string</code></td><td>Debug representation</td></tr>
</tbody></table>
</div>
<h3 id="errinvalidpattern"><a class="header" href="#errinvalidpattern">ErrInvalidPattern</a></h3>
<pre><code class="language-go">var ErrInvalidPattern = errors.New("invalid path pattern...")
</code></pre>
<p>Returned when <code>#</code> wildcard is not at the end of the path.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<h3 id="basic-setget"><a class="header" href="#basic-setget">Basic Set/Get</a></h3>
<pre><code class="language-go">tr := trie.New[string]()

// Set exact path
tr.SetValue("device/gear-001/state", "online")

// Get value
val, ok := tr.GetValue("device/gear-001/state")
// val = "online", ok = true
</code></pre>
<h3 id="wildcard-patterns-1"><a class="header" href="#wildcard-patterns-1">Wildcard Patterns</a></h3>
<pre><code class="language-go">tr := trie.New[string]()

// Single-level wildcard
tr.SetValue("device/+/state", "state_handler")

// Multi-level wildcard
tr.SetValue("logs/#", "log_handler")

// Match against patterns
val, _ := tr.GetValue("device/any-device/state")
// val = "state_handler"

val, _ = tr.GetValue("logs/app/debug/line1")
// val = "log_handler"
</code></pre>
<h3 id="custom-set-function"><a class="header" href="#custom-set-function">Custom Set Function</a></h3>
<pre><code class="language-go">tr := trie.New[[]string]()

// Append to existing value
tr.Set("handlers/events", func(ptr *[]string, existed bool) error {
    if !existed {
        *ptr = []string{"handler1"}
    } else {
        *ptr = append(*ptr, "handler2")
    }
    return nil
})
</code></pre>
<h3 id="walk-all-nodes"><a class="header" href="#walk-all-nodes">Walk All Nodes</a></h3>
<pre><code class="language-go">tr.Walk(func(path string, value string, set bool) {
    if set {
        fmt.Printf("%s: %s\n", path, value)
    }
})
</code></pre>
<h3 id="match-with-route"><a class="header" href="#match-with-route">Match with Route</a></h3>
<pre><code class="language-go">tr := trie.New[string]()
tr.SetValue("device/+/state", "handler")

route, value, ok := tr.Match("device/gear-001/state")
// route = "/+/state"
// value = "handler"
// ok = true
</code></pre>
<h2 id="implementation-details-4"><a class="header" href="#implementation-details-4">Implementation Details</a></h2>
<h3 id="path-splitting"><a class="header" href="#path-splitting">Path Splitting</a></h3>
<p>Paths are split by <code>/</code> and processed segment by segment:</p>
<pre><code class="language-go">// "device/gear-001/state" splits into:
// first="device", subseq="gear-001/state"
</code></pre>
<h3 id="value-storage"><a class="header" href="#value-storage">Value Storage</a></h3>
<p>Uses a <code>set</code> boolean flag to distinguish between:</p>
<ul>
<li>Value not set (default zero value)</li>
<li>Value explicitly set to zero value</li>
</ul>
<h3 id="match-priority"><a class="header" href="#match-priority">Match Priority</a></h3>
<ol>
<li>Exact child match</li>
<li>Single-level wildcard (<code>+</code>)</li>
<li>Multi-level wildcard (<code>#</code>)</li>
</ol>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>Typical performance (from benchmarks):</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>100 paths</th><th>1000 paths</th><th>10000 paths</th></tr></thead><tbody>
<tr><td>Set all</td><td>~50Âµs</td><td>~500Âµs</td><td>~5ms</td></tr>
<tr><td>Get (exact)</td><td>~10Âµs</td><td>~100Âµs</td><td>~1ms</td></tr>
<tr><td>Walk</td><td>~5Âµs</td><td>~50Âµs</td><td>~500Âµs</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="trie-package---rust-implementation"><a class="header" href="#trie-package---rust-implementation">Trie Package - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-trie</code></p>
<h2 id="types-9"><a class="header" href="#types-9">Types</a></h2>
<h3 id="trie"><a class="header" href="#trie">Trie<T></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct Trie&lt;T&gt; {
    children: HashMap&lt;String, Trie&lt;T&gt;&gt;,
    match_any: Option&lt;Box&lt;Trie&lt;T&gt;&gt;&gt;,  // single-level wildcard (+)
    match_all: Option&lt;Box&lt;Trie&lt;T&gt;&gt;&gt;,  // multi-level wildcard (#)
    value: Option&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new() -&gt; Self</code></td><td>Create empty trie</td></tr>
<tr><td><code>set</code></td><td><code>fn set&lt;F, E&gt;(&amp;mut self, path: &amp;str, setter: F) -&gt; Result&lt;(), E&gt;</code></td><td>Set with custom setter</td></tr>
<tr><td><code>set_value</code></td><td><code>fn set_value(&amp;mut self, path: &amp;str, value: T) -&gt; Result&lt;(), InvalidPatternError&gt;</code></td><td>Set value directly</td></tr>
<tr><td><code>get</code></td><td><code>fn get(&amp;self, path: &amp;str) -&gt; Option&lt;&amp;T&gt;</code></td><td>Get value reference (zero-alloc)</td></tr>
<tr><td><code>get_value</code></td><td><code>fn get_value(&amp;self, path: &amp;str) -&gt; Option&lt;T&gt;</code></td><td>Get cloned value</td></tr>
<tr><td><code>match_path</code></td><td><code>fn match_path(&amp;self, path: &amp;str) -&gt; (String, Option&lt;&amp;T&gt;)</code></td><td>Get with matched route</td></tr>
<tr><td><code>walk</code></td><td><code>fn walk&lt;F&gt;(&amp;self, f: F)</code></td><td>Visit all nodes</td></tr>
<tr><td><code>len</code></td><td><code>fn len(&amp;self) -&gt; usize</code></td><td>Count values</td></tr>
<tr><td><code>is_empty</code></td><td><code>fn is_empty(&amp;self) -&gt; bool</code></td><td>Check if empty</td></tr>
</tbody></table>
</div>
<p><strong>Trait Implementations:</strong></p>
<ul>
<li><code>Default</code></li>
<li><code>Clone</code></li>
<li><code>Debug</code></li>
<li><code>Display</code> (when <code>T: Display</code>)</li>
</ul>
<h3 id="invalidpatternerror"><a class="header" href="#invalidpatternerror">InvalidPatternError</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
#[error("invalid path pattern: path should be /a/b/c or /a/+/c or /a/#")]
pub struct InvalidPatternError;
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<h3 id="basic-setget-1"><a class="header" href="#basic-setget-1">Basic Set/Get</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_trie::Trie;

let mut trie = Trie::&lt;String&gt;::new();

// Set exact path
trie.set_value("device/gear-001/state", "online".to_string()).unwrap();

// Get value (zero allocation)
let val: Option&lt;&amp;String&gt; = trie.get("device/gear-001/state");

// Get cloned value
let val: Option&lt;String&gt; = trie.get_value("device/gear-001/state");
<span class="boring">}</span></code></pre></pre>
<h3 id="wildcard-patterns-2"><a class="header" href="#wildcard-patterns-2">Wildcard Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut trie = Trie::&lt;String&gt;::new();

// Single-level wildcard
trie.set_value("device/+/state", "state_handler".to_string()).unwrap();

// Multi-level wildcard
trie.set_value("logs/#", "log_handler".to_string()).unwrap();

// Match against patterns
let val = trie.get("device/any-device/state");
assert_eq!(val, Some(&amp;"state_handler".to_string()));

let val = trie.get("logs/app/debug/line1");
assert_eq!(val, Some(&amp;"log_handler".to_string()));
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-set-function-1"><a class="header" href="#custom-set-function-1">Custom Set Function</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut trie = Trie::&lt;Vec&lt;String&gt;&gt;::new();

// Set with custom logic
trie.set("handlers/events", |existing| {
    match existing {
        Some(vec) =&gt; {
            vec.push("handler2".to_string());
            Ok(vec.clone())
        }
        None =&gt; Ok(vec!["handler1".to_string()]),
    }
}).unwrap();
<span class="boring">}</span></code></pre></pre>
<h3 id="walk-all-nodes-1"><a class="header" href="#walk-all-nodes-1">Walk All Nodes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trie.walk(|path, value| {
    println!("{}: {}", path, value);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="match-with-route-1"><a class="header" href="#match-with-route-1">Match with Route</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut trie = Trie::&lt;String&gt;::new();
trie.set_value("device/+/state", "handler".to_string()).unwrap();

let (route, value) = trie.match_path("device/gear-001/state");
// route = "/device/+/state"
// value = Some(&amp;"handler")
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-details-5"><a class="header" href="#implementation-details-5">Implementation Details</a></h2>
<h3 id="zero-allocation-lookup"><a class="header" href="#zero-allocation-lookup">Zero-Allocation Lookup</a></h3>
<p>The <code>get()</code> method performs zero allocations by:</p>
<ul>
<li>Using string slices for path splitting</li>
<li>Returning references instead of cloned values</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
fn split_path(path: &amp;str) -&gt; (&amp;str, &amp;str) {
    match path.find('/') {
        Some(idx) =&gt; (&amp;path[..idx], &amp;path[idx + 1..]),
        None =&gt; (path, ""),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="value-storage-1"><a class="header" href="#value-storage-1">Value Storage</a></h3>
<p>Uses <code>Option&lt;T&gt;</code> instead of a separate flag:</p>
<ul>
<li><code>None</code> = value not set</li>
<li><code>Some(T)</code> = value set</li>
</ul>
<h3 id="wildcard-storage"><a class="header" href="#wildcard-storage">Wildcard Storage</a></h3>
<ul>
<li><code>match_any</code>: <code>Option&lt;Box&lt;Trie&lt;T&gt;&gt;&gt;</code> for <code>+</code> wildcard</li>
<li><code>match_all</code>: <code>Option&lt;Box&lt;Trie&lt;T&gt;&gt;&gt;</code> for <code>#</code> wildcard</li>
</ul>
<p>Boxed to avoid recursive type sizing issues.</p>
<h2 id="differences-from-go-2"><a class="header" href="#differences-from-go-2">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Value storage</td><td><code>set bool</code> + <code>value T</code></td><td><code>Option&lt;T&gt;</code></td></tr>
<tr><td>Child storage</td><td><code>map[string]*Trie[T]</code></td><td><code>HashMap&lt;String, Trie&lt;T&gt;&gt;</code></td></tr>
<tr><td>Wildcard storage</td><td><code>*Trie[T]</code> (pointer)</td><td><code>Option&lt;Box&lt;Trie&lt;T&gt;&gt;&gt;</code></td></tr>
<tr><td>Get return</td><td><code>(*T, bool)</code></td><td><code>Option&lt;&amp;T&gt;</code></td></tr>
<tr><td>Clone support</td><td>Implicit (pointer)</td><td>Explicit <code>Clone</code> derive</td></tr>
<tr><td>Zero-alloc get</td><td>No (returns route string)</td><td>Yes (<code>get()</code> method)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="trie-package---known-issues"><a class="header" href="#trie-package---known-issues">Trie Package - Known Issues</a></h1>
<h2 id="-minor-issues-2"><a class="header" href="#-minor-issues-2">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="tri-001-go-walk-visits-unset-nodes"><a class="header" href="#tri-001-go-walk-visits-unset-nodes">TRI-001: Go Walk visits unset nodes</a></h3>
<p><strong>File:</strong> <code>go/pkg/trie/trie.go:175-179</code></p>
<p><strong>Description:</strong><br />
The <code>Walk</code> function visits ALL nodes including those without values set, passing the zero value:</p>
<pre><code class="language-go">func (t *Trie[T]) Walk(f func(path string, value T, set bool)) {
    t.walkWithPath(nil, func(path []string, node *Trie[T]) {
        f(strings.Join(path, "/"), node.value, node.set)  // value may be zero
    })
}
</code></pre>
<p><strong>Impact:</strong> Callers must check the <code>set</code> boolean to filter actual values.</p>
<p><strong>Suggestion:</strong> Consider only visiting nodes where <code>set == true</code> by default.</p>
<hr />
<h3 id="tri-002-go-len-is-on-not-o1"><a class="header" href="#tri-002-go-len-is-on-not-o1">TRI-002: Go Len() is O(n) not O(1)</a></h3>
<p><strong>File:</strong> <code>go/pkg/trie/trie.go:211-219</code></p>
<p><strong>Description:</strong><br />
<code>Len()</code> walks the entire trie to count values:</p>
<pre><code class="language-go">func (t *Trie[T]) Len() int {
    count := 0
    t.Walk(func(_ string, _ T, set bool) {
        if set {
            count++
        }
    })
    return count
}
</code></pre>
<p><strong>Impact:</strong> Performance issue for large tries with frequent <code>Len()</code> calls.</p>
<p><strong>Suggestion:</strong> Maintain a counter that increments on Set and decrements on Delete.</p>
<hr />
<h3 id="tri-003-rust-len-same-on-issue"><a class="header" href="#tri-003-rust-len-same-on-issue">TRI-003: Rust Len() same O(n) issue</a></h3>
<p><strong>File:</strong> <code>rust/trie/src/lib.rs:292-296</code></p>
<p><strong>Description:</strong><br />
Same issue as Go - walks entire trie to count.</p>
<hr />
<h3 id="tri-004-no-delete-operation"><a class="header" href="#tri-004-no-delete-operation">TRI-004: No Delete operation</a></h3>
<p><strong>Description:</strong><br />
Neither Go nor Rust implementation provides a way to delete/remove values from the trie.</p>
<p><strong>Impact:</strong> Cannot remove stale subscriptions or routes without rebuilding.</p>
<p><strong>Suggestion:</strong> Add <code>Delete(path string) bool</code> method.</p>
<hr />
<h3 id="tri-005-go-match-returns-route-with-leading-slash-inconsistency"><a class="header" href="#tri-005-go-match-returns-route-with-leading-slash-inconsistency">TRI-005: Go Match returns route with leading slash inconsistency</a></h3>
<p><strong>File:</strong> <code>go/pkg/trie/trie.go:142-172</code></p>
<p><strong>Description:</strong><br />
When building the matched route string, it prepends "/" to each segment:</p>
<pre><code class="language-go">ch.match(matched+"/"+first, subseq)  // Results in "/device/+/state"
</code></pre>
<p>But the root path returns empty string, creating inconsistency.</p>
<hr />
<h2 id="-enhancements-3"><a class="header" href="#-enhancements-3">ğŸ”µ Enhancements</a></h2>
<h3 id="tri-006-no-thread-safety"><a class="header" href="#tri-006-no-thread-safety">TRI-006: No thread safety</a></h3>
<p><strong>Description:</strong><br />
Neither implementation is thread-safe. Concurrent read/write will cause data races.</p>
<p><strong>Go:</strong></p>
<pre><code class="language-go">// UNSAFE: concurrent access
go trie.Set("a/b", value1)
go trie.Set("a/c", value2)
</code></pre>
<p><strong>Suggestion:</strong> Add <code>sync.RWMutex</code> wrapper or document thread-safety requirements.</p>
<hr />
<h3 id="tri-007-no-path-parameter-extraction"><a class="header" href="#tri-007-no-path-parameter-extraction">TRI-007: No path parameter extraction</a></h3>
<p><strong>Description:</strong><br />
When matching <code>device/+/state</code> against <code>device/gear-001/state</code>, there's no way to extract <code>gear-001</code> as a parameter.</p>
<p><strong>Current:</strong> Only returns the matched route pattern and value.</p>
<p><strong>Suggestion:</strong> Add <code>MatchParams(path) (params map[string]string, value *T, ok bool)</code>.</p>
<hr />
<h3 id="tri-008-no-prefix-listing"><a class="header" href="#tri-008-no-prefix-listing">TRI-008: No prefix listing</a></h3>
<p><strong>Description:</strong><br />
Cannot list all paths under a prefix efficiently.</p>
<p><strong>Example use case:</strong> List all devices under <code>device/</code> prefix.</p>
<p><strong>Suggestion:</strong> Add <code>List(prefix string) []string</code> method.</p>
<hr />
<h2 id="-notes-3"><a class="header" href="#-notes-3">âšª Notes</a></h2>
<h3 id="tri-009-different-value-storage-approaches"><a class="header" href="#tri-009-different-value-storage-approaches">TRI-009: Different value storage approaches</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: Uses <code>set bool</code> flag with zero value</li>
<li>Rust: Uses <code>Option&lt;T&gt;</code></li>
</ul>
<p>Both approaches work but have different trade-offs:</p>
<ul>
<li>Go: Can distinguish "set to zero" vs "not set"</li>
<li>Rust: More idiomatic, less memory overhead</li>
</ul>
<hr />
<h3 id="tri-010-path-leading-slash-handling"><a class="header" href="#tri-010-path-leading-slash-handling">TRI-010: Path leading slash handling</a></h3>
<p><strong>Description:</strong><br />
Paths can start with or without <code>/</code>:</p>
<ul>
<li><code>"/a/b/c"</code> and <code>"a/b/c"</code> are NOT equivalent</li>
<li>Leading <code>/</code> creates an empty string segment</li>
</ul>
<pre><code class="language-go">trie.SetValue("/a/b", "val1")  // path segments: ["", "a", "b"]
trie.SetValue("a/b", "val2")   // path segments: ["a", "b"]
</code></pre>
<p><strong>Status:</strong> Documented behavior but may be confusing.</p>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>TRI-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Walk</td></tr>
<tr><td>TRI-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Len</td></tr>
<tr><td>TRI-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Len</td></tr>
<tr><td>TRI-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>TRI-005</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Match</td></tr>
<tr><td>TRI-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>TRI-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>TRI-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>TRI-009</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>TRI-010</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Solid implementation for basic trie operations. Missing Delete and thread-safety for production use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-package"><a class="header" href="#cli-package">CLI Package</a></h1>
<p>Common CLI utilities for giztoy command-line tools.</p>
<h2 id="design-goals-4"><a class="header" href="#design-goals-4">Design Goals</a></h2>
<ol>
<li><strong>Consistent UX</strong>: Shared patterns across all giztoy CLI tools</li>
<li><strong>kubectl-style Contexts</strong>: Multiple API configurations with context switching</li>
<li><strong>Flexible Output</strong>: Support JSON, YAML, and raw output formats</li>
<li><strong>Cross-Platform Paths</strong>: Standard directory structure for config/cache/logs</li>
</ol>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Config</strong></td><td>Multi-context configuration management</td></tr>
<tr><td><strong>Output</strong></td><td>Output formatting (JSON, YAML, raw)</td></tr>
<tr><td><strong>Paths</strong></td><td>Directory structure (~/.giztoy/<app>/)</td></tr>
<tr><td><strong>Request</strong></td><td>Load request data from YAML/JSON files</td></tr>
<tr><td><strong>LogWriter</strong></td><td>Capture logs for TUI display</td></tr>
</tbody></table>
</div>
<h2 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h2>
<pre><code>~/.giztoy/
â”œâ”€â”€ minimax/
â”‚   â”œâ”€â”€ config.yaml
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ logs/
â”‚   â””â”€â”€ data/
â”œâ”€â”€ doubao/
â”‚   â”œâ”€â”€ config.yaml
â”‚   â”œâ”€â”€ cache/
â”‚   â””â”€â”€ ...
â””â”€â”€ dashscope/
    â””â”€â”€ ...
</code></pre>
<h2 id="configuration-format"><a class="header" href="#configuration-format">Configuration Format</a></h2>
<pre><code class="language-yaml">current_context: production

contexts:
  production:
    name: production
    api_key: "sk-..."
    base_url: "https://api.example.com"
    timeout: 30
    extra:
      region: "us-west"
  
  development:
    name: development
    api_key: "sk-dev-..."
    base_url: "https://dev-api.example.com"
</code></pre>
<h2 id="context-system"><a class="header" href="#context-system">Context System</a></h2>
<p>Similar to kubectl, supports multiple API contexts:</p>
<pre><code class="language-bash"># List contexts
myapp config list

# Use a context
myapp config use production

# Add a context
myapp config add staging --api-key=sk-...

# Delete a context
myapp config delete staging
</code></pre>
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>YAML</td><td><code>--output=yaml</code></td><td>Default, human-readable</td></tr>
<tr><td>JSON</td><td><code>--output=json</code></td><td>Machine-readable</td></tr>
<tr><td>Raw</td><td><code>--output=raw</code></td><td>Binary/raw data</td></tr>
</tbody></table>
</div>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="api-cli-tools"><a class="header" href="#api-cli-tools">API CLI Tools</a></h3>
<pre><code class="language-bash"># minimax CLI
minimax chat "Hello" --context=production --output=json

# doubao CLI  
doubao tts "Hello world" --output=audio.mp3
</code></pre>
<h3 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h3>
<pre><code class="language-bash"># View current config
myapp config show

# Set default voice
myapp config set default_voice "zh-CN-Standard-A"
</code></pre>
<h2 id="examples-directory-4"><a class="header" href="#examples-directory-4">Examples Directory</a></h2>
<ul>
<li><code>go/cmd/minimax/</code> - MiniMax CLI using this package</li>
<li><code>go/cmd/doubaospeech/</code> - Doubao Speech CLI</li>
<li><code>rust/cmd/minimax/</code> - Rust MiniMax CLI</li>
</ul>
<h2 id="related-packages-4"><a class="header" href="#related-packages-4">Related Packages</a></h2>
<ul>
<li>Used by all CLI tools in the project</li>
<li>Provides consistent user experience across Go and Rust implementations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-package---go-implementation"><a class="header" href="#cli-package---go-implementation">CLI Package - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/cli</code></p>
<h2 id="types-10"><a class="header" href="#types-10">Types</a></h2>
<h3 id="config"><a class="header" href="#config">Config</a></h3>
<pre><code class="language-go">type Config struct {
    AppName        string              `yaml:"-"`
    CurrentContext string              `yaml:"current_context,omitempty"`
    Contexts       map[string]*Context `yaml:"contexts,omitempty"`
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>LoadConfig</code></td><td><code>func LoadConfig(appName string) (*Config, error)</code></td><td>Load from default path</td></tr>
<tr><td><code>LoadConfigWithPath</code></td><td><code>func LoadConfigWithPath(appName, path string) (*Config, error)</code></td><td>Load from custom path</td></tr>
<tr><td><code>Save</code></td><td><code>(c *Config) Save() error</code></td><td>Save to disk</td></tr>
<tr><td><code>Path</code></td><td><code>(c *Config) Path() string</code></td><td>Get config file path</td></tr>
<tr><td><code>Dir</code></td><td><code>(c *Config) Dir() string</code></td><td>Get config directory</td></tr>
<tr><td><code>AddContext</code></td><td><code>(c *Config) AddContext(name string, ctx *Context) error</code></td><td>Add context</td></tr>
<tr><td><code>DeleteContext</code></td><td><code>(c *Config) DeleteContext(name string) error</code></td><td>Delete context</td></tr>
<tr><td><code>UseContext</code></td><td><code>(c *Config) UseContext(name string) error</code></td><td>Set current context</td></tr>
<tr><td><code>GetContext</code></td><td><code>(c *Config) GetContext(name string) (*Context, error)</code></td><td>Get specific context</td></tr>
<tr><td><code>GetCurrentContext</code></td><td><code>(c *Config) GetCurrentContext() (*Context, error)</code></td><td>Get current context</td></tr>
<tr><td><code>ResolveContext</code></td><td><code>(c *Config) ResolveContext(name string) (*Context, error)</code></td><td>Resolve by name or current</td></tr>
<tr><td><code>ListContexts</code></td><td><code>(c *Config) ListContexts() []string</code></td><td>List all context names</td></tr>
</tbody></table>
</div>
<h3 id="context"><a class="header" href="#context">Context</a></h3>
<pre><code class="language-go">type Context struct {
    Name         string              `yaml:"name"`
    Client       *ClientCredentials  `yaml:"client,omitempty"`
    Console      *ConsoleCredentials `yaml:"console,omitempty"`
    APIKey       string              `yaml:"api_key,omitempty"`
    BaseURL      string              `yaml:"base_url,omitempty"`
    Timeout      int                 `yaml:"timeout,omitempty"`
    MaxRetries   int                 `yaml:"max_retries,omitempty"`
    DefaultVoice string              `yaml:"default_voice,omitempty"`
    Extra        map[string]string   `yaml:"extra,omitempty"`
}
</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><code class="language-go">type OutputFormat string

const (
    FormatYAML  OutputFormat = "yaml"
    FormatJSON  OutputFormat = "json"
    FormatTable OutputFormat = "table"
    FormatRaw   OutputFormat = "raw"
)

type OutputOptions struct {
    Format OutputFormat
    File   string
    Indent string
    Writer io.Writer
}
</code></pre>
<p><strong>Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Output</code></td><td><code>func Output(result any, opts OutputOptions) error</code></td><td>Write formatted output</td></tr>
<tr><td><code>OutputBytes</code></td><td><code>func OutputBytes(data []byte, path string) error</code></td><td>Write binary data</td></tr>
<tr><td><code>PrintSuccess</code></td><td><code>func PrintSuccess(format string, args ...any)</code></td><td>Print âœ“ message</td></tr>
<tr><td><code>PrintError</code></td><td><code>func PrintError(format string, args ...any)</code></td><td>Print error to stderr</td></tr>
<tr><td><code>PrintInfo</code></td><td><code>func PrintInfo(format string, args ...any)</code></td><td>Print â„¹ message</td></tr>
<tr><td><code>PrintWarning</code></td><td><code>func PrintWarning(format string, args ...any)</code></td><td>Print âš  message</td></tr>
<tr><td><code>PrintVerbose</code></td><td><code>func PrintVerbose(verbose bool, format string, args ...any)</code></td><td>Conditional verbose</td></tr>
</tbody></table>
</div>
<h3 id="paths"><a class="header" href="#paths">Paths</a></h3>
<pre><code class="language-go">type Paths struct {
    AppName string
    HomeDir string
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewPaths</code></td><td><code>func NewPaths(appName string) (*Paths, error)</code></td><td>Create paths instance</td></tr>
<tr><td><code>BaseDir</code></td><td><code>(p *Paths) BaseDir() string</code></td><td>~/.giztoy</td></tr>
<tr><td><code>AppDir</code></td><td><code>(p *Paths) AppDir() string</code></td><td>~/.giztoy/<app></td></tr>
<tr><td><code>ConfigFile</code></td><td><code>(p *Paths) ConfigFile() string</code></td><td>~/.giztoy/<app>/config.yaml</td></tr>
<tr><td><code>CacheDir</code></td><td><code>(p *Paths) CacheDir() string</code></td><td>~/.giztoy/<app>/cache</td></tr>
<tr><td><code>LogDir</code></td><td><code>(p *Paths) LogDir() string</code></td><td>~/.giztoy/<app>/logs</td></tr>
<tr><td><code>DataDir</code></td><td><code>(p *Paths) DataDir() string</code></td><td>~/.giztoy/<app>/data</td></tr>
<tr><td><code>EnsureAppDir</code></td><td><code>(p *Paths) EnsureAppDir() error</code></td><td>Create app dir</td></tr>
<tr><td><code>CachePath</code></td><td><code>(p *Paths) CachePath(name string) string</code></td><td>Path in cache</td></tr>
<tr><td><code>LogPath</code></td><td><code>(p *Paths) LogPath(name string) string</code></td><td>Path in logs</td></tr>
<tr><td><code>DataPath</code></td><td><code>(p *Paths) DataPath(name string) string</code></td><td>Path in data</td></tr>
</tbody></table>
</div>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<h3 id="load-configuration"><a class="header" href="#load-configuration">Load Configuration</a></h3>
<pre><code class="language-go">cfg, err := cli.LoadConfig("minimax")
if err != nil {
    log.Fatal(err)
}

// Get current context
ctx, err := cfg.GetCurrentContext()
if err != nil {
    log.Fatal(err)
}

fmt.Println("API Key:", cli.MaskAPIKey(ctx.APIKey))
</code></pre>
<h3 id="output-results"><a class="header" href="#output-results">Output Results</a></h3>
<pre><code class="language-go">result := map[string]string{"status": "ok", "message": "done"}

// Output as JSON to stdout
cli.Output(result, cli.OutputOptions{
    Format: cli.FormatJSON,
})

// Output as YAML to file
cli.Output(result, cli.OutputOptions{
    Format: cli.FormatYAML,
    File:   "output.yaml",
})
</code></pre>
<h3 id="print-helpers"><a class="header" href="#print-helpers">Print Helpers</a></h3>
<pre><code class="language-go">cli.PrintSuccess("Created context %q", "production")
cli.PrintError("Failed to connect: %v", err)
cli.PrintInfo("Using API endpoint: %s", baseURL)
cli.PrintWarning("Rate limit approaching")
cli.PrintVerbose(verbose, "Request: %+v", req)
</code></pre>
<h3 id="path-management"><a class="header" href="#path-management">Path Management</a></h3>
<pre><code class="language-go">paths, _ := cli.NewPaths("minimax")

// Ensure directories exist
paths.EnsureCacheDir()
paths.EnsureLogDir()

// Get paths
cachePath := paths.CachePath("response.json")
logPath := paths.LogPath("2024-01-15.log")
</code></pre>
<h2 id="dependencies-4"><a class="header" href="#dependencies-4">Dependencies</a></h2>
<ul>
<li><code>github.com/goccy/go-yaml</code> - YAML parsing</li>
<li><code>encoding/json</code> (stdlib) - JSON parsing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-package---rust-implementation"><a class="header" href="#cli-package---rust-implementation">CLI Package - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-cli</code></p>
<h2 id="types-11"><a class="header" href="#types-11">Types</a></h2>
<h3 id="config-1"><a class="header" href="#config-1">Config</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Config {
    #[serde(skip)]
    pub app_name: String,
    
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub current_context: String,
    
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub contexts: HashMap&lt;String, Context&gt;,
    
    #[serde(skip)]
    config_path: PathBuf,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default_config_dir</code></td><td><code>fn default_config_dir(app_name: &amp;str) -&gt; Option&lt;PathBuf&gt;</code></td><td>Get default config dir</td></tr>
<tr><td><code>default_config_path</code></td><td><code>fn default_config_path(app_name: &amp;str) -&gt; Option&lt;PathBuf&gt;</code></td><td>Get default config path</td></tr>
<tr><td><code>path</code></td><td><code>fn path(&amp;self) -&gt; &amp;PathBuf</code></td><td>Get config file path</td></tr>
<tr><td><code>dir</code></td><td><code>fn dir(&amp;self) -&gt; Option&lt;&amp;Path&gt;</code></td><td>Get config directory</td></tr>
<tr><td><code>save</code></td><td><code>fn save(&amp;self) -&gt; Result&lt;()&gt;</code></td><td>Save to disk</td></tr>
<tr><td><code>add_context</code></td><td><code>fn add_context(&amp;mut self, name: &amp;str, ctx: Context) -&gt; Result&lt;()&gt;</code></td><td>Add context</td></tr>
<tr><td><code>delete_context</code></td><td><code>fn delete_context(&amp;mut self, name: &amp;str) -&gt; Result&lt;()&gt;</code></td><td>Delete context</td></tr>
<tr><td><code>use_context</code></td><td><code>fn use_context(&amp;mut self, name: &amp;str) -&gt; Result&lt;()&gt;</code></td><td>Set current context</td></tr>
<tr><td><code>get_context</code></td><td><code>fn get_context(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Context&gt;</code></td><td>Get specific context</td></tr>
<tr><td><code>get_current_context</code></td><td><code>fn get_current_context(&amp;self) -&gt; Option&lt;&amp;Context&gt;</code></td><td>Get current context</td></tr>
<tr><td><code>resolve_context</code></td><td><code>fn resolve_context(&amp;self, name: Option&lt;&amp;str&gt;) -&gt; Option&lt;&amp;Context&gt;</code></td><td>Resolve by name or current</td></tr>
<tr><td><code>list_contexts</code></td><td><code>fn list_contexts(&amp;self) -&gt; Vec&lt;&amp;str&gt;</code></td><td>List all context names</td></tr>
</tbody></table>
</div>
<p><strong>Free Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>load_config</code></td><td><code>fn load_config(app_name: &amp;str, custom_path: Option&lt;&amp;str&gt;) -&gt; Result&lt;Config&gt;</code></td><td>Load config</td></tr>
<tr><td><code>save_config</code></td><td><code>fn save_config(app_name: &amp;str, config: &amp;Config, custom_path: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;</code></td><td>Save config</td></tr>
<tr><td><code>mask_api_key</code></td><td><code>fn mask_api_key(key: &amp;str) -&gt; String</code></td><td>Mask API key</td></tr>
</tbody></table>
</div>
<h3 id="context-1"><a class="header" href="#context-1">Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Context {
    pub name: String,
    pub client: Option&lt;ClientCredentials&gt;,
    pub console: Option&lt;ConsoleCredentials&gt;,
    pub api_key: String,
    pub base_url: String,
    pub timeout: i32,
    pub max_retries: i32,
    pub default_voice: String,
    pub extra: HashMap&lt;String, String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OutputFormat {
    #[default]
    Yaml,
    Json,
}

pub struct Output {
    pub format: OutputFormat,
    pub file: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(format: OutputFormat, file: Option&lt;String&gt;) -&gt; Self</code></td><td>Create output config</td></tr>
<tr><td><code>write</code></td><td><code>fn write&lt;T: Serialize&gt;(&amp;self, value: &amp;T) -&gt; Result&lt;()&gt;</code></td><td>Write formatted output</td></tr>
<tr><td><code>write_binary</code></td><td><code>fn write_binary(&amp;self, data: &amp;[u8], path: &amp;str) -&gt; Result&lt;()&gt;</code></td><td>Write binary data</td></tr>
</tbody></table>
</div>
<p><strong>Free Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>print_verbose</code></td><td><code>fn print_verbose(enabled: bool, message: &amp;str)</code></td><td>Print verbose message</td></tr>
<tr><td><code>guess_extension</code></td><td><code>fn guess_extension(format: &amp;str) -&gt; &amp;str</code></td><td>Guess file extension</td></tr>
</tbody></table>
</div>
<h3 id="paths-1"><a class="header" href="#paths-1">Paths</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct Paths {
    pub app_name: String,
    pub home_dir: PathBuf,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(app_name: impl Into&lt;String&gt;) -&gt; io::Result&lt;Self&gt;</code></td><td>Create paths instance</td></tr>
<tr><td><code>base_dir</code></td><td><code>fn base_dir(&amp;self) -&gt; PathBuf</code></td><td>~/.giztoy</td></tr>
<tr><td><code>app_dir</code></td><td><code>fn app_dir(&amp;self) -&gt; PathBuf</code></td><td>~/.giztoy/<app></td></tr>
<tr><td><code>config_file</code></td><td><code>fn config_file(&amp;self) -&gt; PathBuf</code></td><td>~/.giztoy/<app>/config.yaml</td></tr>
<tr><td><code>cache_dir</code></td><td><code>fn cache_dir(&amp;self) -&gt; PathBuf</code></td><td>~/.giztoy/<app>/cache</td></tr>
<tr><td><code>log_dir</code></td><td><code>fn log_dir(&amp;self) -&gt; PathBuf</code></td><td>~/.giztoy/<app>/logs</td></tr>
<tr><td><code>data_dir</code></td><td><code>fn data_dir(&amp;self) -&gt; PathBuf</code></td><td>~/.giztoy/<app>/data</td></tr>
<tr><td><code>ensure_app_dir</code></td><td><code>fn ensure_app_dir(&amp;self) -&gt; io::Result&lt;()&gt;</code></td><td>Create app dir</td></tr>
<tr><td><code>ensure_cache_dir</code></td><td><code>fn ensure_cache_dir(&amp;self) -&gt; io::Result&lt;()&gt;</code></td><td>Create cache dir</td></tr>
<tr><td><code>cache_path</code></td><td><code>fn cache_path(&amp;self, name: &amp;str) -&gt; PathBuf</code></td><td>Path in cache</td></tr>
<tr><td><code>log_path</code></td><td><code>fn log_path(&amp;self, name: &amp;str) -&gt; PathBuf</code></td><td>Path in logs</td></tr>
<tr><td><code>data_path</code></td><td><code>fn data_path(&amp;self, name: &amp;str) -&gt; PathBuf</code></td><td>Path in data</td></tr>
</tbody></table>
</div>
<h2 id="usage-7"><a class="header" href="#usage-7">Usage</a></h2>
<h3 id="load-configuration-1"><a class="header" href="#load-configuration-1">Load Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_cli::{load_config, mask_api_key};

let cfg = load_config("minimax", None)?;

if let Some(ctx) = cfg.get_current_context() {
    println!("API Key: {}", mask_api_key(&amp;ctx.api_key));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="output-results-1"><a class="header" href="#output-results-1">Output Results</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_cli::{Output, OutputFormat};
use serde::Serialize;

#[derive(Serialize)]
struct Result {
    status: String,
    message: String,
}

let result = Result {
    status: "ok".to_string(),
    message: "done".to_string(),
};

// Output as JSON to stdout
let output = Output::new(OutputFormat::Json, None);
output.write(&amp;result)?;

// Output to file
let output = Output::new(OutputFormat::Yaml, Some("output.yaml".to_string()));
output.write(&amp;result)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="path-management-1"><a class="header" href="#path-management-1">Path Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_cli::Paths;

let paths = Paths::new("minimax")?;

// Ensure directories exist
paths.ensure_cache_dir()?;
paths.ensure_log_dir()?;

// Get paths
let cache_path = paths.cache_path("response.json");
let log_path = paths.log_path("2024-01-15.log");
<span class="boring">}</span></code></pre></pre>
<h2 id="dependencies-5"><a class="header" href="#dependencies-5">Dependencies</a></h2>
<ul>
<li><code>serde</code> + <code>serde_yaml</code> + <code>serde_json</code> - Serialization</li>
<li><code>dirs</code> - Home directory detection</li>
<li><code>anyhow</code> - Error handling</li>
</ul>
<h2 id="differences-from-go-3"><a class="header" href="#differences-from-go-3">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Error handling</td><td><code>error</code> return</td><td><code>anyhow::Result</code></td></tr>
<tr><td>Config loading</td><td><code>LoadConfig(app)</code></td><td><code>load_config(app, None)</code></td></tr>
<tr><td>Output formats</td><td>yaml, json, table, raw</td><td>yaml, json only</td></tr>
<tr><td>Print helpers</td><td><code>PrintSuccess</code>, <code>PrintError</code>, etc.</td><td><code>print_verbose</code> only</td></tr>
<tr><td>Path returns</td><td><code>string</code></td><td><code>PathBuf</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="cli-package---known-issues"><a class="header" href="#cli-package---known-issues">CLI Package - Known Issues</a></h1>
<h2 id="-minor-issues-3"><a class="header" href="#-minor-issues-3">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="cli-001-rust-missing-output-formats"><a class="header" href="#cli-001-rust-missing-output-formats">CLI-001: Rust missing output formats</a></h3>
<p><strong>Description:</strong><br />
Go supports 4 output formats: <code>yaml</code>, <code>json</code>, <code>table</code>, <code>raw</code>.
Rust only supports: <code>yaml</code>, <code>json</code>.</p>
<p><strong>Impact:</strong> Rust CLI tools cannot output raw binary to stdout or table format.</p>
<p><strong>Suggestion:</strong> Add <code>Raw</code> and <code>Table</code> format support to Rust.</p>
<hr />
<h3 id="cli-002-rust-missing-print-helpers"><a class="header" href="#cli-002-rust-missing-print-helpers">CLI-002: Rust missing print helpers</a></h3>
<p><strong>Description:</strong><br />
Go has multiple print helpers with icons:</p>
<ul>
<li><code>PrintSuccess</code> (âœ“)</li>
<li><code>PrintError</code></li>
<li><code>PrintInfo</code> (â„¹)</li>
<li><code>PrintWarning</code> (âš )</li>
<li><code>PrintVerbose</code></li>
</ul>
<p>Rust only has <code>print_verbose</code>.</p>
<p><strong>Impact:</strong> Inconsistent user experience between Go and Rust CLIs.</p>
<p><strong>Suggestion:</strong> Add print helper functions to Rust.</p>
<hr />
<h3 id="cli-003-config-file-permissions"><a class="header" href="#cli-003-config-file-permissions">CLI-003: Config file permissions</a></h3>
<p><strong>File:</strong> <code>go/pkg/cli/config.go:143</code></p>
<p><strong>Description:</strong><br />
Config file is created with <code>0600</code> permissions (owner read/write only), which is good. But the config directory is created with <code>0755</code> (world-readable).</p>
<pre><code class="language-go">os.MkdirAll(dir, 0755)  // Directory readable by others
os.WriteFile(c.configPath, data, 0600)  // File only owner
</code></pre>
<p><strong>Impact:</strong> Directory structure is visible to other users, though file content is protected.</p>
<p><strong>Suggestion:</strong> Consider <code>0700</code> for the config directory.</p>
<hr />
<h3 id="cli-004-go-contextextra-returns-empty-string-for-missing-keys"><a class="header" href="#cli-004-go-contextextra-returns-empty-string-for-missing-keys">CLI-004: Go Context.Extra returns empty string for missing keys</a></h3>
<p><strong>File:</strong> <code>go/pkg/cli/config.go:224-228</code></p>
<p><strong>Description:</strong><br />
<code>GetExtra</code> returns empty string <code>""</code> for missing keys, making it impossible to distinguish between "key exists with empty value" and "key doesn't exist".</p>
<pre><code class="language-go">func (ctx *Context) GetExtra(key string) string {
    if ctx.Extra == nil {
        return ""
    }
    return ctx.Extra[key]  // Returns "" for missing key
}
</code></pre>
<p><strong>Impact:</strong> Cannot differentiate missing vs empty extra values.</p>
<p><strong>Suggestion:</strong> Add <code>HasExtra(key string) bool</code> or return <code>(string, bool)</code>.</p>
<hr />
<h2 id="-enhancements-4"><a class="header" href="#-enhancements-4">ğŸ”µ Enhancements</a></h2>
<h3 id="cli-005-no-config-file-locking"><a class="header" href="#cli-005-no-config-file-locking">CLI-005: No config file locking</a></h3>
<p><strong>Description:</strong><br />
Neither Go nor Rust implementation locks the config file during read/write operations. Concurrent CLI processes could corrupt the config.</p>
<p><strong>Suggestion:</strong> Implement file locking for Save operations.</p>
<hr />
<h3 id="cli-006-no-config-validation"><a class="header" href="#cli-006-no-config-validation">CLI-006: No config validation</a></h3>
<p><strong>Description:</strong><br />
Config is loaded without validation. Invalid URLs, negative timeouts, etc. are not detected until runtime errors occur.</p>
<p><strong>Suggestion:</strong> Add <code>Validate() error</code> method to Config/Context.</p>
<hr />
<h3 id="cli-007-missing-config-migration"><a class="header" href="#cli-007-missing-config-migration">CLI-007: Missing config migration</a></h3>
<p><strong>Description:</strong><br />
No mechanism to handle config format changes between versions. If schema changes, old configs may fail to load.</p>
<p><strong>Suggestion:</strong> Add version field and migration support.</p>
<hr />
<h3 id="cli-008-no-environment-variable-support"><a class="header" href="#cli-008-no-environment-variable-support">CLI-008: No environment variable support</a></h3>
<p><strong>Description:</strong><br />
API keys and other credentials must be stored in config file. No support for environment variable overrides.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Desired behavior
export MINIMAX_API_KEY="sk-..."
minimax chat "Hello"  # Uses env var instead of config
</code></pre>
<p><strong>Suggestion:</strong> Add env var lookup with config fallback.</p>
<hr />
<h2 id="-notes-4"><a class="header" href="#-notes-4">âšª Notes</a></h2>
<h3 id="cli-009-different-yaml-libraries"><a class="header" href="#cli-009-different-yaml-libraries">CLI-009: Different YAML libraries</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: Uses <code>github.com/goccy/go-yaml</code></li>
<li>Rust: Uses <code>serde_yaml</code></li>
</ul>
<p>Both produce compatible output but may have minor formatting differences.</p>
<hr />
<h3 id="cli-010-maskapikey-behavior-for-short-keys"><a class="header" href="#cli-010-maskapikey-behavior-for-short-keys">CLI-010: MaskAPIKey behavior for short keys</a></h3>
<p><strong>Description:</strong><br />
Both implementations mask entire key if length &lt;= 8:</p>
<pre><code class="language-go">if len(key) &lt;= 8 {
    return strings.Repeat("*", len(key))
}
</code></pre>
<p>This means very short keys (e.g., "test") show as "****" with no visible characters.</p>
<hr />
<h3 id="cli-011-paths-use-dirs-crate-in-rust"><a class="header" href="#cli-011-paths-use-dirs-crate-in-rust">CLI-011: Paths use dirs crate in Rust</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: Uses <code>os.UserHomeDir()</code> (stdlib)</li>
<li>Rust: Uses <code>dirs::home_dir()</code> (external crate)</li>
</ul>
<p>Both handle cross-platform home directory detection correctly.</p>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>CLI-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Output</td></tr>
<tr><td>CLI-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Print</td></tr>
<tr><td>CLI-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Config</td></tr>
<tr><td>CLI-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Context</td></tr>
<tr><td>CLI-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>CLI-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>CLI-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>CLI-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>CLI-009</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>CLI-010</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>CLI-011</td><td>âšª Note</td><td>N/A</td><td>Rust</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Functional CLI utilities. Main gaps are feature parity between Go and Rust implementations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-package"><a class="header" href="#audio-package">Audio Package</a></h1>
<p>Audio processing framework for speech and multimedia applications.</p>
<h2 id="design-goals-5"><a class="header" href="#design-goals-5">Design Goals</a></h2>
<ol>
<li><strong>Real-time Processing</strong>: Low-latency audio mixing, encoding, and streaming</li>
<li><strong>Format Flexibility</strong>: Support common audio formats (PCM, Opus, MP3, OGG)</li>
<li><strong>Cross-platform</strong>: FFI bindings to native libraries (libopus, libsoxr, lame)</li>
<li><strong>Streaming-first</strong>: Designed for continuous audio streams, not just files</li>
</ol>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         audio/                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚    pcm/     â”‚   â”‚   codec/    â”‚   â”‚  resampler/ â”‚       â”‚
â”‚  â”‚             â”‚   â”‚             â”‚   â”‚             â”‚       â”‚
â”‚  â”‚  - Format   â”‚   â”‚  - opus/    â”‚   â”‚  - soxr     â”‚       â”‚
â”‚  â”‚  - Chunk    â”‚   â”‚  - mp3/     â”‚   â”‚  - Format   â”‚       â”‚
â”‚  â”‚  - Mixer    â”‚   â”‚  - ogg/     â”‚   â”‚  - Convert  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   opusrt/   â”‚   â”‚   songs/    â”‚   â”‚ portaudio/  â”‚       â”‚
â”‚  â”‚             â”‚   â”‚             â”‚   â”‚  (Go only)  â”‚       â”‚
â”‚  â”‚  - Buffer   â”‚   â”‚  - Catalog  â”‚   â”‚             â”‚       â”‚
â”‚  â”‚  - Realtime â”‚   â”‚  - Notes    â”‚   â”‚  - Stream   â”‚       â”‚
â”‚  â”‚  - OGG R/W  â”‚   â”‚  - PCM gen  â”‚   â”‚  - Device   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="submodules"><a class="header" href="#submodules">Submodules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Description</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td><a href="lib/audio/./pcm/">pcm/</a></td><td>PCM format, chunks, mixing</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="lib/audio/./codec/">codec/</a></td><td>Audio codecs (Opus, MP3, OGG)</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="lib/audio/./resampler/">resampler/</a></td><td>Sample rate conversion (soxr)</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="lib/audio/./opusrt/">opusrt/</a></td><td>Realtime Opus streaming</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td></tr>
<tr><td><a href="lib/audio/./songs/">songs/</a></td><td>Built-in melodies</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td><a href="lib/audio/./portaudio/">portaudio/</a></td><td>Audio I/O devices</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td></tr>
</tbody></table>
</div>
<h2 id="audio-formats"><a class="header" href="#audio-formats">Audio Formats</a></h2>
<h3 id="pcm-formats-predefined"><a class="header" href="#pcm-formats-predefined">PCM Formats (Predefined)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Sample Rate</th><th>Channels</th><th>Bit Depth</th></tr></thead><tbody>
<tr><td><code>L16Mono16K</code></td><td>16000 Hz</td><td>1</td><td>16-bit</td></tr>
<tr><td><code>L16Mono24K</code></td><td>24000 Hz</td><td>1</td><td>16-bit</td></tr>
<tr><td><code>L16Mono48K</code></td><td>48000 Hz</td><td>1</td><td>16-bit</td></tr>
</tbody></table>
</div>
<h3 id="codec-support"><a class="header" href="#codec-support">Codec Support</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Codec</th><th>Encode</th><th>Decode</th><th>Container</th></tr></thead><tbody>
<tr><td>Opus</td><td>âœ…</td><td>âœ…</td><td>Raw, OGG</td></tr>
<tr><td>MP3</td><td>âœ…</td><td>âœ…</td><td>Raw</td></tr>
<tr><td>OGG</td><td>N/A</td><td>N/A</td><td>Container only</td></tr>
</tbody></table>
</div>
<h2 id="common-workflows"><a class="header" href="#common-workflows">Common Workflows</a></h2>
<h3 id="voice-chat-low-latency"><a class="header" href="#voice-chat-low-latency">Voice Chat (Low Latency)</a></h3>
<pre><code>Microphone â†’ PCM 16kHz â†’ Opus Encode â†’ Network â†’ Opus Decode â†’ Mixer â†’ Speaker
</code></pre>
<h3 id="speech-synthesis-playback"><a class="header" href="#speech-synthesis-playback">Speech Synthesis Playback</a></h3>
<pre><code>API Response (Base64 MP3) â†’ MP3 Decode â†’ Resample 24Kâ†’16K â†’ Mixer â†’ Speaker
</code></pre>
<h3 id="audio-recording"><a class="header" href="#audio-recording">Audio Recording</a></h3>
<pre><code>PCM Stream â†’ Opus Encode â†’ OGG Writer â†’ File
</code></pre>
<h2 id="native-dependencies"><a class="header" href="#native-dependencies">Native Dependencies</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Library</th><th>Purpose</th><th>Build System</th></tr></thead><tbody>
<tr><td>libopus</td><td>Opus codec</td><td>pkg-config / Bazel</td></tr>
<tr><td>libsoxr</td><td>Resampling</td><td>pkg-config / Bazel</td></tr>
<tr><td>lame</td><td>MP3 encoding</td><td>Bazel (bundled)</td></tr>
<tr><td>minimp3</td><td>MP3 decoding</td><td>Bazel (bundled)</td></tr>
<tr><td>libogg</td><td>OGG container</td><td>pkg-config / Bazel</td></tr>
<tr><td>portaudio</td><td>Audio I/O</td><td>pkg-config / Bazel</td></tr>
</tbody></table>
</div>
<h2 id="examples-directory-5"><a class="header" href="#examples-directory-5">Examples Directory</a></h2>
<ul>
<li><code>examples/go/audio/</code> - Go audio examples</li>
<li><code>examples/rust/audio/</code> - Rust audio examples</li>
</ul>
<h2 id="related-packages-5"><a class="header" href="#related-packages-5">Related Packages</a></h2>
<ul>
<li><code>buffer</code> - Used for audio data buffering</li>
<li><code>speech</code> - High-level speech synthesis/recognition</li>
<li><code>minimax</code>, <code>doubaospeech</code> - TTS/ASR APIs returning audio</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-package---go-implementation"><a class="header" href="#audio-package---go-implementation">Audio Package - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio</code></p>
<p>The main <code>audio</code> package is an umbrella for sub-packages. Import specific packages directly.</p>
<h2 id="sub-packages"><a class="header" href="#sub-packages">Sub-packages</a></h2>
<h3 id="pcm-pcm-audio"><a class="header" href="#pcm-pcm-audio">pcm (PCM Audio)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/pcm"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Format</code></td><td>Audio format (sample rate, channels, depth)</td></tr>
<tr><td><code>Chunk</code></td><td>Interface for audio data chunks</td></tr>
<tr><td><code>DataChunk</code></td><td>Raw audio data chunk</td></tr>
<tr><td><code>SilenceChunk</code></td><td>Silence generator</td></tr>
<tr><td><code>Mixer</code></td><td>Multi-track audio mixer</td></tr>
<tr><td><code>Track</code></td><td>Single audio track in mixer</td></tr>
<tr><td><code>TrackCtrl</code></td><td>Track control (gain, play/stop)</td></tr>
</tbody></table>
</div>
<h3 id="codecopus-opus-codec"><a class="header" href="#codecopus-opus-codec">codec/opus (Opus Codec)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/codec/opus"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Encoder</code></td><td>Opus encoder (wraps libopus)</td></tr>
<tr><td><code>Decoder</code></td><td>Opus decoder (wraps libopus)</td></tr>
<tr><td><code>Frame</code></td><td>Raw Opus frame data (<code>[]byte</code>)</td></tr>
<tr><td><code>TOC</code></td><td>Table of Contents byte parser</td></tr>
<tr><td><code>FrameDuration</code></td><td>Frame duration enum</td></tr>
</tbody></table>
</div>
<h3 id="codecmp3-mp3-codec"><a class="header" href="#codecmp3-mp3-codec">codec/mp3 (MP3 Codec)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/codec/mp3"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Encoder</code></td><td>MP3 encoder (wraps LAME)</td></tr>
<tr><td><code>Decoder</code></td><td>MP3 decoder (wraps minimp3)</td></tr>
</tbody></table>
</div>
<h3 id="codecogg-ogg-container"><a class="header" href="#codecogg-ogg-container">codec/ogg (OGG Container)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/codec/ogg"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Encoder</code></td><td>OGG page encoder</td></tr>
<tr><td><code>Stream</code></td><td>OGG logical bitstream</td></tr>
<tr><td><code>Sync</code></td><td>OGG page synchronizer</td></tr>
</tbody></table>
</div>
<h3 id="resampler-sample-rate-conversion"><a class="header" href="#resampler-sample-rate-conversion">resampler (Sample Rate Conversion)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/resampler"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Resampler</code></td><td>Interface for sample rate conversion</td></tr>
<tr><td><code>Soxr</code></td><td>libsoxr-based resampler</td></tr>
<tr><td><code>Format</code></td><td>Source/destination format</td></tr>
</tbody></table>
</div>
<h3 id="opusrt-realtime-opus"><a class="header" href="#opusrt-realtime-opus">opusrt (Realtime Opus)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/opusrt"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Buffer</code></td><td>Jitter buffer for out-of-order frames</td></tr>
<tr><td><code>RealtimeBuffer</code></td><td>Real-time playback simulation</td></tr>
<tr><td><code>StampedFrame</code></td><td>Opus frame with timestamp</td></tr>
<tr><td><code>OggReader</code></td><td>Read Opus from OGG container</td></tr>
<tr><td><code>OggWriter</code></td><td>Write Opus to OGG container</td></tr>
</tbody></table>
</div>
<h3 id="portaudio-audio-io"><a class="header" href="#portaudio-audio-io">portaudio (Audio I/O)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/portaudio"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Stream</code></td><td>Audio input/output stream</td></tr>
</tbody></table>
</div>
<h3 id="songs-built-in-melodies"><a class="header" href="#songs-built-in-melodies">songs (Built-in Melodies)</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/songs"
</code></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Song</code></td><td>Melody definition</td></tr>
<tr><td><code>Note</code></td><td>Musical note</td></tr>
</tbody></table>
</div>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="pcm-mixer"><a class="header" href="#pcm-mixer">PCM Mixer</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/pcm"

// Create mixer
mixer := pcm.NewMixer(pcm.L16Mono16K, pcm.WithAutoClose())

// Create track
track, ctrl, _ := mixer.CreateTrack(pcm.WithTrackLabel("voice"))

// Write audio to track
track.Write(audioData)

// Adjust gain
ctrl.SetGain(0.8)

// Read mixed output
buf := make([]byte, 1600) // 50ms at 16kHz
mixer.Read(buf)
</code></pre>
<h3 id="opus-encoding"><a class="header" href="#opus-encoding">Opus Encoding</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/codec/opus"

// Create encoder
enc, _ := opus.NewVoIPEncoder(16000, 1)
defer enc.Close()

enc.SetBitrate(24000)

// Encode PCM to Opus
pcmData := make([]int16, 320) // 20ms at 16kHz
frame, _ := enc.Encode(pcmData, 320)
</code></pre>
<h3 id="sample-rate-conversion"><a class="header" href="#sample-rate-conversion">Sample Rate Conversion</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/resampler"

srcFmt := resampler.Format{SampleRate: 24000, Stereo: false}
dstFmt := resampler.Format{SampleRate: 16000, Stereo: false}

rs, _ := resampler.New(audioReader, srcFmt, dstFmt)
defer rs.Close()

// Read resampled data
io.Copy(output, rs)
</code></pre>
<h3 id="realtime-opus-buffer"><a class="header" href="#realtime-opus-buffer">Realtime Opus Buffer</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/opusrt"

// Create jitter buffer (2 minute capacity)
buf := opusrt.NewBuffer(2 * time.Minute)

// Write stamped frames (can arrive out of order)
buf.Write(stampedFrameData)

// Read in order
frame, loss, _ := buf.Frame()
if loss &gt; 0 {
    // Use decoder PLC for lost frames
}
</code></pre>
<h2 id="cgo-dependencies"><a class="header" href="#cgo-dependencies">CGO Dependencies</a></h2>
<p>All codec packages use CGO to bind native libraries:</p>
<pre><code class="language-go">// Example: opus encoder
/*
#cgo pkg-config: opus
#include &lt;opus.h&gt;
*/
import "C"
</code></pre>
<p>Build requirements:</p>
<ul>
<li><code>pkg-config</code> for native builds</li>
<li>Bazel <code>cdeps</code> for Bazel builds</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-package---rust-implementation"><a class="header" href="#audio-package---rust-implementation">Audio Package - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-audio</code></p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<h3 id="pcm-pcm-audio-1"><a class="header" href="#pcm-pcm-audio-1">pcm (PCM Audio)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::pcm::{Format, FormatExt, Chunk, DataChunk, SilenceChunk, Mixer};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Format</code></td><td>Audio format enum (re-exported from resampler)</td></tr>
<tr><td><code>FormatExt</code></td><td>Extension trait for chunk creation</td></tr>
<tr><td><code>Chunk</code></td><td>Trait for audio data chunks</td></tr>
<tr><td><code>DataChunk</code></td><td>Raw audio data chunk</td></tr>
<tr><td><code>SilenceChunk</code></td><td>Silence generator</td></tr>
<tr><td><code>Mixer</code></td><td>Multi-track audio mixer</td></tr>
<tr><td><code>Track</code></td><td>Audio track writer</td></tr>
<tr><td><code>TrackCtrl</code></td><td>Track control</td></tr>
<tr><td><code>AtomicF32</code></td><td>Atomic float for gain control</td></tr>
</tbody></table>
</div>
<h3 id="codecopus-opus-codec-1"><a class="header" href="#codecopus-opus-codec-1">codec::opus (Opus Codec)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::opus::{Encoder, Decoder, Application, Frame, TOC};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Encoder</code></td><td>Opus encoder (wraps libopus)</td></tr>
<tr><td><code>Decoder</code></td><td>Opus decoder</td></tr>
<tr><td><code>Application</code></td><td>Encoder application type enum</td></tr>
<tr><td><code>Frame</code></td><td>Raw Opus frame data</td></tr>
<tr><td><code>TOC</code></td><td>Table of Contents parser</td></tr>
<tr><td><code>FrameDuration</code></td><td>Frame duration enum</td></tr>
</tbody></table>
</div>
<h3 id="codecmp3-mp3-codec-1"><a class="header" href="#codecmp3-mp3-codec-1">codec::mp3 (MP3 Codec)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::mp3::{Encoder, Decoder};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Encoder</code></td><td>MP3 encoder (wraps LAME)</td></tr>
<tr><td><code>Decoder</code></td><td>MP3 decoder (wraps minimp3)</td></tr>
</tbody></table>
</div>
<h3 id="codecogg-ogg-container-1"><a class="header" href="#codecogg-ogg-container-1">codec::ogg (OGG Container)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::ogg::{Encoder, Stream, Sync, Page};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Encoder</code></td><td>OGG page encoder</td></tr>
<tr><td><code>Stream</code></td><td>OGG logical bitstream</td></tr>
<tr><td><code>Sync</code></td><td>OGG page synchronizer</td></tr>
<tr><td><code>Page</code></td><td>OGG page data</td></tr>
</tbody></table>
</div>
<h3 id="resampler-sample-rate-conversion-1"><a class="header" href="#resampler-sample-rate-conversion-1">resampler (Sample Rate Conversion)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::resampler::{Soxr, Format};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Soxr</code></td><td>libsoxr-based resampler</td></tr>
<tr><td><code>Format</code></td><td>Audio format (sample rate, stereo flag)</td></tr>
</tbody></table>
</div>
<h3 id="opusrt-realtime-opus-1"><a class="header" href="#opusrt-realtime-opus-1">opusrt (Realtime Opus)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::opusrt::{Buffer, StampedFrame, EpochMillis};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Buffer</code></td><td>Jitter buffer for frame reordering</td></tr>
<tr><td><code>StampedFrame</code></td><td>Opus frame with timestamp</td></tr>
<tr><td><code>EpochMillis</code></td><td>Millisecond timestamp</td></tr>
</tbody></table>
</div>
<p>âš ï¸ <strong>Note:</strong> Rust opusrt is missing OGG Reader/Writer compared to Go.</p>
<h3 id="songs-built-in-melodies-1"><a class="header" href="#songs-built-in-melodies-1">songs (Built-in Melodies)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::songs::{Song, Note, Catalog};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Song</code></td><td>Melody definition</td></tr>
<tr><td><code>Note</code></td><td>Musical note</td></tr>
<tr><td><code>Catalog</code></td><td>Built-in song collection</td></tr>
</tbody></table>
</div>
<h2 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage Examples</a></h2>
<h3 id="pcm-format"><a class="header" href="#pcm-format">PCM Format</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::pcm::{Format, FormatExt};
use std::time::Duration;

let format = Format::L16Mono16K;

// Calculate bytes for duration
let bytes = format.bytes_in_duration(Duration::from_millis(100));
assert_eq!(bytes, 3200); // 1600 samples * 2 bytes

// Create chunks
let silence = format.silence_chunk(Duration::from_millis(100));
let data = format.data_chunk(vec![0u8; 3200]);
<span class="boring">}</span></code></pre></pre>
<h3 id="opus-encoding-1"><a class="header" href="#opus-encoding-1">Opus Encoding</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::opus::{Encoder, Application};

let mut encoder = Encoder::new(16000, 1, Application::VoIP)?;
encoder.set_bitrate(24000)?;

// Encode PCM to Opus
let pcm: Vec&lt;i16&gt; = vec![0; 320]; // 20ms at 16kHz
let frame = encoder.encode(&amp;pcm, 320)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="sample-rate-conversion-1"><a class="header" href="#sample-rate-conversion-1">Sample Rate Conversion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::resampler::{Soxr, Format};

let src_fmt = Format { sample_rate: 24000, stereo: false };
let dst_fmt = Format { sample_rate: 16000, stereo: false };

let mut resampler = Soxr::new(src_fmt, dst_fmt)?;

// Process audio data
let output = resampler.process(&amp;input_pcm)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="mixer"><a class="header" href="#mixer">Mixer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::pcm::{Format, Mixer, MixerOptions};

let mut mixer = Mixer::new(Format::L16Mono16K, MixerOptions::default());

// Create track
let (track, ctrl) = mixer.create_track(None)?;

// Write audio
track.write(&amp;audio_data)?;

// Adjust gain
ctrl.set_gain(0.8);

// Read mixed output
let mut buf = vec![0u8; 3200];
mixer.read(&amp;mut buf)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="ffi-bindings"><a class="header" href="#ffi-bindings">FFI Bindings</a></h2>
<p>Rust uses custom FFI modules for native library bindings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: codec/opus/ffi.rs
extern "C" {
    fn opus_encoder_create(
        fs: i32,
        channels: i32,
        application: i32,
        error: *mut i32,
    ) -&gt; *mut OpusEncoder;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-4"><a class="header" href="#differences-from-go-4">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Format definition</td><td>In <code>pcm/</code></td><td>In <code>resampler/</code>, re-exported by <code>pcm/</code></td></tr>
<tr><td>opusrt OGG R/W</td><td>âœ…</td><td>âŒ Missing</td></tr>
<tr><td>portaudio</td><td>âœ…</td><td>âŒ Not implemented</td></tr>
<tr><td>Mixer thread-safety</td><td><code>sync.Mutex</code></td><td><code>std::sync::Mutex</code></td></tr>
<tr><td>FFI error handling</td><td>CGO strerror</td><td>Custom error types</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="audio-package---known-issues"><a class="header" href="#audio-package---known-issues">Audio Package - Known Issues</a></h1>
<h2 id="-major-issues-1"><a class="header" href="#-major-issues-1">ğŸŸ  Major Issues</a></h2>
<h3 id="aud-001-go-mixer-uses-unsafe-pointer-casting"><a class="header" href="#aud-001-go-mixer-uses-unsafe-pointer-casting">AUD-001: Go Mixer uses unsafe pointer casting</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/mixer.go:226</code></p>
<p><strong>Description:</strong><br />
The mixer uses <code>unsafe.Slice</code> and <code>unsafe.Pointer</code> to cast between <code>[]byte</code> and <code>[]int16</code>:</p>
<pre><code class="language-go">i16 := unsafe.Slice((*int16)(unsafe.Pointer(&amp;p[0])), len(p)/2)
</code></pre>
<p><strong>Risk:</strong></p>
<ul>
<li>Platform-dependent endianness (assumes little-endian)</li>
<li>Potential undefined behavior if buffer alignment is wrong</li>
</ul>
<p><strong>Impact:</strong> May produce incorrect audio on big-endian systems.</p>
<p><strong>Suggestion:</strong> Add explicit little-endian encoding/decoding or document platform requirements.</p>
<hr />
<h3 id="aud-002-rust-opusrt-missing-ogg-readerwriter"><a class="header" href="#aud-002-rust-opusrt-missing-ogg-readerwriter">AUD-002: Rust opusrt missing OGG Reader/Writer</a></h3>
<p><strong>Description:</strong><br />
Go opusrt has <code>OggReader</code> and <code>OggWriter</code> for reading/writing Opus in OGG containers. Rust implementation is missing these.</p>
<p><strong>Impact:</strong> Cannot read/write Opus files in OGG format in Rust.</p>
<p><strong>Status:</strong> âš ï¸ Partial implementation.</p>
<hr />
<h3 id="aud-003-rust-missing-portaudio-module"><a class="header" href="#aud-003-rust-missing-portaudio-module">AUD-003: Rust missing portaudio module</a></h3>
<p><strong>Description:</strong><br />
Go has <code>audio/portaudio</code> for audio device I/O. Rust has no equivalent.</p>
<p><strong>Impact:</strong> Cannot capture/play audio from hardware devices in Rust.</p>
<p><strong>Status:</strong> âŒ Not implemented.</p>
<hr />
<h2 id="-minor-issues-4"><a class="header" href="#-minor-issues-4">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="aud-004-go-format-panics-on-invalid-value"><a class="header" href="#aud-004-go-format-panics-on-invalid-value">AUD-004: Go Format panics on invalid value</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/pcm.go:36-38</code></p>
<p><strong>Description:</strong><br />
<code>Format.SampleRate()</code>, <code>Channels()</code>, <code>Depth()</code> all panic on invalid format:</p>
<pre><code class="language-go">func (f Format) SampleRate() int {
    switch f {
    // ...
    }
    panic("pcm: invalid audio type")
}
</code></pre>
<p><strong>Impact:</strong> Runtime panic instead of error return.</p>
<p><strong>Suggestion:</strong> Return <code>(int, error)</code> or use <code>MustXxx</code> naming convention for panicking versions.</p>
<hr />
<h3 id="aud-005-go-silencechunk-uses-fixed-global-buffer"><a class="header" href="#aud-005-go-silencechunk-uses-fixed-global-buffer">AUD-005: Go SilenceChunk uses fixed global buffer</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/pcm.go:177</code></p>
<p><strong>Description:</strong><br />
Uses a shared fixed-size zero buffer and loops for long durations.</p>
<p><strong>Impact:</strong> None functionally; avoids repeated allocations.</p>
<p><strong>Status:</strong> Not a bug. Keep as implementation note only.</p>
<h3 id="aud-006-go-opus-encoder-max-frame-size-hardcoded"><a class="header" href="#aud-006-go-opus-encoder-max-frame-size-hardcoded">AUD-006: Go Opus encoder max frame size hardcoded</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/codec/opus/encoder.go:95</code></p>
<p><strong>Description:</strong><br />
Encode function allocates fixed 4000 byte buffer:</p>
<pre><code class="language-go">buf := make([]byte, 4000)
</code></pre>
<p><strong>Impact:</strong> Allocation on every encode call.</p>
<p><strong>Suggestion:</strong> Use buffer pool or allow caller to provide buffer.</p>
<hr />
<h3 id="aud-007-rust-format-re-export-from-resampler-is-confusing"><a class="header" href="#aud-007-rust-format-re-export-from-resampler-is-confusing">AUD-007: Rust Format re-export from resampler is confusing</a></h3>
<p><strong>File:</strong> <code>rust/audio/src/pcm/format.rs:7</code></p>
<p><strong>Description:</strong><br />
<code>pcm::Format</code> is actually re-exported from <code>resampler::Format</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use crate::resampler::format::Format;
<span class="boring">}</span></code></pre></pre>
<p><strong>Impact:</strong> Confusing import paths, circular dependency appearance.</p>
<p><strong>Suggestion:</strong> Define Format once at top level and import in both modules.</p>
<hr />
<h3 id="aud-008-go-mixer-notifywrite-spawns-goroutine-every-call"><a class="header" href="#aud-008-go-mixer-notifywrite-spawns-goroutine-every-call">AUD-008: Go mixer notifyWrite spawns goroutine every call</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/mixer.go:391-405</code></p>
<p><strong>Description:</strong><br />
<code>notifyWrite()</code> spawns a new goroutine each time:</p>
<pre><code class="language-go">func (mx *Mixer) notifyWrite() {
    go func() {
        // ...
    }()
}
</code></pre>
<p><strong>Impact:</strong> Goroutine overhead for every write notification.</p>
<p><strong>Suggestion:</strong> Use single dedicated notification goroutine or avoid goroutine.</p>
<hr />
<h2 id="-enhancements-5"><a class="header" href="#-enhancements-5">ğŸ”µ Enhancements</a></h2>
<h3 id="aud-009-no-stereo-format-support-in-predefined-formats"><a class="header" href="#aud-009-no-stereo-format-support-in-predefined-formats">AUD-009: No stereo format support in predefined formats</a></h3>
<p><strong>Description:</strong><br />
Only mono formats are predefined (<code>L16Mono16K</code>, etc.). No stereo formats.</p>
<p><strong>Suggestion:</strong> Add <code>L16Stereo16K</code>, <code>L16Stereo24K</code>, <code>L16Stereo48K</code>.</p>
<hr />
<h3 id="aud-010-no-8-bit-or-24-bit-pcm-support"><a class="header" href="#aud-010-no-8-bit-or-24-bit-pcm-support">AUD-010: No 8-bit or 24-bit PCM support</a></h3>
<p><strong>Description:</strong><br />
Only 16-bit PCM is supported. Some audio sources use 8-bit (low quality) or 24-bit (high quality).</p>
<p><strong>Suggestion:</strong> Add format variants for different bit depths.</p>
<hr />
<h3 id="aud-011-resampler-quality-not-configurable"><a class="header" href="#aud-011-resampler-quality-not-configurable">AUD-011: Resampler quality not configurable</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/resampler/soxr.go:52</code></p>
<p><strong>Description:</strong><br />
Quality is hardcoded to <code>SOXR_HQ</code>:</p>
<pre><code class="language-go">qSpec := C.soxr_quality_spec(C.SOXR_HQ, 0)
</code></pre>
<p><strong>Impact:</strong> Cannot trade quality for performance when needed.</p>
<p><strong>Suggestion:</strong> Add quality parameter to New().</p>
<hr />
<h3 id="aud-012-no-wav-file-support"><a class="header" href="#aud-012-no-wav-file-support">AUD-012: No WAV file support</a></h3>
<p><strong>Description:</strong><br />
No utilities for reading/writing WAV files, only raw PCM.</p>
<p><strong>Suggestion:</strong> Add WAV header parsing/writing for file I/O.</p>
<hr />
<h2 id="-notes-5"><a class="header" href="#-notes-5">âšª Notes</a></h2>
<h3 id="aud-013-cgoffi-dependency-complexity"><a class="header" href="#aud-013-cgoffi-dependency-complexity">AUD-013: CGO/FFI dependency complexity</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust rely heavily on CGO/FFI for native codec libraries. This adds:</p>
<ul>
<li>Build complexity (pkg-config, Bazel rules)</li>
<li>Platform-specific issues</li>
<li>Memory management concerns</li>
</ul>
<p><strong>Status:</strong> Necessary for performance, but increases maintenance burden.</p>
<hr />
<h3 id="aud-014-mixer-uses-float32-internally"><a class="header" href="#aud-014-mixer-uses-float32-internally">AUD-014: Mixer uses float32 internally</a></h3>
<p><strong>Description:</strong><br />
Mixer converts int16 PCM to float32 for mixing, then back to int16:</p>
<pre><code class="language-go">// int16 â†’ float32
s := float32(trackI16[i])
// ... mix ...
// float32 â†’ int16
i16[i] = int16(t * 32767)
</code></pre>
<p><strong>Impact:</strong> Slight precision loss during mixing, but standard practice.</p>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>AUD-001</td><td>ğŸŸ  Major</td><td>Open</td><td>Go Mixer</td></tr>
<tr><td>AUD-002</td><td>ğŸŸ  Major</td><td>Open</td><td>Rust opusrt</td></tr>
<tr><td>AUD-003</td><td>ğŸŸ  Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>AUD-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Format</td></tr>
<tr><td>AUD-005</td><td>âšª Note</td><td>N/A</td><td>Go SilenceChunk</td></tr>
<tr><td>AUD-006</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Opus</td></tr>
<tr><td>AUD-007</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Format</td></tr>
<tr><td>AUD-008</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Mixer</td></tr>
<tr><td>AUD-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>AUD-010</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>AUD-011</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>AUD-012</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>AUD-013</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>AUD-014</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Functional audio processing with significant native library integration. Main gaps are Rust parity (opusrt OGG, portaudio) and some unsafe code patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-codec-module"><a class="header" href="#audio-codec-module">Audio Codec Module</a></h1>
<p>Audio encoding and decoding for Opus, MP3, and OGG formats.</p>
<h2 id="design-goals-6"><a class="header" href="#design-goals-6">Design Goals</a></h2>
<ol>
<li><strong>Native Performance</strong>: FFI bindings to proven C libraries</li>
<li><strong>Streaming Support</strong>: Process audio in chunks, not full files</li>
<li><strong>VoIP Optimized</strong>: Low-latency Opus encoding for voice chat</li>
</ol>
<h2 id="codec-support-matrix"><a class="header" href="#codec-support-matrix">Codec Support Matrix</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Codec</th><th>Encode</th><th>Decode</th><th>Library</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Opus</td><td>âœ…</td><td>âœ…</td><td>libopus</td><td>Voice chat, streaming</td></tr>
<tr><td>MP3</td><td>âœ…</td><td>âœ…</td><td>LAME / minimp3</td><td>File storage, compatibility</td></tr>
<tr><td>OGG</td><td>N/A</td><td>N/A</td><td>libogg</td><td>Container format</td></tr>
</tbody></table>
</div>
<h2 id="sub-modules"><a class="header" href="#sub-modules">Sub-modules</a></h2>
<h3 id="opus"><a class="header" href="#opus">opus/</a></h3>
<p>Opus codec implementation for voice and audio.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Encoder with VoIP/Audio/LowDelay modes</li>
<li>Decoder with PLC (Packet Loss Concealment)</li>
<li>TOC (Table of Contents) parsing</li>
<li>Frame duration detection</li>
</ul>
<p><strong>Key Types:</strong></p>
<ul>
<li><code>Encoder</code>, <code>Decoder</code></li>
<li><code>Frame</code>, <code>TOC</code>, <code>FrameDuration</code></li>
</ul>
<h3 id="mp3"><a class="header" href="#mp3">mp3/</a></h3>
<p>MP3 codec for compatibility with legacy systems.</p>
<p><strong>Features:</strong></p>
<ul>
<li>LAME-based encoding with quality presets</li>
<li>minimp3-based decoding (header-only library)</li>
</ul>
<p><strong>Key Types:</strong></p>
<ul>
<li><code>Encoder</code>, <code>Decoder</code></li>
</ul>
<h3 id="ogg"><a class="header" href="#ogg">ogg/</a></h3>
<p>OGG container format for packaging Opus/Vorbis streams.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Page-based streaming</li>
<li>Bitstream management</li>
<li>Synchronization recovery</li>
</ul>
<p><strong>Key Types:</strong></p>
<ul>
<li><code>Encoder</code>, <code>Stream</code>, <code>Sync</code>, <code>Page</code></li>
</ul>
<h2 id="opus-frame-durations"><a class="header" href="#opus-frame-durations">Opus Frame Durations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Duration</th><th>Samples@16K</th><th>Samples@48K</th></tr></thead><tbody>
<tr><td>2.5ms</td><td>40</td><td>120</td></tr>
<tr><td>5ms</td><td>80</td><td>240</td></tr>
<tr><td>10ms</td><td>160</td><td>480</td></tr>
<tr><td>20ms</td><td>320</td><td>960</td></tr>
<tr><td>40ms</td><td>640</td><td>1920</td></tr>
<tr><td>60ms</td><td>960</td><td>2880</td></tr>
</tbody></table>
</div>
<p><strong>Recommended:</strong> 20ms frames balance latency and compression.</p>
<h2 id="common-opus-bitrates"><a class="header" href="#common-opus-bitrates">Common Opus Bitrates</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Application</th><th>Bitrate</th><th>Quality</th></tr></thead><tbody>
<tr><td>Voice (narrow)</td><td>8-12 kbps</td><td>Intelligible</td></tr>
<tr><td>Voice (wide)</td><td>16-24 kbps</td><td>Good</td></tr>
<tr><td>Voice (HD)</td><td>32-48 kbps</td><td>Excellent</td></tr>
<tr><td>Music</td><td>64-128 kbps</td><td>Hi-Fi</td></tr>
</tbody></table>
</div>
<h2 id="native-library-versions"><a class="header" href="#native-library-versions">Native Library Versions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Library</th><th>Minimum Version</th><th>Notes</th></tr></thead><tbody>
<tr><td>libopus</td><td>1.3.0</td><td>Opus encoder/decoder</td></tr>
<tr><td>libogg</td><td>1.3.0</td><td>OGG container</td></tr>
<tr><td>LAME</td><td>3.100</td><td>MP3 encoder</td></tr>
<tr><td>minimp3</td><td>-</td><td>Header-only decoder</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>See parent <code>audio/</code> documentation for usage examples.</p>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<ul>
<li><code>opusrt/</code> - Realtime Opus streaming with OGG container</li>
<li><code>resampler/</code> - Sample rate conversion before encoding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-codec---go-implementation"><a class="header" href="#audio-codec---go-implementation">Audio Codec - Go Implementation</a></h1>
<h2 id="opus-package"><a class="header" href="#opus-package">opus/ Package</a></h2>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio/codec/opus</code></p>
<h3 id="types-12"><a class="header" href="#types-12">Types</a></h3>
<h4 id="encoder"><a class="header" href="#encoder">Encoder</a></h4>
<pre><code class="language-go">type Encoder struct {
    sampleRate int
    channels   int
    cEnc       *C.OpusEncoder
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewEncoder</code></td><td><code>func NewEncoder(sampleRate, channels, application int) (*Encoder, error)</code></td><td>Create encoder</td></tr>
<tr><td><code>NewVoIPEncoder</code></td><td><code>func NewVoIPEncoder(sampleRate, channels int) (*Encoder, error)</code></td><td>Voice-optimized encoder</td></tr>
<tr><td><code>NewAudioEncoder</code></td><td><code>func NewAudioEncoder(sampleRate, channels int) (*Encoder, error)</code></td><td>Music-optimized encoder</td></tr>
<tr><td><code>Close</code></td><td><code>(e *Encoder) Close()</code></td><td>Release resources</td></tr>
<tr><td><code>Encode</code></td><td><code>(e *Encoder) Encode(pcm []int16, frameSize int) (Frame, error)</code></td><td>Encode PCM to Opus</td></tr>
<tr><td><code>EncodeBytes</code></td><td><code>(e *Encoder) EncodeBytes(pcm []byte, frameSize int) (Frame, error)</code></td><td>Encode from bytes</td></tr>
<tr><td><code>EncodeTo</code></td><td><code>(e *Encoder) EncodeTo(pcm []int16, frameSize int, buf []byte) (int, error)</code></td><td>Encode to buffer</td></tr>
<tr><td><code>SetBitrate</code></td><td><code>(e *Encoder) SetBitrate(bitrate int) error</code></td><td>Set target bitrate</td></tr>
<tr><td><code>SetComplexity</code></td><td><code>(e *Encoder) SetComplexity(complexity int) error</code></td><td>Set CPU complexity</td></tr>
<tr><td><code>FrameSize20ms</code></td><td><code>(e *Encoder) FrameSize20ms() int</code></td><td>Get 20ms frame size</td></tr>
</tbody></table>
</div>
<p><strong>Application Constants:</strong></p>
<pre><code class="language-go">const (
    ApplicationVoIP              = int(C.OPUS_APPLICATION_VOIP)
    ApplicationAudio             = int(C.OPUS_APPLICATION_AUDIO)
    ApplicationRestrictedLowdelay = int(C.OPUS_APPLICATION_RESTRICTED_LOWDELAY)
)
</code></pre>
<h4 id="decoder"><a class="header" href="#decoder">Decoder</a></h4>
<pre><code class="language-go">type Decoder struct {
    sampleRate int
    channels   int
    cDec       *C.OpusDecoder
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewDecoder</code></td><td><code>func NewDecoder(sampleRate, channels int) (*Decoder, error)</code></td><td>Create decoder</td></tr>
<tr><td><code>Close</code></td><td><code>(d *Decoder) Close()</code></td><td>Release resources</td></tr>
<tr><td><code>Decode</code></td><td><code>(d *Decoder) Decode(f Frame) ([]byte, error)</code></td><td>Decode Opus to PCM</td></tr>
<tr><td><code>DecodeTo</code></td><td><code>(d *Decoder) DecodeTo(f Frame, buf []int16) (int, error)</code></td><td>Decode to buffer</td></tr>
<tr><td><code>DecodePLC</code></td><td><code>(d *Decoder) DecodePLC(samples int) ([]byte, error)</code></td><td>Packet loss concealment</td></tr>
</tbody></table>
</div>
<h4 id="frame--toc"><a class="header" href="#frame--toc">Frame &amp; TOC</a></h4>
<pre><code class="language-go">type Frame []byte

type TOC struct {
    Config      int           // 0-31 configuration
    StereoFlag  bool          // True for stereo
    FrameCount  int           // 1-48 frames
    Duration    FrameDuration // Per-frame duration
}
</code></pre>
<h3 id="usage-8"><a class="header" href="#usage-8">Usage</a></h3>
<pre><code class="language-go">// Create encoder
enc, _ := opus.NewVoIPEncoder(16000, 1)
defer enc.Close()

enc.SetBitrate(24000)
enc.SetComplexity(5)

// Encode 20ms of audio
pcm := make([]int16, enc.FrameSize20ms())
// ... fill pcm with audio data ...
frame, _ := enc.Encode(pcm, enc.FrameSize20ms())

// Create decoder
dec, _ := opus.NewDecoder(16000, 1)
defer dec.Close()

// Decode
pcmOut, _ := dec.Decode(frame)

// Handle packet loss
plcOut, _ := dec.DecodePLC(320) // Generate 20ms of PLC audio
</code></pre>
<hr />
<h2 id="mp3-package"><a class="header" href="#mp3-package">mp3/ Package</a></h2>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio/codec/mp3</code></p>
<h3 id="encoder-lame"><a class="header" href="#encoder-lame">Encoder (LAME)</a></h3>
<pre><code class="language-go">enc, _ := mp3.NewEncoder(sampleRate, channels, bitrate)
defer enc.Close()

mp3Data, _ := enc.Encode(pcmData)
</code></pre>
<h3 id="decoder-minimp3"><a class="header" href="#decoder-minimp3">Decoder (minimp3)</a></h3>
<pre><code class="language-go">dec, _ := mp3.NewDecoder()
defer dec.Close()

pcmData, _ := dec.Decode(mp3Data)
</code></pre>
<hr />
<h2 id="ogg-package"><a class="header" href="#ogg-package">ogg/ Package</a></h2>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio/codec/ogg</code></p>
<h3 id="stream"><a class="header" href="#stream">Stream</a></h3>
<pre><code class="language-go">// Create bitstream
stream := ogg.NewStream(serialNo)

// Add Opus packets
stream.PacketIn(packet)

// Get pages
for {
    page, ok := stream.PageOut()
    if !ok {
        break
    }
    // Write page to output
}
</code></pre>
<h3 id="sync-for-reading"><a class="header" href="#sync-for-reading">Sync (for reading)</a></h3>
<pre><code class="language-go">sync := ogg.NewSync()

// Feed data
sync.Buffer(data)

// Read pages
for {
    page, ok := sync.PageOut()
    if !ok {
        break
    }
    // Process page
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-codec---rust-implementation"><a class="header" href="#audio-codec---rust-implementation">Audio Codec - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-audio</code> (module <code>codec</code>)</p>
<h2 id="opus-module"><a class="header" href="#opus-module">opus Module</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::opus::{Encoder, Decoder, Application, Frame, TOC, FrameDuration};
<span class="boring">}</span></code></pre></pre>
<h3 id="types-13"><a class="header" href="#types-13">Types</a></h3>
<h4 id="encoder-1"><a class="header" href="#encoder-1">Encoder</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Encoder {
    sample_rate: i32,
    channels: i32,
    enc: *mut ffi::OpusEncoder,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(sample_rate: i32, channels: i32, app: Application) -&gt; Result&lt;Self&gt;</code></td><td>Create encoder</td></tr>
<tr><td><code>encode</code></td><td><code>fn encode(&amp;mut self, pcm: &amp;[i16], frame_size: i32) -&gt; Result&lt;Frame&gt;</code></td><td>Encode PCM</td></tr>
<tr><td><code>set_bitrate</code></td><td><code>fn set_bitrate(&amp;mut self, bitrate: i32) -&gt; Result&lt;()&gt;</code></td><td>Set target bitrate</td></tr>
<tr><td><code>set_complexity</code></td><td><code>fn set_complexity(&amp;mut self, complexity: i32) -&gt; Result&lt;()&gt;</code></td><td>Set CPU complexity</td></tr>
<tr><td><code>frame_size_20ms</code></td><td><code>fn frame_size_20ms(&amp;self) -&gt; i32</code></td><td>Get 20ms frame size</td></tr>
</tbody></table>
</div>
<p><strong>Application Enum:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Application {
    VoIP,
    Audio,
    RestrictedLowdelay,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="decoder-1"><a class="header" href="#decoder-1">Decoder</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Decoder {
    sample_rate: i32,
    channels: i32,
    dec: *mut ffi::OpusDecoder,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(sample_rate: i32, channels: i32) -&gt; Result&lt;Self&gt;</code></td><td>Create decoder</td></tr>
<tr><td><code>decode</code></td><td><code>fn decode(&amp;mut self, frame: &amp;Frame) -&gt; Result&lt;Vec&lt;i16&gt;&gt;</code></td><td>Decode to PCM</td></tr>
<tr><td><code>decode_plc</code></td><td><code>fn decode_plc(&amp;mut self, samples: i32) -&gt; Result&lt;Vec&lt;i16&gt;&gt;</code></td><td>Packet loss concealment</td></tr>
</tbody></table>
</div>
<h4 id="frame--toc-1"><a class="header" href="#frame--toc-1">Frame &amp; TOC</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Frame = Vec&lt;u8&gt;;

pub struct TOC {
    pub config: u8,
    pub stereo: bool,
    pub frame_count: u8,
    pub duration: FrameDuration,
}

pub enum FrameDuration {
    Ms2_5,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms60,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="usage-9"><a class="header" href="#usage-9">Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::opus::{Encoder, Decoder, Application};

// Create encoder
let mut encoder = Encoder::new(16000, 1, Application::VoIP)?;
encoder.set_bitrate(24000)?;

// Encode 20ms of audio
let frame_size = encoder.frame_size_20ms();
let pcm: Vec&lt;i16&gt; = vec![0; frame_size as usize];
let frame = encoder.encode(&amp;pcm, frame_size)?;

// Create decoder
let mut decoder = Decoder::new(16000, 1)?;

// Decode
let pcm_out = decoder.decode(&amp;frame)?;

// Handle packet loss
let plc_out = decoder.decode_plc(320)?;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mp3-module"><a class="header" href="#mp3-module">mp3 Module</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::mp3::{Encoder, Decoder};
<span class="boring">}</span></code></pre></pre>
<h3 id="encoder-lame-1"><a class="header" href="#encoder-lame-1">Encoder (LAME)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut encoder = Encoder::new(sample_rate, channels, bitrate)?;
let mp3_data = encoder.encode(&amp;pcm_data)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="decoder-minimp3-1"><a class="header" href="#decoder-minimp3-1">Decoder (minimp3)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut decoder = Decoder::new()?;
let pcm_data = decoder.decode(&amp;mp3_data)?;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="ogg-module"><a class="header" href="#ogg-module">ogg Module</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::codec::ogg::{Encoder, Stream, Sync, Page};
<span class="boring">}</span></code></pre></pre>
<h3 id="stream-1"><a class="header" href="#stream-1">Stream</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stream = Stream::new(serial_no);

// Add packets
stream.packet_in(&amp;packet);

// Get pages
while let Some(page) = stream.page_out() {
    // Write page
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sync-for-reading-1"><a class="header" href="#sync-for-reading-1">Sync (for reading)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sync = Sync::new();

// Feed data
sync.buffer(&amp;data);

// Read pages
while let Some(page) = sync.page_out() {
    // Process page
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="ffi-implementation"><a class="header" href="#ffi-implementation">FFI Implementation</a></h2>
<p>Each codec has an <code>ffi.rs</code> module with raw C bindings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// codec/opus/ffi.rs
#[repr(C)]
pub struct OpusEncoder {
    _private: [u8; 0],
}

extern "C" {
    pub fn opus_encoder_create(
        fs: i32,
        channels: i32,
        application: i32,
        error: *mut i32,
    ) -&gt; *mut OpusEncoder;
    
    pub fn opus_encode(
        enc: *mut OpusEncoder,
        pcm: *const i16,
        frame_size: i32,
        data: *mut u8,
        max_data_bytes: i32,
    ) -&gt; i32;
    
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-5"><a class="header" href="#differences-from-go-5">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>FFI approach</td><td>CGO with inline C</td><td>Separate ffi.rs module</td></tr>
<tr><td>Error handling</td><td><code>error</code> return</td><td><code>Result&lt;T, E&gt;</code></td></tr>
<tr><td>Application type</td><td>int constants</td><td>enum</td></tr>
<tr><td>Memory management</td><td>GC + C.free</td><td>Drop trait</td></tr>
<tr><td>Frame type</td><td><code>[]byte</code></td><td><code>Vec&lt;u8&gt;</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="audio-codec---known-issues"><a class="header" href="#audio-codec---known-issues">Audio Codec - Known Issues</a></h1>
<h2 id="-minor-issues-5"><a class="header" href="#-minor-issues-5">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="cod-001-go-opus-encoder-buffer-allocation-per-call"><a class="header" href="#cod-001-go-opus-encoder-buffer-allocation-per-call">COD-001: Go Opus encoder buffer allocation per call</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/codec/opus/encoder.go:95</code></p>
<p><strong>Description:</strong><br />
Encode allocates a new 4000-byte buffer on every call:</p>
<pre><code class="language-go">buf := make([]byte, 4000)
</code></pre>
<p><strong>Impact:</strong> GC pressure for high-frequency encoding (e.g., 50 calls/second for 20ms frames).</p>
<p><strong>Suggestion:</strong> Prefer existing <code>EncodeTo</code> or add a pool-backed <code>Encode</code> helper.</p>
<hr />
<h3 id="cod-002-go-opus-decoder-max-samples-hardcoded"><a class="header" href="#cod-002-go-opus-decoder-max-samples-hardcoded">COD-002: Go Opus decoder max samples hardcoded</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/codec/opus/decoder.go:58-59</code></p>
<p><strong>Description:</strong><br />
Hardcoded max samples based on 48kHz stereo:</p>
<pre><code class="language-go">maxSamples := 5760 * d.channels
buf := make([]int16, maxSamples)
</code></pre>
<p><strong>Impact:</strong> Allocation per decode, may over-allocate for lower sample rates.</p>
<hr />
<h3 id="cod-003-rust-codec-modules-lack-documentation"><a class="header" href="#cod-003-rust-codec-modules-lack-documentation">COD-003: Rust codec modules lack documentation</a></h3>
<p><strong>Description:</strong><br />
Most Rust codec functions have minimal or no documentation compared to Go.</p>
<p><strong>Impact:</strong> Less discoverable API for Rust users.</p>
<hr />
<h3 id="cod-004-no-float-pcm-support-in-encoders"><a class="header" href="#cod-004-no-float-pcm-support-in-encoders">COD-004: No float PCM support in encoders</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust opus encoders only accept int16 PCM. libopus supports float input via <code>opus_encode_float</code>.</p>
<p><strong>Impact:</strong> Extra conversion step when working with float audio pipelines.</p>
<p><strong>Suggestion:</strong> Add <code>EncodeFloat</code> variant.</p>
<hr />
<h2 id="-enhancements-6"><a class="header" href="#-enhancements-6">ğŸ”µ Enhancements</a></h2>
<h3 id="cod-005-no-opus-decoder-fec-support"><a class="header" href="#cod-005-no-opus-decoder-fec-support">COD-005: No Opus decoder FEC support</a></h3>
<p><strong>Description:</strong><br />
Forward Error Correction (FEC) is supported by libopus but not exposed in the API.</p>
<p><strong>Impact:</strong> Cannot use FEC for improved packet loss resilience.</p>
<p><strong>Suggestion:</strong> Add <code>decode_fec</code> parameter.</p>
<hr />
<h3 id="cod-006-no-mp3-vbr-encoding-option"><a class="header" href="#cod-006-no-mp3-vbr-encoding-option">COD-006: No MP3 VBR encoding option</a></h3>
<p><strong>Description:</strong><br />
MP3 encoder appears to use CBR only. VBR (Variable Bit Rate) produces better quality at same file size.</p>
<p><strong>Suggestion:</strong> Add quality-based VBR mode.</p>
<hr />
<h3 id="cod-007-ogg-container-lacks-vorbis-comment-support"><a class="header" href="#cod-007-ogg-container-lacks-vorbis-comment-support">COD-007: OGG container lacks Vorbis comment support</a></h3>
<p><strong>Description:</strong><br />
OGG encoder doesn't provide helpers for adding metadata (Vorbis comments).</p>
<p><strong>Impact:</strong> Cannot add title/artist/etc. to OGG files.</p>
<hr />
<h3 id="cod-008-no-codec-capability-queries"><a class="header" href="#cod-008-no-codec-capability-queries">COD-008: No codec capability queries</a></h3>
<p><strong>Description:</strong><br />
Cannot query supported sample rates or channel counts before creating encoder/decoder.</p>
<p><strong>Suggestion:</strong> Add <code>SupportedSampleRates() []int</code> etc.</p>
<hr />
<h2 id="-notes-6"><a class="header" href="#-notes-6">âšª Notes</a></h2>
<h3 id="cod-009-libopus-version-dependency"><a class="header" href="#cod-009-libopus-version-dependency">COD-009: libopus version dependency</a></h3>
<p><strong>Description:</strong><br />
Some features may require specific libopus versions:</p>
<ul>
<li>1.1: Basic functionality</li>
<li>1.2: Improved quality</li>
<li>1.3: Ambisonics support</li>
</ul>
<p>Currently no version checking is performed.</p>
<hr />
<h3 id="cod-010-toc-parsing-is-standalone"><a class="header" href="#cod-010-toc-parsing-is-standalone">COD-010: TOC parsing is standalone</a></h3>
<p><strong>Description:</strong><br />
TOC parsing works on raw bytes without requiring encoder/decoder. Useful for stream analysis without full codec setup.</p>
<hr />
<h3 id="cod-011-minimp3-is-header-only"><a class="header" href="#cod-011-minimp3-is-header-only">COD-011: minimp3 is header-only</a></h3>
<p><strong>Description:</strong><br />
MP3 decoder uses minimp3, a header-only library. This:</p>
<ul>
<li>Simplifies build (no separate library)</li>
<li>May have different behavior than reference decoder</li>
<li>Single-threaded only</li>
</ul>
<hr />
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>COD-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Opus</td></tr>
<tr><td>COD-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Opus</td></tr>
<tr><td>COD-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust</td></tr>
<tr><td>COD-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>COD-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>COD-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>COD-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>COD-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>COD-009</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>COD-010</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>COD-011</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Solid codec implementation. Main issues are allocation patterns and missing advanced features (FEC, float PCM, VBR).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-pcm-module"><a class="header" href="#audio-pcm-module">Audio PCM Module</a></h1>
<p>PCM (Pulse Code Modulation) audio format handling, chunks, and multi-track mixing.</p>
<h2 id="design-goals-7"><a class="header" href="#design-goals-7">Design Goals</a></h2>
<ol>
<li><strong>Standard Formats</strong>: Predefined configurations for common use cases</li>
<li><strong>Chunk Abstraction</strong>: Unified interface for audio data and silence</li>
<li><strong>Real-time Mixing</strong>: Low-latency multi-track audio mixing with gain control</li>
<li><strong>Streaming Interface</strong>: Compatible with io.Reader/io.Writer patterns</li>
</ol>
<h2 id="predefined-formats"><a class="header" href="#predefined-formats">Predefined Formats</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Sample Rate</th><th>Channels</th><th>Bit Depth</th><th>Bytes/sec</th></tr></thead><tbody>
<tr><td><code>L16Mono16K</code></td><td>16000 Hz</td><td>1</td><td>16-bit</td><td>32,000</td></tr>
<tr><td><code>L16Mono24K</code></td><td>24000 Hz</td><td>1</td><td>16-bit</td><td>48,000</td></tr>
<tr><td><code>L16Mono48K</code></td><td>48000 Hz</td><td>1</td><td>16-bit</td><td>96,000</td></tr>
</tbody></table>
</div>
<h2 id="durationbytes-calculations"><a class="header" href="#durationbytes-calculations">Duration/Bytes Calculations</a></h2>
<p>For <code>L16Mono16K</code> (16kHz, 16-bit mono):</p>
<div class="table-wrapper"><table><thead><tr><th>Duration</th><th>Samples</th><th>Bytes</th></tr></thead><tbody>
<tr><td>20ms</td><td>320</td><td>640</td></tr>
<tr><td>50ms</td><td>800</td><td>1,600</td></tr>
<tr><td>100ms</td><td>1,600</td><td>3,200</td></tr>
<tr><td>1s</td><td>16,000</td><td>32,000</td></tr>
</tbody></table>
</div>
<p>Formula: <code>bytes = samples Ã— channels Ã— (bit_depth / 8)</code></p>
<h2 id="chunk-types"><a class="header" href="#chunk-types">Chunk Types</a></h2>
<h3 id="datachunk"><a class="header" href="#datachunk">DataChunk</a></h3>
<p>Raw audio data with format metadata.</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    DataChunk    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Data: []byte    â”‚
â”‚ Format: Format  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="silencechunk"><a class="header" href="#silencechunk">SilenceChunk</a></h3>
<p>Generates silence (zeros) of specified duration without allocating.</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SilenceChunk   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Duration: time  â”‚
â”‚ Format: Format  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="mixer-architecture"><a class="header" href="#mixer-architecture">Mixer Architecture</a></h2>
<p>Multi-track audio mixer with real-time mixing and gain control:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Mixer                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Track 1 â”€â”€â”¬â”€â”€â”€â–º Mix Buffer â”€â”€â”€â–º Output (int16) â”‚
â”‚  (gain=1)  â”‚     (float32)                      â”‚
â”‚            â”‚                                     â”‚
â”‚  Track 2 â”€â”€â”¤                                     â”‚
â”‚  (gain=0.5)â”‚                                     â”‚
â”‚            â”‚                                     â”‚
â”‚  Track N â”€â”€â”˜                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Dynamic track creation/removal</li>
<li>Per-track gain control (0.0 - 1.0+)</li>
<li>Silence gap detection</li>
<li>Auto-close when all tracks done</li>
<li>Thread-safe operations</li>
</ul>
<h2 id="mixing-algorithm"><a class="header" href="#mixing-algorithm">Mixing Algorithm</a></h2>
<ol>
<li>Convert int16 PCM to float32 (-1.0 to 1.0)</li>
<li>Apply per-track gain</li>
<li>Sum all track samples</li>
<li>Clip to [-1.0, 1.0]</li>
<li>Convert back to int16</li>
</ol>
<pre><code>output = clip(Î£(track[i] Ã— gain[i]), -1.0, 1.0) Ã— 32767
</code></pre>
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h2>
<h3 id="voice-chat-mixing"><a class="header" href="#voice-chat-mixing">Voice Chat Mixing</a></h3>
<p>Multiple participants' audio mixed into single output stream.</p>
<h3 id="background-music"><a class="header" href="#background-music">Background Music</a></h3>
<p>Mix background music track with voice at lower gain.</p>
<h3 id="audio-ducking"><a class="header" href="#audio-ducking">Audio Ducking</a></h3>
<p>Reduce music volume when voice is detected.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>See parent <code>audio/</code> documentation for usage examples.</p>
<h2 id="related-modules-1"><a class="header" href="#related-modules-1">Related Modules</a></h2>
<ul>
<li><code>audio/codec/</code> - Encode/decode before/after mixing</li>
<li><code>audio/resampler/</code> - Convert sample rates before mixing</li>
<li><code>buffer/</code> - Buffer audio data between processing stages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-pcm---go-implementation"><a class="header" href="#audio-pcm---go-implementation">Audio PCM - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio/pcm</code></p>
<h2 id="types-14"><a class="header" href="#types-14">Types</a></h2>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<pre><code class="language-go">type Format int

const (
    L16Mono16K Format = iota  // audio/L16; rate=16000; channels=1
    L16Mono24K                 // audio/L16; rate=24000; channels=1
    L16Mono48K                 // audio/L16; rate=48000; channels=1
)
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>SampleRate</code></td><td><code>() int</code></td><td>Get sample rate in Hz</td></tr>
<tr><td><code>Channels</code></td><td><code>() int</code></td><td>Get channel count</td></tr>
<tr><td><code>Depth</code></td><td><code>() int</code></td><td>Get bit depth</td></tr>
<tr><td><code>Samples</code></td><td><code>(bytes int64) int64</code></td><td>Bytes to samples</td></tr>
<tr><td><code>SamplesInDuration</code></td><td><code>(d time.Duration) int64</code></td><td>Duration to samples</td></tr>
<tr><td><code>BytesInDuration</code></td><td><code>(d time.Duration) int64</code></td><td>Duration to bytes</td></tr>
<tr><td><code>Duration</code></td><td><code>(bytes int64) time.Duration</code></td><td>Bytes to duration</td></tr>
<tr><td><code>BitsRate</code></td><td><code>() int</code></td><td>Get bits per second</td></tr>
<tr><td><code>BytesRate</code></td><td><code>() int</code></td><td>Get bytes per second</td></tr>
<tr><td><code>SilenceChunk</code></td><td><code>(d time.Duration) Chunk</code></td><td>Create silence chunk</td></tr>
<tr><td><code>DataChunk</code></td><td><code>(data []byte) Chunk</code></td><td>Create data chunk</td></tr>
<tr><td><code>ReadChunk</code></td><td><code>(r io.Reader, d time.Duration) (Chunk, error)</code></td><td>Read chunk from reader</td></tr>
<tr><td><code>String</code></td><td><code>() string</code></td><td>Human-readable format</td></tr>
</tbody></table>
</div>
<h3 id="chunk-interface"><a class="header" href="#chunk-interface">Chunk Interface</a></h3>
<pre><code class="language-go">type Chunk interface {
    Len() int64
    Format() Format
    WriteTo(w io.Writer) (int64, error)
}
</code></pre>
<h3 id="datachunk-1"><a class="header" href="#datachunk-1">DataChunk</a></h3>
<pre><code class="language-go">type DataChunk struct {
    Data []byte
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Len</code></td><td><code>() int64</code></td><td>Data length</td></tr>
<tr><td><code>Format</code></td><td><code>() Format</code></td><td>Audio format</td></tr>
<tr><td><code>ReadFrom</code></td><td><code>(r io.Reader) (int64, error)</code></td><td>Read into chunk</td></tr>
<tr><td><code>WriteTo</code></td><td><code>(w io.Writer) (int64, error)</code></td><td>Write chunk data</td></tr>
</tbody></table>
</div>
<h3 id="silencechunk-1"><a class="header" href="#silencechunk-1">SilenceChunk</a></h3>
<pre><code class="language-go">type SilenceChunk struct {
    Duration time.Duration
}
</code></pre>
<p>Writes zeros without allocating a full buffer.</p>
<h3 id="mixer-1"><a class="header" href="#mixer-1">Mixer</a></h3>
<pre><code class="language-go">type Mixer struct {
    output    Format
    // ... internal fields
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewMixer</code></td><td><code>func NewMixer(output Format, opts ...MixerOption) *Mixer</code></td><td>Create mixer</td></tr>
<tr><td><code>Output</code></td><td><code>() Format</code></td><td>Get output format</td></tr>
<tr><td><code>CreateTrack</code></td><td><code>(opts ...TrackOption) (Track, *TrackCtrl, error)</code></td><td>Create track</td></tr>
<tr><td><code>Read</code></td><td><code>(p []byte) (int, error)</code></td><td>Read mixed audio</td></tr>
<tr><td><code>CloseWrite</code></td><td><code>() error</code></td><td>Stop accepting new tracks</td></tr>
<tr><td><code>Close</code></td><td><code>() error</code></td><td>Close mixer</td></tr>
<tr><td><code>CloseWithError</code></td><td><code>(err error) error</code></td><td>Close with error</td></tr>
</tbody></table>
</div>
<p><strong>Options:</strong></p>
<pre><code class="language-go">// Auto-close when all tracks are done
mixer := NewMixer(L16Mono16K, WithAutoClose())

// Close after silence duration
mixer := NewMixer(L16Mono16K, WithSilenceGap(5*time.Second))
</code></pre>
<h3 id="track--trackctrl"><a class="header" href="#track--trackctrl">Track &amp; TrackCtrl</a></h3>
<pre><code class="language-go">type Track interface {
    Write(p []byte) (int, error)
    WriteChunk(c Chunk) (int64, error)
    Close() error
    CloseWithError(err error) error
}

type TrackCtrl struct {
    // ...
}
</code></pre>
<p><strong>TrackCtrl Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Gain</code></td><td><code>() float32</code></td><td>Get current gain</td></tr>
<tr><td><code>SetGain</code></td><td><code>(g float32)</code></td><td>Set gain (0.0 - 1.0+)</td></tr>
<tr><td><code>CloseWrite</code></td><td><code>() error</code></td><td>Stop writing</td></tr>
<tr><td><code>CloseWithError</code></td><td><code>(err error) error</code></td><td>Close with error</td></tr>
</tbody></table>
</div>
<h2 id="usage-10"><a class="header" href="#usage-10">Usage</a></h2>
<h3 id="format-calculations"><a class="header" href="#format-calculations">Format Calculations</a></h3>
<pre><code class="language-go">format := pcm.L16Mono16K

// Calculate for 100ms
bytes := format.BytesInDuration(100 * time.Millisecond)
// bytes = 3200

samples := format.SamplesInDuration(100 * time.Millisecond)
// samples = 1600

// Reverse calculation
duration := format.Duration(3200)
// duration = 100ms
</code></pre>
<h3 id="creating-chunks"><a class="header" href="#creating-chunks">Creating Chunks</a></h3>
<pre><code class="language-go">format := pcm.L16Mono16K

// Data chunk
data := make([]byte, 3200) // 100ms
chunk := format.DataChunk(data)

// Silence chunk (no allocation)
silence := format.SilenceChunk(100 * time.Millisecond)

// Read chunk from io.Reader
chunk, err := format.ReadChunk(reader, 100*time.Millisecond)
</code></pre>
<h3 id="mixer-example"><a class="header" href="#mixer-example">Mixer Example</a></h3>
<pre><code class="language-go">mixer := pcm.NewMixer(pcm.L16Mono16K, pcm.WithAutoClose())

// Create voice track
voice, voiceCtrl, _ := mixer.CreateTrack(pcm.WithTrackLabel("voice"))
voiceCtrl.SetGain(1.0)

// Create music track at lower volume
music, musicCtrl, _ := mixer.CreateTrack(pcm.WithTrackLabel("music"))
musicCtrl.SetGain(0.3)

// Write audio to tracks (in separate goroutines)
go func() {
    voice.Write(voiceData)
    voice.Close()
}()
go func() {
    music.Write(musicData)
    music.Close()
}()

// Read mixed output
buf := make([]byte, 3200)
for {
    n, err := mixer.Read(buf)
    if err == io.EOF {
        break
    }
    // Process mixed audio in buf[:n]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-pcm---rust-implementation"><a class="header" href="#audio-pcm---rust-implementation">Audio PCM - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-audio</code> (module <code>pcm</code>)</p>
<h2 id="types-15"><a class="header" href="#types-15">Types</a></h2>
<h3 id="format-1"><a class="header" href="#format-1">Format</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Re-exported from resampler module
pub use crate::resampler::format::Format;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Format {
    L16Mono16K,  // 16000 Hz, mono, 16-bit
    L16Mono24K,  // 24000 Hz, mono, 16-bit
    L16Mono48K,  // 48000 Hz, mono, 16-bit
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sample_rate</code></td><td><code>fn sample_rate(&amp;self) -&gt; u32</code></td><td>Get sample rate in Hz</td></tr>
<tr><td><code>channels</code></td><td><code>fn channels(&amp;self) -&gt; u32</code></td><td>Get channel count</td></tr>
<tr><td><code>depth</code></td><td><code>fn depth(&amp;self) -&gt; u32</code></td><td>Get bit depth</td></tr>
<tr><td><code>samples</code></td><td><code>fn samples(&amp;self, bytes: u64) -&gt; u64</code></td><td>Bytes to samples</td></tr>
<tr><td><code>samples_in_duration</code></td><td><code>fn samples_in_duration(&amp;self, d: Duration) -&gt; u64</code></td><td>Duration to samples</td></tr>
<tr><td><code>bytes_in_duration</code></td><td><code>fn bytes_in_duration(&amp;self, d: Duration) -&gt; u64</code></td><td>Duration to bytes</td></tr>
<tr><td><code>duration</code></td><td><code>fn duration(&amp;self, bytes: u64) -&gt; Duration</code></td><td>Bytes to duration</td></tr>
<tr><td><code>bits_rate</code></td><td><code>fn bits_rate(&amp;self) -&gt; u32</code></td><td>Get bits per second</td></tr>
<tr><td><code>bytes_rate</code></td><td><code>fn bytes_rate(&amp;self) -&gt; u32</code></td><td>Get bytes per second</td></tr>
</tbody></table>
</div>
<h3 id="formatext-trait"><a class="header" href="#formatext-trait">FormatExt Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FormatExt {
    fn silence_chunk(&amp;self, duration: Duration) -&gt; SilenceChunk;
    fn data_chunk(&amp;self, data: Vec&lt;u8&gt;) -&gt; DataChunk;
    fn data_chunk_from_samples(&amp;self, samples: &amp;[i16]) -&gt; DataChunk;
}

impl FormatExt for Format { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<h3 id="chunk-trait"><a class="header" href="#chunk-trait">Chunk Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Chunk {
    fn len(&amp;self) -&gt; u64;
    fn format(&amp;self) -&gt; Format;
    fn write_to&lt;W: Write&gt;(&amp;self, writer: &amp;mut W) -&gt; io::Result&lt;u64&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="datachunk-2"><a class="header" href="#datachunk-2">DataChunk</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DataChunk {
    data: Vec&lt;u8&gt;,
    format: Format,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="silencechunk-2"><a class="header" href="#silencechunk-2">SilenceChunk</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SilenceChunk {
    duration: Duration,
    len: u64,
    format: Format,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mixer-2"><a class="header" href="#mixer-2">Mixer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mixer {
    output: Format,
    // ... internal fields
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(output: Format, opts: MixerOptions) -&gt; Self</code></td><td>Create mixer</td></tr>
<tr><td><code>output</code></td><td><code>fn output(&amp;self) -&gt; Format</code></td><td>Get output format</td></tr>
<tr><td><code>create_track</code></td><td><code>fn create_track(&amp;mut self, opts: Option&lt;TrackOptions&gt;) -&gt; Result&lt;(Track, TrackCtrl)&gt;</code></td><td>Create track</td></tr>
<tr><td><code>read</code></td><td><code>fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;</code></td><td>Read mixed audio</td></tr>
<tr><td><code>close_write</code></td><td><code>fn close_write(&amp;mut self) -&gt; Result&lt;()&gt;</code></td><td>Stop accepting tracks</td></tr>
<tr><td><code>close</code></td><td><code>fn close(&amp;mut self) -&gt; Result&lt;()&gt;</code></td><td>Close mixer</td></tr>
</tbody></table>
</div>
<h3 id="mixeroptions"><a class="header" href="#mixeroptions">MixerOptions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct MixerOptions {
    pub auto_close: bool,
    pub silence_gap: Option&lt;Duration&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="track--trackctrl-1"><a class="header" href="#track--trackctrl-1">Track &amp; TrackCtrl</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Track {
    // ...
}

impl Track {
    pub fn write(&amp;mut self, data: &amp;[u8]) -&gt; io::Result&lt;usize&gt;;
    pub fn close(&amp;mut self) -&gt; Result&lt;()&gt;;
}

pub struct TrackCtrl {
    // ...
}

impl TrackCtrl {
    pub fn gain(&amp;self) -&gt; f32;
    pub fn set_gain(&amp;self, gain: f32);
    pub fn close_write(&amp;mut self) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="atomicf32"><a class="header" href="#atomicf32">AtomicF32</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AtomicF32 {
    bits: AtomicU32,
}

impl AtomicF32 {
    pub fn new(value: f32) -&gt; Self;
    pub fn load(&amp;self) -&gt; f32;
    pub fn store(&amp;self, value: f32);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-11"><a class="header" href="#usage-11">Usage</a></h2>
<h3 id="format-calculations-1"><a class="header" href="#format-calculations-1">Format Calculations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::pcm::Format;
use std::time::Duration;

let format = Format::L16Mono16K;

// Calculate for 100ms
let bytes = format.bytes_in_duration(Duration::from_millis(100));
// bytes = 3200

let samples = format.samples_in_duration(Duration::from_millis(100));
// samples = 1600

// Reverse calculation
let duration = format.duration(3200);
// duration = 100ms
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-chunks-1"><a class="header" href="#creating-chunks-1">Creating Chunks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::pcm::{Format, FormatExt};
use std::time::Duration;

let format = Format::L16Mono16K;

// Data chunk from bytes
let data = vec![0u8; 3200]; // 100ms
let chunk = format.data_chunk(data);

// Data chunk from samples
let samples: Vec&lt;i16&gt; = vec![0; 1600];
let chunk = format.data_chunk_from_samples(&amp;samples);

// Silence chunk
let silence = format.silence_chunk(Duration::from_millis(100));
<span class="boring">}</span></code></pre></pre>
<h3 id="mixer-example-1"><a class="header" href="#mixer-example-1">Mixer Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::pcm::{Format, Mixer, MixerOptions};

let opts = MixerOptions {
    auto_close: true,
    ..Default::default()
};
let mut mixer = Mixer::new(Format::L16Mono16K, opts);

// Create voice track
let (mut voice, voice_ctrl) = mixer.create_track(None)?;
voice_ctrl.set_gain(1.0);

// Create music track
let (mut music, music_ctrl) = mixer.create_track(None)?;
music_ctrl.set_gain(0.3);

// Write audio (in separate threads)
std::thread::spawn(move || {
    voice.write(&amp;voice_data).unwrap();
    voice.close().unwrap();
});

// Read mixed output
let mut buf = vec![0u8; 3200];
loop {
    match mixer.read(&amp;mut buf) {
        Ok(0) =&gt; break,
        Ok(n) =&gt; { /* process buf[..n] */ }
        Err(e) =&gt; break,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-6"><a class="header" href="#differences-from-go-6">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Format location</td><td>In <code>pcm/</code></td><td>In <code>resampler/</code>, re-exported</td></tr>
<tr><td>Chunk creation</td><td><code>format.DataChunk()</code></td><td><code>format.data_chunk()</code> via trait</td></tr>
<tr><td>Mixer options</td><td>Variadic options</td><td>Options struct</td></tr>
<tr><td>Track creation</td><td>Returns 3 values</td><td>Returns tuple</td></tr>
<tr><td>Atomic float</td><td>Custom <code>AtomicFloat32</code></td><td>Custom <code>AtomicF32</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="audio-pcm---known-issues"><a class="header" href="#audio-pcm---known-issues">Audio PCM - Known Issues</a></h1>
<h2 id="-minor-issues-6"><a class="header" href="#-minor-issues-6">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="pcm-001-format-panics-on-invalid-values"><a class="header" href="#pcm-001-format-panics-on-invalid-values">PCM-001: Format panics on invalid values</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/pcm.go:36-38</code></p>
<p><strong>Description:</strong><br />
All Format methods panic if the format value is invalid:</p>
<pre><code class="language-go">func (f Format) SampleRate() int {
    switch f {
    case L16Mono16K:
        return 16000
    // ...
    }
    panic("pcm: invalid audio type")
}
</code></pre>
<p><strong>Impact:</strong> Runtime panic if format is incorrectly initialized.</p>
<p><strong>Suggestion:</strong> Return <code>(int, error)</code> or add validation method.</p>
<hr />
<h3 id="pcm-002-silencechunk-uses-global-buffer"><a class="header" href="#pcm-002-silencechunk-uses-global-buffer">PCM-002: SilenceChunk uses global buffer</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/pcm.go:177</code></p>
<p><strong>Description:</strong><br />
SilenceChunk shares a global 32KB zero buffer:</p>
<pre><code class="language-go">var emptyBytes [32000]byte
</code></pre>
<p><strong>Impact:</strong><br />
No functional issue; <code>WriteTo</code> loops and handles any length. Shared buffer avoids allocations.</p>
<hr />
<h3 id="pcm-003-mixer-notifywrite-creates-goroutine-per-call"><a class="header" href="#pcm-003-mixer-notifywrite-creates-goroutine-per-call">PCM-003: Mixer notifyWrite creates goroutine per call</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/mixer.go:391-405</code></p>
<p><strong>Description:</strong><br />
Each write notification spawns a goroutine:</p>
<pre><code class="language-go">func (mx *Mixer) notifyWrite() {
    go func() {
        // ...
    }()
}
</code></pre>
<p><strong>Impact:</strong> Goroutine creation overhead for every track write.</p>
<p><strong>Suggestion:</strong> Use dedicated notification channel without goroutine.</p>
<hr />
<h3 id="pcm-004-mixer-uses-unsafe-pointer-casting"><a class="header" href="#pcm-004-mixer-uses-unsafe-pointer-casting">PCM-004: Mixer uses unsafe pointer casting</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/mixer.go:226</code></p>
<p><strong>Description:</strong><br />
Converts between byte slice and int16 slice using unsafe:</p>
<pre><code class="language-go">i16 := unsafe.Slice((*int16)(unsafe.Pointer(&amp;p[0])), len(p)/2)
</code></pre>
<p><strong>Risk:</strong> Assumes little-endian, may have alignment issues.</p>
<hr />
<h3 id="pcm-005-track-buffer-allocation-per-read"><a class="header" href="#pcm-005-track-buffer-allocation-per-read">PCM-005: Track buffer allocation per read</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/pcm/mixer.go:341</code></p>
<p><strong>Description:</strong><br />
Allocates temporary buffer for each track read:</p>
<pre><code class="language-go">trackBuf := make([]byte, len(p))
</code></pre>
<p><strong>Impact:</strong> GC pressure during mixing.</p>
<p><strong>Suggestion:</strong> Use per-track persistent buffer or sync.Pool.</p>
<hr />
<h3 id="pcm-006-rust-format-re-export-is-confusing"><a class="header" href="#pcm-006-rust-format-re-export-is-confusing">PCM-006: Rust Format re-export is confusing</a></h3>
<p><strong>File:</strong> <code>rust/audio/src/pcm/format.rs:7</code></p>
<p><strong>Description:</strong><br />
Format is defined in <code>resampler</code> but re-exported by <code>pcm</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use crate::resampler::format::Format;
<span class="boring">}</span></code></pre></pre>
<p><strong>Impact:</strong> Import path confusion.</p>
<hr />
<h2 id="-enhancements-7"><a class="header" href="#-enhancements-7">ğŸ”µ Enhancements</a></h2>
<h3 id="pcm-007-no-stereo-format-support"><a class="header" href="#pcm-007-no-stereo-format-support">PCM-007: No stereo format support</a></h3>
<p><strong>Description:</strong><br />
Only mono formats are predefined. Stereo is common for music.</p>
<p><strong>Suggestion:</strong> Add <code>L16Stereo16K</code>, etc.</p>
<hr />
<h3 id="pcm-008-no-24-bit-or-32-bit-pcm"><a class="header" href="#pcm-008-no-24-bit-or-32-bit-pcm">PCM-008: No 24-bit or 32-bit PCM</a></h3>
<p><strong>Description:</strong><br />
Only 16-bit depth supported. Professional audio uses 24/32-bit.</p>
<p><strong>Suggestion:</strong> Add higher bit depth variants.</p>
<hr />
<h3 id="pcm-009-no-channel-downmix-in-mixer"><a class="header" href="#pcm-009-no-channel-downmix-in-mixer">PCM-009: No channel downmix in mixer</a></h3>
<p><strong>Description:</strong><br />
Mixer doesn't handle mixing stereo sources to mono output or vice versa.</p>
<p><strong>Suggestion:</strong> Add automatic channel conversion.</p>
<hr />
<h3 id="pcm-010-no-mixer-input-resampling"><a class="header" href="#pcm-010-no-mixer-input-resampling">PCM-010: No mixer input resampling</a></h3>
<p><strong>Description:</strong><br />
All tracks must match mixer output sample rate. No automatic resampling.</p>
<p><strong>Suggestion:</strong> Auto-resample tracks that don't match output format.</p>
<hr />
<h3 id="pcm-011-no-track-volume-ramping"><a class="header" href="#pcm-011-no-track-volume-ramping">PCM-011: No track volume ramping</a></h3>
<p><strong>Description:</strong><br />
Gain changes apply instantly, potentially causing clicks.</p>
<p><strong>Suggestion:</strong> Add smooth gain transition over configurable duration.</p>
<hr />
<h2 id="-notes-7"><a class="header" href="#-notes-7">âšª Notes</a></h2>
<h3 id="pcm-012-float32-internal-mixing"><a class="header" href="#pcm-012-float32-internal-mixing">PCM-012: Float32 internal mixing</a></h3>
<p><strong>Description:</strong><br />
Mixer converts int16â†’float32â†’int16 internally for headroom during mixing. This is standard practice but involves precision loss.</p>
<hr />
<h3 id="pcm-013-mixer-silence-gap-behavior"><a class="header" href="#pcm-013-mixer-silence-gap-behavior">PCM-013: Mixer silence gap behavior</a></h3>
<p><strong>Description:</strong><br />
When <code>WithSilenceGap</code> is set:</p>
<ul>
<li>Mixer tracks continuous silence duration</li>
<li>Closes after gap threshold</li>
<li>Initial silence counts from gap to avoid leading silence</li>
</ul>
<p>Complex logic that could be confusing.</p>
<hr />
<h3 id="pcm-014-atomicfloat32-implementation"><a class="header" href="#pcm-014-atomicfloat32-implementation">PCM-014: AtomicFloat32 implementation</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust implement atomic float32 via bit reinterpretation:</p>
<pre><code class="language-go">func (a *AtomicFloat32) Load() float32 {
    return math.Float32frombits(a.v.Load())
}
</code></pre>
<p>Standard technique, but worth documenting.</p>
<hr />
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>PCM-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Format</td></tr>
<tr><td>PCM-002</td><td>âšª Note</td><td>N/A</td><td>Go Silence</td></tr>
<tr><td>PCM-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Mixer</td></tr>
<tr><td>PCM-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Mixer</td></tr>
<tr><td>PCM-005</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Mixer</td></tr>
<tr><td>PCM-006</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust</td></tr>
<tr><td>PCM-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>PCM-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>PCM-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>PCM-010</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>PCM-011</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>PCM-012</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>PCM-013</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>PCM-014</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Functional PCM handling and mixing. Main concerns are allocation patterns and missing format variants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-resampler-module"><a class="header" href="#audio-resampler-module">Audio Resampler Module</a></h1>
<p>Sample rate conversion using libsoxr (SoX Resampler Library).</p>
<h2 id="design-goals-8"><a class="header" href="#design-goals-8">Design Goals</a></h2>
<ol>
<li><strong>High Quality</strong>: Professional-grade resampling via libsoxr</li>
<li><strong>Streaming</strong>: Process audio as continuous stream, not files</li>
<li><strong>Channel Conversion</strong>: Support monoâ†”stereo conversion</li>
<li><strong>io.Reader Interface</strong>: Drop-in replacement for audio sources</li>
</ol>
<h2 id="supported-conversions"><a class="header" href="#supported-conversions">Supported Conversions</a></h2>
<h3 id="sample-rate"><a class="header" href="#sample-rate">Sample Rate</a></h3>
<p>Any integer sample rate to any other integer sample rate:</p>
<ul>
<li>8000 Hz â†” 16000 Hz â†” 24000 Hz â†” 48000 Hz</li>
<li>Non-standard rates supported</li>
</ul>
<h3 id="channel-conversion"><a class="header" href="#channel-conversion">Channel Conversion</a></h3>
<div class="table-wrapper"><table><thead><tr><th>From</th><th>To</th><th>Method</th></tr></thead><tbody>
<tr><td>Mono</td><td>Stereo</td><td>Duplicate</td></tr>
<tr><td>Stereo</td><td>Mono</td><td>Average (L+R)/2</td></tr>
</tbody></table>
</div>
<h2 id="quality-levels"><a class="header" href="#quality-levels">Quality Levels</a></h2>
<p>libsoxr supports multiple quality presets:</p>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>Quick</td><td>Low quality, fast</td></tr>
<tr><td>1</td><td>Low</td><td>Better than quick</td></tr>
<tr><td>2</td><td>Medium</td><td>Balance of quality/speed</td></tr>
<tr><td>3</td><td>High</td><td>Good quality (default)</td></tr>
<tr><td>4</td><td>Very High</td><td>Best quality</td></tr>
</tbody></table>
</div>
<p><strong>Note:</strong> Current implementation uses High quality by default.</p>
<h2 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h2>
<p>libsoxr uses polyphase filter banks with configurable:</p>
<ul>
<li>Passband rolloff</li>
<li>Stop-band attenuation</li>
<li>Linear/minimum phase</li>
</ul>
<p>The High quality preset provides:</p>
<ul>
<li>Passband: 0-0.91 Nyquist</li>
<li>Stop-band attenuation: -100 dB</li>
<li>Linear phase</li>
</ul>
<h2 id="common-resampling-scenarios"><a class="header" href="#common-resampling-scenarios">Common Resampling Scenarios</a></h2>
<h3 id="speech-api-to-local-playback"><a class="header" href="#speech-api-to-local-playback">Speech API to Local Playback</a></h3>
<pre><code>API Output (24kHz) â†’ Resample â†’ Mixer Input (16kHz)
</code></pre>
<h3 id="local-capture-to-speech-api"><a class="header" href="#local-capture-to-speech-api">Local Capture to Speech API</a></h3>
<pre><code>Microphone (48kHz) â†’ Resample â†’ API Input (16kHz)
</code></pre>
<h3 id="multi-source-mixing"><a class="header" href="#multi-source-mixing">Multi-source Mixing</a></h3>
<pre><code>Source 1 (24kHz) â”€â”¬â”€â–º Resample â”€â–º 16kHz â”€â”
Source 2 (16kHz) â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”œâ”€â–º Mixer
Source 3 (48kHz) â”€â”´â”€â–º Resample â”€â–º 16kHz â”€â”˜
</code></pre>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<p>Approximate cycles per sample (on modern CPU):</p>
<ul>
<li>Quick: ~10</li>
<li>High: ~50-100</li>
<li>Very High: ~200-500</li>
</ul>
<p>For real-time 16kHz mono:</p>
<ul>
<li>16000 samples/sec Ã— 100 cycles â‰ˆ 1.6M cycles/sec</li>
<li>Negligible CPU load on modern hardware</li>
</ul>
<h2 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h2>
<p>libsoxr maintains internal buffers for filter state:</p>
<ul>
<li>~10-50KB per resampler instance</li>
<li>More for higher quality settings</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>See parent <code>audio/</code> documentation for usage examples.</p>
<h2 id="related-modules-2"><a class="header" href="#related-modules-2">Related Modules</a></h2>
<ul>
<li><code>audio/pcm/</code> - Format definitions, use with resampler</li>
<li><code>audio/codec/</code> - Often resample before/after encoding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-resampler---go-implementation"><a class="header" href="#audio-resampler---go-implementation">Audio Resampler - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio/resampler</code></p>
<h2 id="types-16"><a class="header" href="#types-16">Types</a></h2>
<h3 id="resampler-interface"><a class="header" href="#resampler-interface">Resampler Interface</a></h3>
<pre><code class="language-go">type Resampler interface {
    io.ReadCloser
    CloseWithError(error) error
}
</code></pre>
<h3 id="format-2"><a class="header" href="#format-2">Format</a></h3>
<pre><code class="language-go">type Format struct {
    SampleRate int
    Stereo     bool
}
</code></pre>
<p><strong>Helper Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sampleBytes</code></td><td><code>() int</code></td><td>Bytes per sample (2 or 4)</td></tr>
<tr><td><code>channels</code></td><td><code>() int</code></td><td>Channel count (1 or 2)</td></tr>
</tbody></table>
</div>
<h3 id="soxr"><a class="header" href="#soxr">Soxr</a></h3>
<pre><code class="language-go">type Soxr struct {
    srcFmt Format
    dstFmt Format
    // ... internal fields
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>New</code></td><td><code>func New(src io.Reader, srcFmt, dstFmt Format) (Resampler, error)</code></td><td>Create resampler</td></tr>
<tr><td><code>Read</code></td><td><code>(r *Soxr) Read(p []byte) (int, error)</code></td><td>Read resampled data</td></tr>
<tr><td><code>Close</code></td><td><code>(r *Soxr) Close() error</code></td><td>Release resources</td></tr>
<tr><td><code>CloseWithError</code></td><td><code>(r *Soxr) CloseWithError(err error) error</code></td><td>Close with custom error</td></tr>
</tbody></table>
</div>
<h3 id="samplereader"><a class="header" href="#samplereader">SampleReader</a></h3>
<p>Utility for reading complete samples from a reader that may return partial data.</p>
<pre><code class="language-go">// Internal helper - ensures reads are sample-aligned
sr := newSampleReader(reader, sampleBytes)
</code></pre>
<h2 id="usage-12"><a class="header" href="#usage-12">Usage</a></h2>
<h3 id="basic-resampling"><a class="header" href="#basic-resampling">Basic Resampling</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/resampler"

// 24kHz to 16kHz
srcFmt := resampler.Format{SampleRate: 24000, Stereo: false}
dstFmt := resampler.Format{SampleRate: 16000, Stereo: false}

rs, err := resampler.New(audioSource, srcFmt, dstFmt)
if err != nil {
    return err
}
defer rs.Close()

// Read resampled data
buf := make([]byte, 3200) // 100ms at 16kHz mono
for {
    n, err := rs.Read(buf)
    if err == io.EOF {
        break
    }
    if err != nil {
        return err
    }
    // Process buf[:n]
}
</code></pre>
<h3 id="stereo-to-mono"><a class="header" href="#stereo-to-mono">Stereo to Mono</a></h3>
<pre><code class="language-go">srcFmt := resampler.Format{SampleRate: 48000, Stereo: true}
dstFmt := resampler.Format{SampleRate: 16000, Stereo: false}

rs, _ := resampler.New(stereoSource, srcFmt, dstFmt)
// Output is downmixed mono at 16kHz
</code></pre>
<h3 id="mono-to-stereo"><a class="header" href="#mono-to-stereo">Mono to Stereo</a></h3>
<pre><code class="language-go">srcFmt := resampler.Format{SampleRate: 16000, Stereo: false}
dstFmt := resampler.Format{SampleRate: 48000, Stereo: true}

rs, _ := resampler.New(monoSource, srcFmt, dstFmt)
// Output is duplicated stereo at 48kHz
</code></pre>
<h3 id="pipeline-with-decoder"><a class="header" href="#pipeline-with-decoder">Pipeline with Decoder</a></h3>
<pre><code class="language-go">// MP3 (24kHz) â†’ Decode â†’ Resample â†’ Mixer (16kHz)
mp3Data := bytes.NewReader(encodedData)
decoder, _ := mp3.NewDecoder(mp3Data)

srcFmt := resampler.Format{SampleRate: 24000, Stereo: false}
dstFmt := resampler.Format{SampleRate: 16000, Stereo: false}

rs, _ := resampler.New(decoder, srcFmt, dstFmt)

// Feed to mixer
track.WriteFrom(rs)
</code></pre>
<h2 id="cgo-details"><a class="header" href="#cgo-details">CGO Details</a></h2>
<pre><code class="language-go">/*
#cgo pkg-config: soxr
#include &lt;soxr.h&gt;
*/
import "C"

// Quality setting (hardcoded to HQ)
qSpec := C.soxr_quality_spec(C.SOXR_HQ, 0)

// I/O format (int16 for both input and output)
ioSpec := C.soxr_io_spec(C.SOXR_INT16_I, C.SOXR_INT16_I)
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<ul>
<li><code>io.EOF</code>: Source exhausted, resampler flushed</li>
<li><code>io.ErrShortBuffer</code>: Output buffer too small for one sample</li>
<li><code>io.ErrClosedPipe</code>: Resampler was closed</li>
</ul>
<h2 id="thread-safety-2"><a class="header" href="#thread-safety-2">Thread Safety</a></h2>
<ul>
<li><code>Read</code> is NOT safe for concurrent calls</li>
<li><code>Close</code>/<code>CloseWithError</code> can be called from any goroutine</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-resampler---rust-implementation"><a class="header" href="#audio-resampler---rust-implementation">Audio Resampler - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-audio</code> (module <code>resampler</code>)</p>
<h2 id="types-17"><a class="header" href="#types-17">Types</a></h2>
<h3 id="format-3"><a class="header" href="#format-3">Format</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Format {
    pub sample_rate: u32,
    pub stereo: bool,
}

impl Format {
    pub const L16Mono16K: Self = Self { sample_rate: 16000, stereo: false };
    pub const L16Mono24K: Self = Self { sample_rate: 24000, stereo: false };
    pub const L16Mono48K: Self = Self { sample_rate: 48000, stereo: false };
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sample_rate</code></td><td><code>fn sample_rate(&amp;self) -&gt; u32</code></td><td>Get sample rate</td></tr>
<tr><td><code>channels</code></td><td><code>fn channels(&amp;self) -&gt; u32</code></td><td>Get channel count (1 or 2)</td></tr>
<tr><td><code>depth</code></td><td><code>fn depth(&amp;self) -&gt; u32</code></td><td>Always 16</td></tr>
<tr><td><code>samples</code></td><td><code>fn samples(&amp;self, bytes: u64) -&gt; u64</code></td><td>Bytes to samples</td></tr>
<tr><td><code>samples_in_duration</code></td><td><code>fn samples_in_duration(&amp;self, d: Duration) -&gt; u64</code></td><td>Duration to samples</td></tr>
<tr><td><code>bytes_in_duration</code></td><td><code>fn bytes_in_duration(&amp;self, d: Duration) -&gt; u64</code></td><td>Duration to bytes</td></tr>
<tr><td><code>duration</code></td><td><code>fn duration(&amp;self, bytes: u64) -&gt; Duration</code></td><td>Bytes to duration</td></tr>
<tr><td><code>bits_rate</code></td><td><code>fn bits_rate(&amp;self) -&gt; u32</code></td><td>Bits per second</td></tr>
<tr><td><code>bytes_rate</code></td><td><code>fn bytes_rate(&amp;self) -&gt; u32</code></td><td>Bytes per second</td></tr>
</tbody></table>
</div>
<h3 id="soxr-1"><a class="header" href="#soxr-1">Soxr</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Soxr {
    src_fmt: Format,
    dst_fmt: Format,
    soxr: *mut ffi::soxr,
    // ... internal fields
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(src_fmt: Format, dst_fmt: Format) -&gt; Result&lt;Self&gt;</code></td><td>Create resampler</td></tr>
<tr><td><code>process</code></td><td><code>fn process(&amp;mut self, input: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code></td><td>Resample data</td></tr>
<tr><td><code>flush</code></td><td><code>fn flush(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code></td><td>Flush remaining data</td></tr>
</tbody></table>
</div>
<h3 id="samplereader-1"><a class="header" href="#samplereader-1">SampleReader</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SampleReader&lt;R&gt; {
    inner: R,
    sample_size: usize,
    buffer: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Ensures reads are sample-aligned.</p>
<h2 id="usage-13"><a class="header" href="#usage-13">Usage</a></h2>
<h3 id="basic-resampling-1"><a class="header" href="#basic-resampling-1">Basic Resampling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::resampler::{Soxr, Format};

// 24kHz to 16kHz
let src_fmt = Format { sample_rate: 24000, stereo: false };
let dst_fmt = Format { sample_rate: 16000, stereo: false };

let mut resampler = Soxr::new(src_fmt, dst_fmt)?;

// Resample data
let output = resampler.process(&amp;input_pcm)?;

// Flush at end of stream
let final_output = resampler.flush()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="format-calculations-2"><a class="header" href="#format-calculations-2">Format Calculations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::resampler::Format;
use std::time::Duration;

let format = Format::L16Mono16K;

// Calculate buffer size for 100ms
let bytes = format.bytes_in_duration(Duration::from_millis(100));
// bytes = 3200

let samples = format.samples_in_duration(Duration::from_millis(100));
// samples = 1600

// Convert bytes to duration
let duration = format.duration(3200);
// duration = 100ms
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-format"><a class="header" href="#custom-format">Custom Format</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 44.1kHz stereo (CD quality)
let cd_format = Format {
    sample_rate: 44100,
    stereo: true,
};

// 8kHz mono (telephone)
let phone_format = Format {
    sample_rate: 8000,
    stereo: false,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="ffi-bindings-1"><a class="header" href="#ffi-bindings-1">FFI Bindings</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// resampler/ffi.rs
#[repr(C)]
pub struct soxr {
    _private: [u8; 0],
}

extern "C" {
    pub fn soxr_create(
        input_rate: f64,
        output_rate: f64,
        num_channels: c_uint,
        error: *mut soxr_error,
        io_spec: *const soxr_io_spec,
        quality_spec: *const soxr_quality_spec,
        runtime_spec: *const soxr_runtime_spec,
    ) -&gt; *mut soxr;
    
    pub fn soxr_process(
        soxr: *mut soxr,
        in_: soxr_in,
        ilen: usize,
        idone: *mut usize,
        out: soxr_out,
        olen: usize,
        odone: *mut usize,
    ) -&gt; soxr_error;
    
    pub fn soxr_delete(soxr: *mut soxr);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-7"><a class="header" href="#differences-from-go-7">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>API style</td><td>io.Reader wrapper</td><td>Direct process() method</td></tr>
<tr><td>Input source</td><td>Takes io.Reader</td><td>Takes byte slices</td></tr>
<tr><td>Channel convert</td><td>Built-in stereoâ†”mono</td><td>TBD</td></tr>
<tr><td>Error on close</td><td>CloseWithError</td><td>Drop trait</td></tr>
<tr><td>Format location</td><td>In resampler/</td><td>In resampler/, re-exported by pcm/</td></tr>
</tbody></table>
</div>
<h2 id="thread-safety-3"><a class="header" href="#thread-safety-3">Thread Safety</a></h2>
<ul>
<li><code>Soxr</code> is NOT thread-safe</li>
<li>Use separate instances for concurrent processing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-resampler---known-issues"><a class="header" href="#audio-resampler---known-issues">Audio Resampler - Known Issues</a></h1>
<h2 id="-minor-issues-7"><a class="header" href="#-minor-issues-7">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="rsm-001-quality-level-hardcoded"><a class="header" href="#rsm-001-quality-level-hardcoded">RSM-001: Quality level hardcoded</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/resampler/soxr.go:52</code></p>
<p><strong>Description:</strong><br />
Quality is hardcoded to <code>SOXR_HQ</code>:</p>
<pre><code class="language-go">qSpec := C.soxr_quality_spec(C.SOXR_HQ, 0)
</code></pre>
<p><strong>Impact:</strong> Cannot trade quality for performance when needed.</p>
<p><strong>Suggestion:</strong> Add quality parameter to <code>New()</code>.</p>
<hr />
<h3 id="rsm-002-go-read-not-concurrency-safe"><a class="header" href="#rsm-002-go-read-not-concurrency-safe">RSM-002: Go Read not concurrency-safe</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/resampler/soxr.go:90-150</code></p>
<p><strong>Description:</strong><br />
<code>Read</code> uses internal buffer and mutex, but documentation doesn't clearly state thread-safety limitations.</p>
<p><strong>Impact:</strong> Potential confusion about concurrent use.</p>
<p><strong>Suggestion:</strong> Add explicit thread-safety documentation.</p>
<hr />
<h3 id="rsm-003-rust-api-differs-significantly-from-go"><a class="header" href="#rsm-003-rust-api-differs-significantly-from-go">RSM-003: Rust API differs significantly from Go</a></h3>
<p><strong>Description:</strong></p>
<ul>
<li>Go: <code>io.Reader</code> wrapper with <code>Read()</code> method</li>
<li>Rust: Direct <code>process()</code> with byte slices</li>
</ul>
<p><strong>Impact:</strong> Code not easily portable between languages.</p>
<hr />
<h3 id="rsm-004-stereomono-conversion-before-soxr"><a class="header" href="#rsm-004-stereomono-conversion-before-soxr">RSM-004: Stereo/mono conversion before soxr</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/resampler/soxr.go:228-278</code></p>
<p><strong>Description:</strong><br />
Channel conversion is done separately from sample rate conversion:</p>
<pre><code class="language-go">if r.srcFmt.Stereo &amp;&amp; !r.dstFmt.Stereo {
    return stereoToMono(r.readBuf[:rn]), err
}
</code></pre>
<p><strong>Impact:</strong></p>
<ul>
<li>Two-pass processing for stereoâ†’mono + rate change</li>
<li>Not using libsoxr's built-in channel handling</li>
</ul>
<p><strong>Suggestion:</strong> Use soxr's multi-channel support directly.</p>
<hr />
<h3 id="rsm-005-go-stereotomono-loses-precision"><a class="header" href="#rsm-005-go-stereotomono-loses-precision">RSM-005: Go stereoToMono loses precision</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/resampler/soxr.go:252-264</code></p>
<p><strong>Description:</strong><br />
Averages L+R channels with integer division:</p>
<pre><code class="language-go">m := int16((int32(l) + int32(r)) / 2)
</code></pre>
<p><strong>Impact:</strong> Potential off-by-one errors, always rounds down.</p>
<p><strong>Suggestion:</strong> Use rounding division: <code>(l + r + 1) / 2</code>.</p>
<hr />
<h2 id="-enhancements-8"><a class="header" href="#-enhancements-8">ğŸ”µ Enhancements</a></h2>
<h3 id="rsm-006-no-asyncstreaming-api"><a class="header" href="#rsm-006-no-asyncstreaming-api">RSM-006: No async/streaming API</a></h3>
<p><strong>Description:</strong><br />
Both implementations are synchronous. No async/await support in Rust.</p>
<p><strong>Suggestion:</strong> Add async interface for non-blocking resampling.</p>
<hr />
<h3 id="rsm-007-no-passbandstopband-configuration"><a class="header" href="#rsm-007-no-passbandstopband-configuration">RSM-007: No passband/stopband configuration</a></h3>
<p><strong>Description:</strong><br />
Cannot configure filter characteristics:</p>
<ul>
<li>Passband ripple</li>
<li>Stopband attenuation</li>
<li>Transition bandwidth</li>
</ul>
<p><strong>Suggestion:</strong> Expose libsoxr quality parameters.</p>
<hr />
<h3 id="rsm-008-no-float32-pcm-support"><a class="header" href="#rsm-008-no-float32-pcm-support">RSM-008: No float32 PCM support</a></h3>
<p><strong>Description:</strong><br />
Only int16 PCM is supported. Many audio pipelines use float32 internally.</p>
<p><strong>Suggestion:</strong> Add float32 I/O format option.</p>
<hr />
<h3 id="rsm-009-no-resampling-ratio-limits"><a class="header" href="#rsm-009-no-resampling-ratio-limits">RSM-009: No resampling ratio limits</a></h3>
<p><strong>Description:</strong><br />
No validation of extreme resampling ratios (e.g., 8000â†’192000).</p>
<p><strong>Impact:</strong> Quality degradation or memory issues with extreme ratios.</p>
<p><strong>Suggestion:</strong> Add ratio validation or warnings.</p>
<hr />
<h2 id="-notes-8"><a class="header" href="#-notes-8">âšª Notes</a></h2>
<h3 id="rsm-010-libsoxr-memory-management"><a class="header" href="#rsm-010-libsoxr-memory-management">RSM-010: libsoxr memory management</a></h3>
<p><strong>Description:</strong><br />
libsoxr allocates internal buffers based on:</p>
<ul>
<li>Quality level</li>
<li>Input/output sample rates</li>
<li>Number of channels</li>
</ul>
<p>Memory is released only on <code>soxr_delete</code>. Go/Rust wrappers handle this in Close/Drop.</p>
<hr />
<h3 id="rsm-011-sample-alignment-handling"><a class="header" href="#rsm-011-sample-alignment-handling">RSM-011: Sample alignment handling</a></h3>
<p><strong>Description:</strong><br />
Both implementations ensure reads are sample-aligned:</p>
<ul>
<li>Go: <code>sampleReader</code> wrapper</li>
<li>Rust: <code>SampleReader</code> struct</li>
</ul>
<p>This handles partial reads from underlying sources.</p>
<hr />
<h3 id="rsm-012-format-definition-location"><a class="header" href="#rsm-012-format-definition-location">RSM-012: Format definition location</a></h3>
<p><strong>Description:</strong><br />
<code>Format</code> is defined in <code>resampler</code> module but re-exported by <code>pcm</code> module. This could be confusing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Both work:
use giztoy_audio::resampler::Format;
use giztoy_audio::pcm::Format;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>RSM-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>RSM-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>RSM-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>RSM-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>RSM-005</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>RSM-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>RSM-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>RSM-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>RSM-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>RSM-010</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>RSM-011</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>RSM-012</td><td>âšª Note</td><td>N/A</td><td>Rust</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Functional resampling with good quality defaults. Main issues are API differences and hardcoded quality settings.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-opusrt-module"><a class="header" href="#audio-opusrt-module">Audio OpusRT Module</a></h1>
<p>Real-time Opus stream processing with jitter buffering and packet loss handling.</p>
<h2 id="design-goals-9"><a class="header" href="#design-goals-9">Design Goals</a></h2>
<ol>
<li><strong>Out-of-Order Handling</strong>: Reorder packets that arrive out of sequence</li>
<li><strong>Packet Loss Detection</strong>: Detect and report gaps for PLC (Packet Loss Concealment)</li>
<li><strong>Real-time Simulation</strong>: Playback timing based on timestamps, not arrival time</li>
<li><strong>OGG Container Support</strong>: Read/write Opus in OGG format (Go only)</li>
</ol>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="jitter-buffer"><a class="header" href="#jitter-buffer">Jitter Buffer</a></h3>
<p>Network packets may arrive out of order or with variable delay (jitter).
The jitter buffer collects packets and outputs them in correct order:</p>
<pre><code>Network          Buffer              Output
   â”‚               â”‚                   â”‚
   â”‚â”€â”€[PKT 3]â”€â”€â–º  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
   â”‚              â”‚  â”‚ Heap     â”‚     â”‚
   â”‚â”€â”€[PKT 1]â”€â”€â–º  â”‚  â”‚ [1,3]    â”‚     â”‚
   â”‚              â”‚  â”‚          â”‚     â”‚â”€â”€[PKT 1]â”€â”€â–º
   â”‚â”€â”€[PKT 2]â”€â”€â–º  â”‚  â”‚ [2,3]    â”‚     â”‚
   â”‚              â”‚  â”‚          â”‚     â”‚â”€â”€[PKT 2]â”€â”€â–º
   â”‚              â”‚  â”‚ [3]      â”‚     â”‚â”€â”€[PKT 3]â”€â”€â–º
</code></pre>
<h3 id="packet-loss-detection"><a class="header" href="#packet-loss-detection">Packet Loss Detection</a></h3>
<p>Gaps between consecutive frame timestamps indicate lost packets:</p>
<pre><code>Frame 1: 0ms - 20ms
Frame 2: 20ms - 40ms    âœ“ No gap
Frame 4: 60ms - 80ms    âœ— 20ms gap (Frame 3 lost)
</code></pre>
<p>When loss is detected, the caller should use decoder PLC:</p>
<pre><code class="language-go">frame, loss, _ := buffer.Frame()
if loss &gt; 0 {
    // Generate PLC audio for 'loss' duration
    plcAudio := decoder.DecodePLC(...)
}
</code></pre>
<h3 id="timestamped-frames"><a class="header" href="#timestamped-frames">Timestamped Frames</a></h3>
<p>Frames are timestamped with epoch milliseconds:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        StampedFrame             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Timestamp (8 bytes, big-endian) â”‚
â”‚ Opus Frame (variable)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<h3 id="buffer-1"><a class="header" href="#buffer-1">Buffer</a></h3>
<p>Simple jitter buffer with min-heap ordering:</p>
<ul>
<li>Append frames in any order</li>
<li>Read frames in timestamp order</li>
<li>Max duration limit (oldest dropped)</li>
</ul>
<h3 id="realtimebuffer"><a class="header" href="#realtimebuffer">RealtimeBuffer</a></h3>
<p>Wraps Buffer for real-time playback simulation:</p>
<ul>
<li>Background goroutine pulls frames at correct time</li>
<li>Generates loss events when data not available</li>
<li>Handles clock synchronization</li>
</ul>
<h3 id="ogg-readerwriter-go-only"><a class="header" href="#ogg-readerwriter-go-only">OGG Reader/Writer (Go only)</a></h3>
<p>Read/write Opus streams in OGG container format:</p>
<ul>
<li><code>OggReader</code>: Read Opus frames from OGG file</li>
<li><code>OggWriter</code>: Write Opus frames to OGG container</li>
</ul>
<h2 id="timing"><a class="header" href="#timing">Timing</a></h2>
<h3 id="epochmillis"><a class="header" href="#epochmillis">EpochMillis</a></h3>
<p>All timestamps are milliseconds since Unix epoch:</p>
<pre><code class="language-go">type EpochMillis int64

// Convert from time.Time
stamp := EpochMillis(time.Now().UnixMilli())

// Convert to duration
duration := stamp.Duration() // time.Duration
</code></pre>
<h3 id="timestamp-epsilon"><a class="header" href="#timestamp-epsilon">Timestamp Epsilon</a></h3>
<p>A 2ms tolerance for timestamp comparisons accounts for clock drift:</p>
<pre><code class="language-go">const timestampEpsilon = 2 // milliseconds
</code></pre>
<h2 id="use-cases-4"><a class="header" href="#use-cases-4">Use Cases</a></h2>
<h3 id="webrtc-audio"><a class="header" href="#webrtc-audio">WebRTC Audio</a></h3>
<pre><code>WebRTC â†’ RTP Packets â†’ Jitter Buffer â†’ Opus Decode â†’ Playback
</code></pre>
<h3 id="speech-api-streaming"><a class="header" href="#speech-api-streaming">Speech API Streaming</a></h3>
<pre><code>API Response â†’ Stamped Frames â†’ RealtimeBuffer â†’ Decode â†’ Mixer
</code></pre>
<h3 id="audio-recording-1"><a class="header" href="#audio-recording-1">Audio Recording</a></h3>
<pre><code>Opus Frames â†’ OGG Writer â†’ File
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>See parent <code>audio/</code> documentation for usage examples.</p>
<h2 id="related-modules-3"><a class="header" href="#related-modules-3">Related Modules</a></h2>
<ul>
<li><code>audio/codec/opus/</code> - Opus encoder/decoder</li>
<li><code>audio/codec/ogg/</code> - OGG container primitives</li>
<li><code>buffer/</code> - Used internally by RealtimeBuffer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-opusrt---go-implementation"><a class="header" href="#audio-opusrt---go-implementation">Audio OpusRT - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/audio/opusrt</code></p>
<h2 id="types-18"><a class="header" href="#types-18">Types</a></h2>
<h3 id="epochmillis-1"><a class="header" href="#epochmillis-1">EpochMillis</a></h3>
<pre><code class="language-go">type EpochMillis int64
</code></pre>
<p><strong>Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Now</code></td><td><code>func Now() EpochMillis</code></td><td>Current time as epoch millis</td></tr>
<tr><td><code>FromDuration</code></td><td><code>func FromDuration(d time.Duration) EpochMillis</code></td><td>Duration to millis</td></tr>
</tbody></table>
</div>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Duration</code></td><td><code>(e EpochMillis) Duration() time.Duration</code></td><td>To time.Duration</td></tr>
<tr><td><code>Time</code></td><td><code>(e EpochMillis) Time() time.Time</code></td><td>To time.Time</td></tr>
</tbody></table>
</div>
<h3 id="frame"><a class="header" href="#frame">Frame</a></h3>
<pre><code class="language-go">type Frame []byte
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Duration</code></td><td><code>(f Frame) Duration() time.Duration</code></td><td>Frame duration from TOC</td></tr>
<tr><td><code>Clone</code></td><td><code>(f Frame) Clone() Frame</code></td><td>Deep copy</td></tr>
</tbody></table>
</div>
<h3 id="stampedframe"><a class="header" href="#stampedframe">StampedFrame</a></h3>
<pre><code class="language-go">// Binary format: 8-byte timestamp (big-endian) + Opus frame
func FromStamped(data []byte) (Frame, EpochMillis, bool)
func ToStamped(frame Frame, stamp EpochMillis) []byte
</code></pre>
<h3 id="buffer-2"><a class="header" href="#buffer-2">Buffer</a></h3>
<pre><code class="language-go">type Buffer struct {
    Duration EpochMillis  // Max buffer duration
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewBuffer</code></td><td><code>func NewBuffer(d time.Duration) *Buffer</code></td><td>Create buffer</td></tr>
<tr><td><code>Append</code></td><td><code>(buf *Buffer) Append(frame Frame, stamp EpochMillis) error</code></td><td>Add frame</td></tr>
<tr><td><code>Write</code></td><td><code>(buf *Buffer) Write(stamped []byte) (int, error)</code></td><td>io.Writer for stamped frames</td></tr>
<tr><td><code>Frame</code></td><td><code>(buf *Buffer) Frame() (Frame, time.Duration, error)</code></td><td>Get next frame</td></tr>
<tr><td><code>Len</code></td><td><code>(buf *Buffer) Len() int</code></td><td>Frame count</td></tr>
<tr><td><code>Buffered</code></td><td><code>(buf *Buffer) Buffered() time.Duration</code></td><td>Buffered duration</td></tr>
<tr><td><code>Reset</code></td><td><code>(buf *Buffer) Reset()</code></td><td>Clear buffer</td></tr>
</tbody></table>
</div>
<h3 id="realtimebuffer-1"><a class="header" href="#realtimebuffer-1">RealtimeBuffer</a></h3>
<pre><code class="language-go">type RealtimeBuffer struct {
    // ... internal fields
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RealtimeFrom</code></td><td><code>func RealtimeFrom(buf *Buffer) *RealtimeBuffer</code></td><td>Create from Buffer</td></tr>
<tr><td><code>Write</code></td><td><code>(rtb *RealtimeBuffer) Write(stamped []byte) (int, error)</code></td><td>io.Writer</td></tr>
<tr><td><code>Frame</code></td><td><code>(rtb *RealtimeBuffer) Frame() (Frame, time.Duration, error)</code></td><td>Get next frame/loss</td></tr>
<tr><td><code>CloseWrite</code></td><td><code>(rtb *RealtimeBuffer) CloseWrite() error</code></td><td>Signal end of input</td></tr>
<tr><td><code>Close</code></td><td><code>(rtb *RealtimeBuffer) Close() error</code></td><td>Close buffer</td></tr>
<tr><td><code>Reset</code></td><td><code>(rtb *RealtimeBuffer) Reset()</code></td><td>Clear buffer</td></tr>
</tbody></table>
</div>
<h3 id="oggwriter"><a class="header" href="#oggwriter">OggWriter</a></h3>
<pre><code class="language-go">type OggWriter struct {
    // ... internal fields
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewOggWriter</code></td><td><code>func NewOggWriter(w io.Writer, sampleRate int) (*OggWriter, error)</code></td><td>Create writer</td></tr>
<tr><td><code>Write</code></td><td><code>(ow *OggWriter) Write(frame Frame) error</code></td><td>Write frame</td></tr>
<tr><td><code>Close</code></td><td><code>(ow *OggWriter) Close() error</code></td><td>Finalize and close</td></tr>
</tbody></table>
</div>
<h3 id="oggreader"><a class="header" href="#oggreader">OggReader</a></h3>
<pre><code class="language-go">type OggReader struct {
    // ... internal fields
}
</code></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NewOggReader</code></td><td><code>func NewOggReader(r io.Reader) (*OggReader, error)</code></td><td>Create reader</td></tr>
<tr><td><code>Frame</code></td><td><code>(or *OggReader) Frame() (Frame, time.Duration, error)</code></td><td>Read next frame</td></tr>
</tbody></table>
</div>
<h2 id="usage-14"><a class="header" href="#usage-14">Usage</a></h2>
<h3 id="basic-jitter-buffer"><a class="header" href="#basic-jitter-buffer">Basic Jitter Buffer</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/audio/opusrt"

// Create buffer (2 minute capacity)
buf := opusrt.NewBuffer(2 * time.Minute)

// Write stamped frames (from network)
buf.Write(stampedData)

// Read in order
for {
    frame, loss, err := buf.Frame()
    if err == io.EOF {
        break
    }
    if loss &gt; 0 {
        // Handle packet loss with PLC
        pcm := decoder.DecodePLC(int(loss / 20 * time.Millisecond * 320))
        play(pcm)
    } else {
        pcm := decoder.Decode(frame)
        play(pcm)
    }
}
</code></pre>
<h3 id="realtime-playback"><a class="header" href="#realtime-playback">Realtime Playback</a></h3>
<pre><code class="language-go">// Create realtime buffer
buf := opusrt.NewBuffer(2 * time.Minute)
rtb := opusrt.RealtimeFrom(buf)

// Write frames (from another goroutine)
go func() {
    for data := range networkData {
        rtb.Write(data)
    }
    rtb.CloseWrite()
}()

// Read at real-time pace
for {
    frame, loss, err := rtb.Frame()
    if err == io.EOF {
        break
    }
    // Frames arrive at correct timing
}
</code></pre>
<h3 id="ogg-file-writing"><a class="header" href="#ogg-file-writing">OGG File Writing</a></h3>
<pre><code class="language-go">file, _ := os.Create("output.ogg")
writer, _ := opusrt.NewOggWriter(file, 16000)
defer writer.Close()

for _, frame := range opusFrames {
    writer.Write(frame)
}
</code></pre>
<h3 id="ogg-file-reading"><a class="header" href="#ogg-file-reading">OGG File Reading</a></h3>
<pre><code class="language-go">file, _ := os.Open("input.ogg")
reader, _ := opusrt.NewOggReader(file)

for {
    frame, _, err := reader.Frame()
    if err == io.EOF {
        break
    }
    // Process frame
}
</code></pre>
<h2 id="error-types-1"><a class="header" href="#error-types-1">Error Types</a></h2>
<pre><code class="language-go">var ErrDisorderedPacket = errors.New("opusrt: disordered packet")
var ErrInvalidFrame = errors.New("opusrt: invalid frame")
var ErrDone = errors.New("opusrt: done")
</code></pre>
<h2 id="thread-safety-4"><a class="header" href="#thread-safety-4">Thread Safety</a></h2>
<ul>
<li><code>Buffer</code>: Safe for concurrent Append/Frame calls</li>
<li><code>RealtimeBuffer</code>: Safe for concurrent Write/Frame calls</li>
<li><code>OggWriter/OggReader</code>: NOT thread-safe</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-opusrt---rust-implementation"><a class="header" href="#audio-opusrt---rust-implementation">Audio OpusRT - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-audio</code> (module <code>opusrt</code>)</p>
<h2 id="types-19"><a class="header" href="#types-19">Types</a></h2>
<h3 id="epochmillis-2"><a class="header" href="#epochmillis-2">EpochMillis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type EpochMillis = i64;
<span class="boring">}</span></code></pre></pre>
<p><strong>Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>now</code></td><td><code>fn now() -&gt; EpochMillis</code></td><td>Current time as epoch millis</td></tr>
<tr><td><code>from_duration</code></td><td><code>fn from_duration(d: Duration) -&gt; EpochMillis</code></td><td>Duration to millis</td></tr>
<tr><td><code>to_duration</code></td><td><code>fn to_duration(e: EpochMillis) -&gt; Duration</code></td><td>Millis to Duration</td></tr>
</tbody></table>
</div>
<h3 id="frame-1"><a class="header" href="#frame-1">Frame</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Frame = Vec&lt;u8&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Extension Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>frame_duration</code></td><td><code>fn frame_duration(frame: &amp;Frame) -&gt; Duration</code></td><td>Frame duration from TOC</td></tr>
</tbody></table>
</div>
<h3 id="stampedframe-1"><a class="header" href="#stampedframe-1">StampedFrame</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StampedFrame {
    pub frame: Frame,
    pub timestamp: EpochMillis,
}

impl StampedFrame {
    pub fn from_bytes(data: &amp;[u8]) -&gt; Option&lt;Self&gt;;
    pub fn to_bytes(&amp;self) -&gt; Vec&lt;u8&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="buffer-3"><a class="header" href="#buffer-3">Buffer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Buffer {
    duration: EpochMillis,
    // ... internal fields
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new</code></td><td><code>fn new(duration: Duration) -&gt; Self</code></td><td>Create buffer</td></tr>
<tr><td><code>append</code></td><td><code>fn append(&amp;mut self, frame: Frame, stamp: EpochMillis) -&gt; Result&lt;()&gt;</code></td><td>Add frame</td></tr>
<tr><td><code>frame</code></td><td><code>fn frame(&amp;mut self) -&gt; Result&lt;(Option&lt;Frame&gt;, Duration)&gt;</code></td><td>Get next frame</td></tr>
<tr><td><code>len</code></td><td><code>fn len(&amp;self) -&gt; usize</code></td><td>Frame count</td></tr>
<tr><td><code>buffered</code></td><td><code>fn buffered(&amp;self) -&gt; Duration</code></td><td>Buffered duration</td></tr>
<tr><td><code>reset</code></td><td><code>fn reset(&amp;mut self)</code></td><td>Clear buffer</td></tr>
</tbody></table>
</div>
<h2 id="usage-15"><a class="header" href="#usage-15">Usage</a></h2>
<h3 id="basic-jitter-buffer-1"><a class="header" href="#basic-jitter-buffer-1">Basic Jitter Buffer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::opusrt::{Buffer, Frame, EpochMillis};
use std::time::Duration;

// Create buffer (2 minute capacity)
let mut buffer = Buffer::new(Duration::from_secs(120));

// Append frames
buffer.append(frame1, timestamp1)?;
buffer.append(frame2, timestamp2)?;

// Read in order
loop {
    match buffer.frame() {
        Ok((Some(frame), Duration::ZERO)) =&gt; {
            // Got a valid frame
            let pcm = decoder.decode(&amp;frame)?;
            play(&amp;pcm);
        }
        Ok((None, loss)) if loss &gt; Duration::ZERO =&gt; {
            // Packet loss detected
            let plc_pcm = decoder.decode_plc(loss_to_samples(loss))?;
            play(&amp;plc_pcm);
        }
        Err(_) =&gt; break, // Buffer empty
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stamped-frame-handling"><a class="header" href="#stamped-frame-handling">Stamped Frame Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_audio::opusrt::StampedFrame;

// Parse stamped frame
let stamped = StampedFrame::from_bytes(&amp;network_data)?;
buffer.append(stamped.frame, stamped.timestamp)?;

// Create stamped frame
let stamped = StampedFrame {
    frame: opus_frame,
    timestamp: now(),
};
let bytes = stamped.to_bytes();
<span class="boring">}</span></code></pre></pre>
<h2 id="missing-features-vs-go"><a class="header" href="#missing-features-vs-go">Missing Features vs Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>Notes</th></tr></thead><tbody>
<tr><td>Buffer</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>Basic jitter buffer</td></tr>
<tr><td>RealtimeBuffer</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Real-time playback simulation</td></tr>
<tr><td>OggWriter</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Write Opus to OGG</td></tr>
<tr><td>OggReader</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Read Opus from OGG</td></tr>
<tr><td>RealtimeReader</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Generic frame reader with pacing</td></tr>
</tbody></table>
</div>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p>The Rust implementation provides:</p>
<ul>
<li>Basic jitter buffer with heap-based ordering</li>
<li>Stamped frame parsing</li>
<li>Timestamp utilities</li>
</ul>
<p><strong>Missing:</strong></p>
<ul>
<li>RealtimeBuffer (background thread with real-time pacing)</li>
<li>OGG container integration</li>
<li>RealtimeReader wrapper</li>
</ul>
<h2 id="differences-from-go-8"><a class="header" href="#differences-from-go-8">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>EpochMillis</td><td>Custom type with methods</td><td>Type alias <code>i64</code></td></tr>
<tr><td>Frame</td><td><code>[]byte</code> with methods</td><td><code>Vec&lt;u8&gt;</code> (no methods)</td></tr>
<tr><td>Error handling</td><td>Multiple error vars</td><td>Result with error types</td></tr>
<tr><td>Thread safety</td><td>Mutex-protected</td><td>TBD</td></tr>
<tr><td>OGG support</td><td>âœ… Full</td><td>âŒ Missing</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="audio-opusrt---known-issues"><a class="header" href="#audio-opusrt---known-issues">Audio OpusRT - Known Issues</a></h1>
<h2 id="-major-issues-2"><a class="header" href="#-major-issues-2">ğŸŸ  Major Issues</a></h2>
<h3 id="ort-001-rust-missing-realtimebuffer"><a class="header" href="#ort-001-rust-missing-realtimebuffer">ORT-001: Rust missing RealtimeBuffer</a></h3>
<p><strong>Description:</strong><br />
Go has <code>RealtimeBuffer</code> for real-time playback simulation. Rust implementation is missing this.</p>
<p><strong>Impact:</strong> Cannot simulate real-time audio playback in Rust without manual timing logic.</p>
<p><strong>Status:</strong> âŒ Not implemented.</p>
<hr />
<h3 id="ort-002-rust-missing-ogg-readerwriter"><a class="header" href="#ort-002-rust-missing-ogg-readerwriter">ORT-002: Rust missing OGG Reader/Writer</a></h3>
<p><strong>Description:</strong><br />
Go has <code>OggReader</code> and <code>OggWriter</code> for reading/writing Opus in OGG containers. Rust is missing these.</p>
<p><strong>Impact:</strong> Cannot read/write Opus files in standard OGG format in Rust.</p>
<p><strong>Status:</strong> âŒ Not implemented.</p>
<hr />
<h2 id="-minor-issues-8"><a class="header" href="#-minor-issues-8">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="ort-003-buffer-drops-old-frames-silently"><a class="header" href="#ort-003-buffer-drops-old-frames-silently">ORT-003: Buffer drops old frames silently</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/opusrt/buffer.go:136-141</code></p>
<p><strong>Description:</strong><br />
When buffer exceeds max duration, oldest frames are dropped with only debug logging:</p>
<pre><code class="language-go">for buf.buffered &gt; buf.duration() {
    slog.Debug("opusrt: remove frame", ...)
    buf.pop()
}
</code></pre>
<p><strong>Impact:</strong> Caller may not know data was lost.</p>
<p><strong>Suggestion:</strong> Return dropped count or emit metric.</p>
<hr />
<h3 id="ort-004-realtimebuffer-spawns-goroutine-unconditionally"><a class="header" href="#ort-004-realtimebuffer-spawns-goroutine-unconditionally">ORT-004: RealtimeBuffer spawns goroutine unconditionally</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/opusrt/realtime.go:43</code></p>
<p><strong>Description:</strong><br />
<code>RealtimeFrom</code> always starts a background goroutine:</p>
<pre><code class="language-go">func RealtimeFrom(buf *Buffer) *RealtimeBuffer {
    // ...
    go rtb.pull()
    return rtb
}
</code></pre>
<p><strong>Impact:</strong></p>
<ul>
<li>Goroutine leak if RealtimeBuffer not properly closed</li>
<li>Cannot use lazy initialization</li>
</ul>
<hr />
<h3 id="ort-005-timestamp-epsilon-is-magic-number"><a class="header" href="#ort-005-timestamp-epsilon-is-magic-number">ORT-005: Timestamp epsilon is magic number</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/opusrt/realtime.go:19</code></p>
<p><strong>Description:</strong><br />
The 2ms epsilon is hardcoded without clear documentation:</p>
<pre><code class="language-go">const timestampEpsilon = 2
</code></pre>
<p><strong>Impact:</strong> May not be appropriate for all use cases.</p>
<p><strong>Suggestion:</strong> Make configurable or document reasoning better.</p>
<hr />
<h3 id="ort-006-bufferwrite-ignores-append-error"><a class="header" href="#ort-006-bufferwrite-ignores-append-error">ORT-006: Buffer.Write ignores Append error</a></h3>
<p><strong>File:</strong> <code>go/pkg/audio/opusrt/buffer.go:156</code></p>
<p><strong>Description:</strong><br />
The Write method ignores the error from Append:</p>
<pre><code class="language-go">func (buf *Buffer) Write(stamped []byte) (int, error) {
    // ...
    buf.Append(frame.Clone(), ts)  // Error ignored!
    return len(stamped), nil
}
</code></pre>
<p><strong>Impact:</strong> ErrDisorderedPacket is silently ignored.</p>
<hr />
<h3 id="ort-007-oggwriter-requires-manual-close"><a class="header" href="#ort-007-oggwriter-requires-manual-close">ORT-007: OggWriter requires manual Close</a></h3>
<p><strong>Description:</strong><br />
OggWriter must be closed to write the final OGG page. Not closing results in corrupted file.</p>
<p><strong>Impact:</strong> Easy to forget, no defer pattern works well.</p>
<p><strong>Suggestion:</strong> Document prominently or add finalizer.</p>
<hr />
<h2 id="-enhancements-9"><a class="header" href="#-enhancements-9">ğŸ”µ Enhancements</a></h2>
<h3 id="ort-008-no-fec-forward-error-correction-support"><a class="header" href="#ort-008-no-fec-forward-error-correction-support">ORT-008: No FEC (Forward Error Correction) support</a></h3>
<p><strong>Description:</strong><br />
Opus FEC can recover some lost data without PLC. Current implementation doesn't use this.</p>
<p><strong>Suggestion:</strong> Add FEC extraction from subsequent frames.</p>
<hr />
<h3 id="ort-009-no-statisticsmetrics"><a class="header" href="#ort-009-no-statisticsmetrics">ORT-009: No statistics/metrics</a></h3>
<p><strong>Description:</strong><br />
No way to get buffer statistics:</p>
<ul>
<li>Packets received</li>
<li>Packets lost</li>
<li>Jitter measurements</li>
<li>Buffer fullness</li>
</ul>
<p><strong>Suggestion:</strong> Add Stats() method.</p>
<hr />
<h3 id="ort-010-no-adaptive-buffer-sizing"><a class="header" href="#ort-010-no-adaptive-buffer-sizing">ORT-010: No adaptive buffer sizing</a></h3>
<p><strong>Description:</strong><br />
Buffer duration is fixed at creation. Real-world systems often adapt buffer size based on jitter.</p>
<p><strong>Suggestion:</strong> Add adaptive buffering option.</p>
<hr />
<h3 id="ort-011-no-rtcp-support"><a class="header" href="#ort-011-no-rtcp-support">ORT-011: No RTCP support</a></h3>
<p><strong>Description:</strong><br />
No support for RTCP (Real-time Transport Control Protocol) which provides feedback for real-time streams.</p>
<p><strong>Suggestion:</strong> Consider RTCP integration for WebRTC use cases.</p>
<hr />
<h2 id="-notes-9"><a class="header" href="#-notes-9">âšª Notes</a></h2>
<h3 id="ort-012-heap-based-ordering"><a class="header" href="#ort-012-heap-based-ordering">ORT-012: Heap-based ordering</a></h3>
<p><strong>Description:</strong><br />
Buffer uses Go's container/heap for timestamp ordering:</p>
<ul>
<li>O(log n) insert</li>
<li>O(log n) pop</li>
<li>Memory for heap structure</li>
</ul>
<p>This is appropriate for jitter buffer sizes (typically &lt; 1000 frames).</p>
<hr />
<h3 id="ort-013-stampedframe-format"><a class="header" href="#ort-013-stampedframe-format">ORT-013: StampedFrame format</a></h3>
<p><strong>Description:</strong><br />
Binary format:</p>
<pre><code>[0:8]  - Timestamp (int64, big-endian)
[8:]   - Opus frame data
</code></pre>
<p>This is a custom format, not a standard protocol.</p>
<hr />
<h3 id="ort-014-loss-threshold-in-realtimebuffer"><a class="header" href="#ort-014-loss-threshold-in-realtimebuffer">ORT-014: Loss threshold in RealtimeBuffer</a></h3>
<p><strong>Description:</strong><br />
RealtimeBuffer has complex loss handling with thresholds:</p>
<pre><code class="language-go">const (
    pullInterval  = 20
    lossStep      = pullInterval * time.Millisecond
    lossThreshold = 10 * lossStep  // 200ms
)
</code></pre>
<p>Designed to avoid spurious loss reports during initial buffering.</p>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>ORT-001</td><td>ğŸŸ  Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>ORT-002</td><td>ğŸŸ  Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>ORT-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Buffer</td></tr>
<tr><td>ORT-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Realtime</td></tr>
<tr><td>ORT-005</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>ORT-006</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Buffer</td></tr>
<tr><td>ORT-007</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go OGG</td></tr>
<tr><td>ORT-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>ORT-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>ORT-010</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>ORT-011</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>ORT-012</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>ORT-013</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>ORT-014</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Go implementation is comprehensive. Rust implementation is significantly incomplete, missing RealtimeBuffer and OGG support which are critical for real-world use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimax-sdk"><a class="header" href="#minimax-sdk">MiniMax SDK</a></h1>
<p>Go and Rust SDK for the MiniMax AI platform API.</p>
<blockquote>
<p><strong>Official API Documentation</strong>: <a href="lib/minimax/./api/README.html">api/README.md</a></p>
</blockquote>
<h2 id="design-goals-10"><a class="header" href="#design-goals-10">Design Goals</a></h2>
<ol>
<li><strong>Full API Coverage</strong>: Support all MiniMax API capabilities</li>
<li><strong>Idiomatic Language Design</strong>: Natural Go/Rust patterns</li>
<li><strong>Streaming Support</strong>: First-class support for streaming responses</li>
<li><strong>Async Task Handling</strong>: Convenient polling for long-running operations</li>
</ol>
<h2 id="api-coverage"><a class="header" href="#api-coverage">API Coverage</a></h2>
<div class="table-wrapper"><table><thead><tr><th>API Feature</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>Official Doc</th></tr></thead><tbody>
<tr><td>Text Generation (Chat)</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/text.html">api/text.md</a></td></tr>
<tr><td>Sync Speech (T2A)</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/speech-t2a.html">api/speech-t2a.md</a></td></tr>
<tr><td>Async Speech (Long Text)</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/speech-t2a-async.html">api/speech-t2a-async.md</a></td></tr>
<tr><td>Voice Cloning</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/voice-cloning.html">api/voice-cloning.md</a></td></tr>
<tr><td>Voice Design</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/voice-design.html">api/voice-design.md</a></td></tr>
<tr><td>Voice Management</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/voice-management.html">api/voice-management.md</a></td></tr>
<tr><td>Video Generation</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/video.html">api/video.md</a></td></tr>
<tr><td>Video Agent</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/video-agent.html">api/video-agent.md</a></td></tr>
<tr><td>Image Generation</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/image.html">api/image.md</a></td></tr>
<tr><td>Music Generation</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/music.html">api/music.md</a></td></tr>
<tr><td>File Management</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/minimax/./api/file.html">api/file.md</a></td></tr>
</tbody></table>
</div>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Client                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚ â”‚   Text   â”‚ â”‚  Speech  â”‚ â”‚  Voice   â”‚ â”‚  Video   â”‚     â”‚
â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚     â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚ â”‚  Image   â”‚ â”‚  Music   â”‚ â”‚   File   â”‚                  â”‚
â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚                  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    HTTP Client                           â”‚
â”‚            (retry, auth, error handling)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
              https://api.minimaxi.com
</code></pre>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Service</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Text</code></td><td>Chat completion, streaming, tool calls</td></tr>
<tr><td><code>Speech</code></td><td>TTS sync/stream, async long-text</td></tr>
<tr><td><code>Voice</code></td><td>List voices, clone, design</td></tr>
<tr><td><code>Video</code></td><td>Text-to-video, image-to-video, agent</td></tr>
<tr><td><code>Image</code></td><td>Text-to-image, image reference</td></tr>
<tr><td><code>Music</code></td><td>Music generation from lyrics</td></tr>
<tr><td><code>File</code></td><td>Upload, list, retrieve, delete files</td></tr>
</tbody></table>
</div>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Uses Bearer token authentication:</p>
<pre><code>Authorization: Bearer &lt;api_key&gt;
</code></pre>
<p>API keys are obtained from <a href="https://platform.minimaxi.com">MiniMax Platform</a>.</p>
<h2 id="base-urls"><a class="header" href="#base-urls">Base URLs</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Region</th><th>URL</th></tr></thead><tbody>
<tr><td>China (Default)</td><td><code>https://api.minimaxi.com</code></td></tr>
<tr><td>Global</td><td><code>https://api.minimaxi.chat</code></td></tr>
</tbody></table>
</div>
<h2 id="response-patterns"><a class="header" href="#response-patterns">Response Patterns</a></h2>
<h3 id="synchronous"><a class="header" href="#synchronous">Synchronous</a></h3>
<p>Direct response with data.</p>
<h3 id="streaming"><a class="header" href="#streaming">Streaming</a></h3>
<p>SSE (Server-Sent Events) for real-time data:</p>
<ul>
<li>Text: Token-by-token chat responses</li>
<li>Speech: Audio chunk streaming</li>
</ul>
<h3 id="async-tasks"><a class="header" href="#async-tasks">Async Tasks</a></h3>
<p>For long-running operations (video, async speech):</p>
<ol>
<li>Create task â†’ get <code>task_id</code></li>
<li>Poll status â†’ <code>Pending</code>/<code>Running</code>/<code>Success</code>/<code>Failed</code></li>
<li>Retrieve result on success</li>
</ol>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>All errors include:</p>
<ul>
<li><code>status_code</code>: Numeric error code</li>
<li><code>status_msg</code>: Human-readable message</li>
</ul>
<p>Common error codes:</p>
<ul>
<li><code>1000</code>: General error</li>
<li><code>1001</code>: Rate limit exceeded</li>
<li><code>1002</code>: Invalid parameters</li>
<li><code>1004</code>: Authentication failed</li>
</ul>
<h2 id="examples-directory-6"><a class="header" href="#examples-directory-6">Examples Directory</a></h2>
<ul>
<li><code>examples/go/minimax/</code> - Go SDK examples</li>
<li><code>examples/rust/minimax/</code> - Rust SDK examples</li>
<li><code>examples/cmd/minimax/</code> - CLI test scripts</li>
</ul>
<h2 id="related"><a class="header" href="#related">Related</a></h2>
<ul>
<li>CLI tool: <code>go/cmd/minimax/</code></li>
<li>CLI tests: <code>examples/cmd/minimax/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimax-sdk---go-implementation"><a class="header" href="#minimax-sdk---go-implementation">MiniMax SDK - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/minimax</code></p>
<h2 id="client"><a class="header" href="#client">Client</a></h2>
<pre><code class="language-go">type Client struct {
    Text   *TextService
    Speech *SpeechService
    Voice  *VoiceService
    Video  *VideoService
    Image  *ImageService
    Music  *MusicService
    File   *FileService
}
</code></pre>
<p><strong>Constructor:</strong></p>
<pre><code class="language-go">// Basic
client := minimax.NewClient("api-key")

// With options
client := minimax.NewClient("api-key",
    minimax.WithBaseURL(minimax.BaseURLGlobal),
    minimax.WithRetry(5),
    minimax.WithHTTPClient(&amp;http.Client{Timeout: 60*time.Second}),
)
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>WithBaseURL(url)</code></td><td>Custom API base URL</td></tr>
<tr><td><code>WithRetry(n)</code></td><td>Max retry count (default: 3)</td></tr>
<tr><td><code>WithHTTPClient(c)</code></td><td>Custom http.Client</td></tr>
</tbody></table>
</div>
<h2 id="services-1"><a class="header" href="#services-1">Services</a></h2>
<h3 id="textservice"><a class="header" href="#textservice">TextService</a></h3>
<pre><code class="language-go">// Synchronous
resp, err := client.Text.CreateChatCompletion(ctx, &amp;minimax.ChatCompletionRequest{
    Model: "MiniMax-M2.1",
    Messages: []minimax.Message{
        {Role: "user", Content: "Hello!"},
    },
})

// Streaming (Go 1.23+ iter.Seq2)
for chunk, err := range client.Text.CreateChatCompletionStream(ctx, req) {
    if err != nil {
        return err
    }
    fmt.Print(chunk.Choices[0].Delta.Content)
}
</code></pre>
<h3 id="speechservice"><a class="header" href="#speechservice">SpeechService</a></h3>
<pre><code class="language-go">// Synchronous
resp, err := client.Speech.Synthesize(ctx, &amp;minimax.SpeechRequest{
    Model: "speech-2.6-hd",
    Text:  "Hello, world!",
    VoiceSetting: &amp;minimax.VoiceSetting{
        VoiceID: "male-qn-qingse",
    },
})
// resp.Audio contains decoded audio bytes

// Streaming
for chunk, err := range client.Speech.SynthesizeStream(ctx, req) {
    if err != nil {
        return err
    }
    buf.Write(chunk.Audio)
}

// Async (long text)
task, err := client.Speech.CreateAsyncTask(ctx, &amp;minimax.AsyncSpeechRequest{
    Model: "speech-2.6-hd",
    Text:  longText,
    // ...
})
result, err := task.Wait(ctx)
</code></pre>
<h3 id="voiceservice"><a class="header" href="#voiceservice">VoiceService</a></h3>
<pre><code class="language-go">// List voices
voices, err := client.Voice.List(ctx)

// Clone voice
resp, err := client.Voice.Clone(ctx, &amp;minimax.VoiceCloneRequest{
    FileID:  "uploaded-file-id",
    VoiceID: "my-cloned-voice",
})

// Design voice
resp, err := client.Voice.Design(ctx, &amp;minimax.VoiceDesignRequest{
    Prompt:      "A warm female voice...",
    PreviewText: "Hello, how can I help?",
})
</code></pre>
<h3 id="videoservice"><a class="header" href="#videoservice">VideoService</a></h3>
<pre><code class="language-go">// Text to video
task, err := client.Video.CreateTextToVideo(ctx, &amp;minimax.TextToVideoRequest{
    Model:  "video-01",
    Prompt: "A cat playing piano",
})
result, err := task.Wait(ctx)
// result.FileID contains the video file ID

// Image to video
task, err := client.Video.CreateImageToVideo(ctx, &amp;minimax.ImageToVideoRequest{
    Model:          "video-01",
    FirstFrameImage: "https://...",
})
</code></pre>
<h3 id="imageservice"><a class="header" href="#imageservice">ImageService</a></h3>
<pre><code class="language-go">resp, err := client.Image.Generate(ctx, &amp;minimax.ImageGenerateRequest{
    Model:  "image-01",
    Prompt: "A beautiful sunset",
})
// resp.Data[0].URL or resp.Data[0].B64JSON
</code></pre>
<h3 id="musicservice"><a class="header" href="#musicservice">MusicService</a></h3>
<pre><code class="language-go">task, err := client.Music.Generate(ctx, &amp;minimax.MusicRequest{
    Prompt: "upbeat pop song",
    Lyrics: "[Verse]\nHello world...",
})
result, err := task.Wait(ctx)
</code></pre>
<h3 id="fileservice"><a class="header" href="#fileservice">FileService</a></h3>
<pre><code class="language-go">// Upload
resp, err := client.File.Upload(ctx, filePath, minimax.FilePurposeVoiceClone)

// List
files, err := client.File.List(ctx, &amp;minimax.FileListRequest{
    Purpose: minimax.FilePurposeVoiceClone,
})

// Download
data, err := client.File.Download(ctx, fileID)

// Delete
err := client.File.Delete(ctx, fileID)
</code></pre>
<h2 id="task-polling"><a class="header" href="#task-polling">Task Polling</a></h2>
<pre><code class="language-go">task, err := client.Video.CreateTextToVideo(ctx, req)
if err != nil {
    return err
}

// Default 5s interval
result, err := task.Wait(ctx)

// Custom interval
result, err := task.WaitWithInterval(ctx, 10*time.Second)

// Manual polling
status, err := task.Query(ctx)
if status.Status == minimax.TaskStatusSuccess {
    // ...
}
</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre><code class="language-go">resp, err := client.Text.CreateChatCompletion(ctx, req)
if err != nil {
    if e, ok := minimax.AsError(err); ok {
        fmt.Printf("API Error: %d - %s\n", e.StatusCode, e.StatusMsg)
        if e.IsRateLimit() {
            // Wait and retry
        }
    }
    return err
}
</code></pre>
<h2 id="streaming-internals"><a class="header" href="#streaming-internals">Streaming Internals</a></h2>
<p>Uses SSE (Server-Sent Events):</p>
<ul>
<li><code>iter.Seq2[T, error]</code> for Go 1.23+ range loops</li>
<li>Auto-reconnect on transient errors (based on retry config)</li>
<li>Hex audio decoding for speech streams</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimax-sdk---rust-implementation"><a class="header" href="#minimax-sdk---rust-implementation">MiniMax SDK - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-minimax</code></p>
<h2 id="client-1"><a class="header" href="#client-1">Client</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Client {
    http: Arc&lt;HttpClient&gt;,
    config: ClientConfig,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Constructor:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_minimax::{Client, BASE_URL_GLOBAL};

// Basic
let client = Client::new("api-key")?;

// With builder
let client = Client::builder("api-key")
    .base_url(BASE_URL_GLOBAL)
    .max_retries(5)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Builder Methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>base_url(url)</code></td><td>Custom API base URL</td></tr>
<tr><td><code>max_retries(n)</code></td><td>Max retry count (default: 3)</td></tr>
</tbody></table>
</div>
<h2 id="services-2"><a class="header" href="#services-2">Services</a></h2>
<p>Services are accessed via getter methods (returns new instance each call):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>client.text()    // TextService
client.speech()  // SpeechService
client.voice()   // VoiceService
client.video()   // VideoService
client.image()   // ImageService
client.music()   // MusicService
client.file()    // FileService
<span class="boring">}</span></code></pre></pre>
<h3 id="textservice-1"><a class="header" href="#textservice-1">TextService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_minimax::{ChatCompletionRequest, Message};

// Synchronous
let resp = client.text().create_chat_completion(&amp;ChatCompletionRequest {
    model: "MiniMax-M2.1".to_string(),
    messages: vec![
        Message { role: "user".to_string(), content: "Hello!".to_string() },
    ],
    ..Default::default()
}).await?;

// Streaming
let stream = client.text().create_chat_completion_stream(&amp;req).await?;
while let Some(chunk) = stream.next().await {
    let chunk = chunk?;
    if let Some(choice) = chunk.choices.first() {
        print!("{}", choice.delta.content);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="speechservice-1"><a class="header" href="#speechservice-1">SpeechService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_minimax::{SpeechRequest, VoiceSetting};

// Synchronous
let resp = client.speech().synthesize(&amp;SpeechRequest {
    model: "speech-2.6-hd".to_string(),
    text: "Hello, world!".to_string(),
    voice_setting: Some(VoiceSetting {
        voice_id: "male-qn-qingse".to_string(),
        ..Default::default()
    }),
    ..Default::default()
}).await?;
// resp.audio contains decoded bytes

// Streaming
let stream = client.speech().synthesize_stream(&amp;req).await?;
while let Some(chunk) = stream.next().await {
    let chunk = chunk?;
    if let Some(audio) = chunk.audio {
        buf.extend(&amp;audio);
    }
}

// Async (long text)
let task = client.speech().create_async_task(&amp;AsyncSpeechRequest {
    // ...
}).await?;
let result = task.wait().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="voiceservice-1"><a class="header" href="#voiceservice-1">VoiceService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List voices
let voices = client.voice().list().await?;

// Clone voice
let resp = client.voice().clone(&amp;VoiceCloneRequest {
    file_id: "uploaded-file-id".to_string(),
    voice_id: "my-cloned-voice".to_string(),
}).await?;

// Design voice
let resp = client.voice().design(&amp;VoiceDesignRequest {
    prompt: "A warm female voice...".to_string(),
    preview_text: "Hello, how can I help?".to_string(),
    ..Default::default()
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="videoservice-1"><a class="header" href="#videoservice-1">VideoService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Text to video
let task = client.video().create_text_to_video(&amp;TextToVideoRequest {
    model: "video-01".to_string(),
    prompt: "A cat playing piano".to_string(),
    ..Default::default()
}).await?;
let result = task.wait().await?;

// Image to video
let task = client.video().create_image_to_video(&amp;ImageToVideoRequest {
    model: "video-01".to_string(),
    first_frame_image: "https://...".to_string(),
    ..Default::default()
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="imageservice-1"><a class="header" href="#imageservice-1">ImageService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = client.image().generate(&amp;ImageGenerateRequest {
    model: "image-01".to_string(),
    prompt: "A beautiful sunset".to_string(),
    ..Default::default()
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="musicservice-1"><a class="header" href="#musicservice-1">MusicService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let task = client.music().generate(&amp;MusicRequest {
    prompt: "upbeat pop song".to_string(),
    lyrics: "[Verse]\nHello world...".to_string(),
    ..Default::default()
}).await?;
let result = task.wait().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="fileservice-1"><a class="header" href="#fileservice-1">FileService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Upload
let resp = client.file().upload(file_path, FilePurpose::VoiceClone).await?;

// List
let files = client.file().list(Some(FilePurpose::VoiceClone)).await?;

// Download
let data = client.file().download(&amp;file_id).await?;

// Delete
client.file().delete(&amp;file_id).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="task-polling-1"><a class="header" href="#task-polling-1">Task Polling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let task = client.video().create_text_to_video(&amp;req).await?;

// Default interval
let result = task.wait().await?;

// Custom interval
let result = task.wait_with_interval(Duration::from_secs(10)).await?;

// Manual polling
let status = task.query().await?;
if status.status == TaskStatus::Success {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_minimax::{Error, Result};

match client.text().create_chat_completion(&amp;req).await {
    Ok(resp) =&gt; { /* ... */ }
    Err(Error::Api { status_code, status_msg }) =&gt; {
        eprintln!("API Error: {} - {}", status_code, status_msg);
    }
    Err(Error::Http(e)) =&gt; {
        eprintln!("HTTP Error: {}", e);
    }
    Err(e) =&gt; {
        eprintln!("Error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hasmodel-trait"><a class="header" href="#hasmodel-trait">HasModel Trait</a></h2>
<p>For default model handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HasModel {
    fn model(&amp;self) -&gt; &amp;str;
    fn set_model(&amp;mut self, model: impl Into&lt;String&gt;);
    fn default_model() -&gt; &amp;'static str;
    fn apply_default_model(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-9"><a class="header" href="#differences-from-go-9">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Client construction</td><td><code>NewClient()</code> (panic on empty key)</td><td><code>Client::new()</code> (returns Result)</td></tr>
<tr><td>Service access</td><td>Direct fields (<code>client.Text</code>)</td><td>Getter methods (<code>client.text()</code>)</td></tr>
<tr><td>Streaming</td><td><code>iter.Seq2[T, error]</code></td><td><code>Stream&lt;Item=Result&lt;T&gt;&gt;</code></td></tr>
<tr><td>Options</td><td>Functional options</td><td>Builder pattern</td></tr>
<tr><td>Error type</td><td><code>*Error</code> with helper methods</td><td><code>Error</code> enum</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="minimax-sdk---known-issues"><a class="header" href="#minimax-sdk---known-issues">MiniMax SDK - Known Issues</a></h1>
<h2 id="-minor-issues-9"><a class="header" href="#-minor-issues-9">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="mmx-001-go-newclient-panics-on-empty-api-key"><a class="header" href="#mmx-001-go-newclient-panics-on-empty-api-key">MMX-001: Go NewClient panics on empty API key</a></h3>
<p><strong>File:</strong> <code>go/pkg/minimax/client.go:100-102</code></p>
<p><strong>Description:</strong><br />
NewClient panics instead of returning an error:</p>
<pre><code class="language-go">func NewClient(apiKey string, opts ...Option) *Client {
    if apiKey == "" {
        panic("minimax: apiKey must be non-empty")
    }
</code></pre>
<p><strong>Impact:</strong> Unrecoverable error at construction time.</p>
<p><strong>Suggestion:</strong> Return <code>(*Client, error)</code> or use builder pattern like Rust.</p>
<hr />
<h3 id="mmx-002-rust-services-created-on-each-call"><a class="header" href="#mmx-002-rust-services-created-on-each-call">MMX-002: Rust services created on each call</a></h3>
<p><strong>File:</strong> <code>rust/minimax/src/client.rs:91-123</code></p>
<p><strong>Description:</strong><br />
Service getters create new instances each call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn speech(&amp;self) -&gt; SpeechService {
    SpeechService::new(self.http.clone())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Impact:</strong> Arc clone overhead on each service access.</p>
<p><strong>Suggestion:</strong> Cache services or use <code>&amp;self</code> references.</p>
<hr />
<h3 id="mmx-003-go-streaming-uses-hex-encoding"><a class="header" href="#mmx-003-go-streaming-uses-hex-encoding">MMX-003: Go streaming uses hex encoding</a></h3>
<p><strong>File:</strong> <code>go/pkg/minimax/speech.go:51-56</code></p>
<p><strong>Description:</strong><br />
Audio data comes hex-encoded from API, decoded in SDK:</p>
<pre><code class="language-go">if apiResp.Data.Audio != "" {
    audio, err := decodeHexAudio(apiResp.Data.Audio)
</code></pre>
<p><strong>Impact:</strong> CPU overhead for decoding, 2x memory during decode.</p>
<p><strong>Note:</strong> This is API design, not SDK issue, but worth documenting.</p>
<hr />
<h3 id="mmx-004-no-request-timeout-option"><a class="header" href="#mmx-004-no-request-timeout-option">MMX-004: No request timeout option</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust SDKs don't have request-level timeout option. Go suggests using <code>context.WithTimeout</code>, Rust doesn't document timeout handling.</p>
<p><strong>Suggestion:</strong> Add timeout option or document clearly.</p>
<hr />
<h3 id="mmx-005-go-iterseq2-requires-go-123"><a class="header" href="#mmx-005-go-iterseq2-requires-go-123">MMX-005: Go iter.Seq2 requires Go 1.23+</a></h3>
<p><strong>File:</strong> <code>go/pkg/minimax/speech.go:78</code></p>
<p><strong>Description:</strong><br />
Streaming uses <code>iter.Seq2</code> which requires Go 1.23:</p>
<pre><code class="language-go">func (s *SpeechService) SynthesizeStream(ctx context.Context, req *SpeechRequest) iter.Seq2[*SpeechChunk, error]
</code></pre>
<p><strong>Impact:</strong> Not compatible with older Go versions.</p>
<p><strong>Note:</strong> Modern API choice, acceptable trade-off.</p>
<hr />
<h3 id="mmx-006-error-handling-inconsistency"><a class="header" href="#mmx-006-error-handling-inconsistency">MMX-006: Error handling inconsistency</a></h3>
<p><strong>Description:</strong><br />
Go uses <code>AsError()</code> helper function, Rust uses error enum matching.</p>
<p><strong>Go:</strong></p>
<pre><code class="language-go">if e, ok := minimax.AsError(err); ok {
    if e.IsRateLimit() { ... }
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match err {
    Error::Api { status_code, .. } =&gt; { ... }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Impact:</strong> Different patterns between languages.</p>
<hr />
<h2 id="-enhancements-10"><a class="header" href="#-enhancements-10">ğŸ”µ Enhancements</a></h2>
<h3 id="mmx-007-no-websocket-tts-support"><a class="header" href="#mmx-007-no-websocket-tts-support">MMX-007: No WebSocket TTS support</a></h3>
<p><strong>Description:</strong><br />
Official API supports WebSocket for TTS (<code>/v1/t2a_ws</code>), but SDK only implements HTTP.</p>
<p><strong>Suggestion:</strong> Add WebSocket-based streaming TTS for lower latency.</p>
<hr />
<h3 id="mmx-008-no-request-validation"><a class="header" href="#mmx-008-no-request-validation">MMX-008: No request validation</a></h3>
<p><strong>Description:</strong><br />
No client-side validation before sending requests. Invalid parameters only fail after API call.</p>
<p><strong>Suggestion:</strong> Add validation for known constraints (text length, model names, etc.).</p>
<hr />
<h3 id="mmx-009-no-retry-backoff-configuration"><a class="header" href="#mmx-009-no-retry-backoff-configuration">MMX-009: No retry backoff configuration</a></h3>
<p><strong>Description:</strong><br />
Retry count is configurable, but backoff strategy is hardcoded.</p>
<p><strong>Suggestion:</strong> Add configurable backoff (exponential, jitter).</p>
<hr />
<h3 id="mmx-010-no-requestresponse-logging"><a class="header" href="#mmx-010-no-requestresponse-logging">MMX-010: No request/response logging</a></h3>
<p><strong>Description:</strong><br />
No built-in debug logging for API requests/responses.</p>
<p><strong>Suggestion:</strong> Add optional logging middleware or debug mode.</p>
<hr />
<h3 id="mmx-011-no-rate-limit-handling"><a class="header" href="#mmx-011-no-rate-limit-handling">MMX-011: No rate limit handling</a></h3>
<p><strong>Description:</strong><br />
Rate limit errors are returned but not automatically handled (e.g., exponential backoff, queue).</p>
<p><strong>Suggestion:</strong> Add optional rate limit handling.</p>
<hr />
<h2 id="-notes-10"><a class="header" href="#-notes-10">âšª Notes</a></h2>
<h3 id="mmx-012-full-api-coverage-achieved"><a class="header" href="#mmx-012-full-api-coverage-achieved">MMX-012: Full API coverage achieved</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust SDKs implement all documented MiniMax API endpoints:</p>
<ul>
<li>Text generation</li>
<li>Speech synthesis (sync, stream, async)</li>
<li>Voice management (list, clone, design)</li>
<li>Video generation (text-to-video, image-to-video, agent)</li>
<li>Image generation</li>
<li>Music generation</li>
<li>File management</li>
</ul>
<hr />
<h3 id="mmx-013-async-task-pattern"><a class="header" href="#mmx-013-async-task-pattern">MMX-013: Async task pattern</a></h3>
<p><strong>Description:</strong><br />
Long-running operations (video, async speech, music) use a consistent pattern:</p>
<ol>
<li>Create task â†’ returns <code>Task[T]</code></li>
<li>Call <code>task.Wait()</code> for automatic polling</li>
<li>Or manual <code>task.Query()</code> for custom logic</li>
</ol>
<p>This is a well-designed abstraction.</p>
<hr />
<h3 id="mmx-014-base-url-handling"><a class="header" href="#mmx-014-base-url-handling">MMX-014: Base URL handling</a></h3>
<p><strong>Description:</strong><br />
Both SDKs support China and Global endpoints:</p>
<ul>
<li>China: <code>https://api.minimaxi.com</code></li>
<li>Global: <code>https://api.minimaxi.chat</code></li>
</ul>
<p>Correctly defaulting to China URL.</p>
<hr />
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>MMX-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Client</td></tr>
<tr><td>MMX-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust Client</td></tr>
<tr><td>MMX-003</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Both</td></tr>
<tr><td>MMX-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-005</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Go</td></tr>
<tr><td>MMX-006</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-010</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-011</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>MMX-012</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>MMX-013</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>MMX-014</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Well-implemented SDK with full API coverage. Both Go and Rust implementations are feature-complete and production-ready. Minor issues are mostly design choices rather than bugs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimax-å¼€æ”¾å¹³å°-api-æ–‡æ¡£"><a class="header" href="#minimax-å¼€æ”¾å¹³å°-api-æ–‡æ¡£">MiniMax å¼€æ”¾å¹³å° API æ–‡æ¡£</a></h1>
<blockquote>
<p><strong>å®˜æ–¹æ–‡æ¡£</strong>: <a href="https://platform.minimaxi.com/docs/api-reference/api-overview">MiniMax å¼€æ”¾å¹³å°æ–‡æ¡£ä¸­å¿ƒ</a></p>
<p><strong>æœ€åæ›´æ–°</strong>: 2026-01-19</p>
<p><strong>æ³¨æ„</strong>: æœ¬æ–‡æ¡£åŸºäºå®˜æ–¹æ–‡æ¡£æ•´ç†ï¼Œå¦‚æœ‰æ›´æ–°è¯·å‚è€ƒå®˜æ–¹æ–‡æ¡£</p>
</blockquote>
<h2 id="å®˜æ–¹æ–‡æ¡£å¯¼èˆª"><a class="header" href="#å®˜æ–¹æ–‡æ¡£å¯¼èˆª">å®˜æ–¹æ–‡æ¡£å¯¼èˆª</a></h2>
<p>å¦‚æœæœ¬æ–‡æ¡£ä¿¡æ¯ä¸å®Œæ•´æˆ–éœ€è¦æœ€æ–°ä¿¡æ¯ï¼Œè¯·è®¿é—®ä»¥ä¸‹å®˜æ–¹é“¾æ¥ï¼š</p>
<div class="table-wrapper"><table><thead><tr><th>åŠŸèƒ½æ¨¡å—</th><th>å®˜æ–¹æ–‡æ¡£é“¾æ¥</th></tr></thead><tbody>
<tr><td>æ¥å£æ¦‚è§ˆ</td><td>https://platform.minimaxi.com/docs/api-reference/api-overview</td></tr>
<tr><td>æ–‡æœ¬ç”Ÿæˆ (Anthropic)</td><td>https://platform.minimaxi.com/docs/api-reference/text-anthropic-api</td></tr>
<tr><td>æ–‡æœ¬ç”Ÿæˆ (OpenAI)</td><td>https://platform.minimaxi.com/docs/api-reference/text-openai-api</td></tr>
<tr><td>åŒæ­¥è¯­éŸ³åˆæˆ HTTP</td><td>https://platform.minimaxi.com/docs/api-reference/speech-t2a-http</td></tr>
<tr><td>åŒæ­¥è¯­éŸ³åˆæˆ WebSocket</td><td>https://platform.minimaxi.com/docs/api-reference/speech-t2a-ws</td></tr>
<tr><td>å¼‚æ­¥é•¿æ–‡æœ¬è¯­éŸ³åˆæˆ</td><td>https://platform.minimaxi.com/docs/api-reference/speech-t2a-async</td></tr>
<tr><td>éŸ³è‰²å¿«é€Ÿå¤åˆ»</td><td>https://platform.minimaxi.com/docs/api-reference/speech-voice-cloning</td></tr>
<tr><td>éŸ³è‰²è®¾è®¡</td><td>https://platform.minimaxi.com/docs/api-reference/speech-voice-design</td></tr>
<tr><td>å£°éŸ³ç®¡ç†</td><td>https://platform.minimaxi.com/docs/api-reference/speech-voice-management</td></tr>
<tr><td>è§†é¢‘ç”Ÿæˆ</td><td>https://platform.minimaxi.com/docs/api-reference/video-generation</td></tr>
<tr><td>è§†é¢‘ç”Ÿæˆ Agent</td><td>https://platform.minimaxi.com/docs/api-reference/video-generation-agent</td></tr>
<tr><td>å›¾ç‰‡ç”Ÿæˆ</td><td>https://platform.minimaxi.com/docs/api-reference/image-generation</td></tr>
<tr><td>éŸ³ä¹ç”Ÿæˆ</td><td>https://platform.minimaxi.com/docs/api-reference/music-generation</td></tr>
<tr><td>æ–‡ä»¶ç®¡ç†</td><td>https://platform.minimaxi.com/docs/api-reference/file-management</td></tr>
<tr><td>é”™è¯¯ç æŸ¥è¯¢</td><td>https://platform.minimaxi.com/docs/api-reference/error-code</td></tr>
</tbody></table>
</div>
<h2 id="å¦‚ä½•è·å–æœ€æ–°æ–‡æ¡£"><a class="header" href="#å¦‚ä½•è·å–æœ€æ–°æ–‡æ¡£">å¦‚ä½•è·å–æœ€æ–°æ–‡æ¡£</a></h2>
<h3 id="æ–¹æ³•ä¸€ç›´æ¥è®¿é—®å®˜ç½‘"><a class="header" href="#æ–¹æ³•ä¸€ç›´æ¥è®¿é—®å®˜ç½‘">æ–¹æ³•ä¸€ï¼šç›´æ¥è®¿é—®å®˜ç½‘</a></h3>
<p>è®¿é—® <a href="https://platform.minimaxi.com/docs/api-reference/api-overview">MiniMax å¼€æ”¾å¹³å°æ–‡æ¡£ä¸­å¿ƒ</a>ï¼Œå·¦ä¾§å¯¼èˆªæ åŒ…å«æ‰€æœ‰ API æ¥å£çš„è¯¦ç»†æ–‡æ¡£ã€‚</p>
<h3 id="æ–¹æ³•äºŒä½¿ç”¨-ai-å·¥å…·è¯»å–"><a class="header" href="#æ–¹æ³•äºŒä½¿ç”¨-ai-å·¥å…·è¯»å–">æ–¹æ³•äºŒï¼šä½¿ç”¨ AI å·¥å…·è¯»å–</a></h3>
<p>å¦‚æœä½¿ç”¨æ”¯æŒæµè§ˆå™¨åŠŸèƒ½çš„ AI å·¥å…·ï¼ˆå¦‚ Cursorï¼‰ï¼Œå¯ä»¥ï¼š</p>
<ol>
<li>ä½¿ç”¨ <code>browser_navigate</code> å·¥å…·è®¿é—®å®˜æ–¹æ–‡æ¡£é¡µé¢</li>
<li>ä½¿ç”¨ <code>browser_snapshot</code> è·å–é¡µé¢å†…å®¹</li>
<li>è§£æé¡µé¢ä¸­çš„ API å‚æ•°ã€è¯·æ±‚/å“åº”æ ¼å¼ç­‰ä¿¡æ¯</li>
</ol>
<p>ç¤ºä¾‹ï¼š</p>
<pre><code>è®¿é—®: https://platform.minimaxi.com/docs/api-reference/speech-t2a-http
</code></pre>
<h3 id="æ–¹æ³•ä¸‰æŸ¥çœ‹å®˜æ–¹-mcp-æœåŠ¡å™¨"><a class="header" href="#æ–¹æ³•ä¸‰æŸ¥çœ‹å®˜æ–¹-mcp-æœåŠ¡å™¨">æ–¹æ³•ä¸‰ï¼šæŸ¥çœ‹å®˜æ–¹ MCP æœåŠ¡å™¨</a></h3>
<p>MiniMax æä¾›äº†å®˜æ–¹çš„ MCPï¼ˆModel Context Protocolï¼‰æœåŠ¡å™¨å®ç°ï¼ŒåŒ…å«å®Œæ•´çš„ API è°ƒç”¨ç¤ºä¾‹ï¼š</p>
<ul>
<li><strong>Python ç‰ˆæœ¬</strong>: https://github.com/MiniMax-AI/MiniMax-MCP</li>
<li><strong>JavaScript ç‰ˆæœ¬</strong>: https://github.com/MiniMax-AI/MiniMax-MCP-JS</li>
</ul>
<h3 id="å…³äº-openapiswagger"><a class="header" href="#å…³äº-openapiswagger">å…³äº OpenAPI/Swagger</a></h3>
<p>MiniMax ç›®å‰<strong>æ²¡æœ‰å…¬å¼€æä¾›</strong> OpenAPI/Swagger è§„èŒƒæ–‡ä»¶ã€‚å¦‚éœ€è·å–ï¼Œå¯ä»¥ï¼š</p>
<ul>
<li>è”ç³»å®˜æ–¹æŠ€æœ¯æ”¯æŒ: api-support@minimaxi.com</li>
<li>åŸºäºå®˜æ–¹æ–‡æ¡£æ‰‹åŠ¨æ•´ç†</li>
</ul>
<h2 id="æ¦‚è¿°"><a class="header" href="#æ¦‚è¿°">æ¦‚è¿°</a></h2>
<p>MiniMax å¼€æ”¾å¹³å°æä¾›å¤šæ¨¡æ€ AI èƒ½åŠ›ï¼ŒåŒ…æ‹¬æ–‡æœ¬ç”Ÿæˆã€è¯­éŸ³åˆæˆã€è§†é¢‘ç”Ÿæˆã€å›¾åƒç”Ÿæˆã€éŸ³ä¹ç”Ÿæˆç­‰ã€‚</p>
<h2 id="api-èƒ½åŠ›æ¦‚è§ˆ"><a class="header" href="#api-èƒ½åŠ›æ¦‚è§ˆ">API èƒ½åŠ›æ¦‚è§ˆ</a></h2>
<div class="table-wrapper"><table><thead><tr><th>èƒ½åŠ›æ¨¡å—</th><th>è¯´æ˜</th><th>æ–‡æ¡£é“¾æ¥</th></tr></thead><tbody>
<tr><td>æ–‡æœ¬ç”Ÿæˆ</td><td>å¯¹è¯å†…å®¹ç”Ÿæˆã€å·¥å…·è°ƒç”¨</td><td><a href="lib/minimax/api/./text.html">text.md</a></td></tr>
<tr><td>åŒæ­¥è¯­éŸ³åˆæˆ (T2A)</td><td>çŸ­æ–‡æœ¬è¯­éŸ³åˆæˆï¼Œæ”¯æŒ HTTP/WebSocket</td><td><a href="lib/minimax/api/./speech-t2a.html">speech-t2a.md</a></td></tr>
<tr><td>å¼‚æ­¥é•¿æ–‡æœ¬è¯­éŸ³åˆæˆ</td><td>é•¿æ–‡æœ¬è¯­éŸ³åˆæˆï¼Œå¼‚æ­¥ä»»åŠ¡æ¨¡å¼</td><td><a href="lib/minimax/api/./speech-t2a-async.html">speech-t2a-async.md</a></td></tr>
<tr><td>éŸ³è‰²å¿«é€Ÿå¤åˆ»</td><td>ä¸Šä¼ éŸ³é¢‘å¤åˆ»éŸ³è‰²</td><td><a href="lib/minimax/api/./voice-cloning.html">voice-cloning.md</a></td></tr>
<tr><td>éŸ³è‰²è®¾è®¡</td><td>åŸºäºæè¿°ç”Ÿæˆä¸ªæ€§åŒ–éŸ³è‰²</td><td><a href="lib/minimax/api/./voice-design.html">voice-design.md</a></td></tr>
<tr><td>å£°éŸ³ç®¡ç†</td><td>æŸ¥è¯¢å’Œç®¡ç†å¯ç”¨éŸ³è‰²</td><td><a href="lib/minimax/api/./voice-management.html">voice-management.md</a></td></tr>
<tr><td>è§†é¢‘ç”Ÿæˆ</td><td>æ–‡ç”Ÿè§†é¢‘ã€å›¾ç”Ÿè§†é¢‘</td><td><a href="lib/minimax/api/./video.html">video.md</a></td></tr>
<tr><td>è§†é¢‘ç”Ÿæˆ Agent</td><td>åŸºäºæ¨¡æ¿çš„è§†é¢‘ç”Ÿæˆ</td><td><a href="lib/minimax/api/./video-agent.html">video-agent.md</a></td></tr>
<tr><td>å›¾ç‰‡ç”Ÿæˆ</td><td>æ–‡ç”Ÿå›¾ã€å›¾ç”Ÿå›¾</td><td><a href="lib/minimax/api/./image.html">image.md</a></td></tr>
<tr><td>éŸ³ä¹ç”Ÿæˆ</td><td>åŸºäºæè¿°å’Œæ­Œè¯ç”ŸæˆéŸ³ä¹</td><td><a href="lib/minimax/api/./music.html">music.md</a></td></tr>
<tr><td>æ–‡ä»¶ç®¡ç†</td><td>æ–‡ä»¶ä¸Šä¼ ã€ä¸‹è½½ã€ç®¡ç†</td><td><a href="lib/minimax/api/./file.html">file.md</a></td></tr>
</tbody></table>
</div>
<h2 id="è®¤è¯æ–¹å¼"><a class="header" href="#è®¤è¯æ–¹å¼">è®¤è¯æ–¹å¼</a></h2>
<p>æ‰€æœ‰ API ä½¿ç”¨ Bearer Token è®¤è¯ï¼š</p>
<pre><code>Authorization: Bearer &lt;your_api_key&gt;
</code></pre>
<h3 id="è·å–-api-key"><a class="header" href="#è·å–-api-key">è·å– API Key</a></h3>
<ol>
<li><strong>æŒ‰é‡ä»˜è´¹</strong>: åœ¨ã€Œè´¦æˆ·ç®¡ç† &gt; æ¥å£å¯†é’¥ã€ä¸­åˆ›å»º API Keyï¼Œæ”¯æŒæ‰€æœ‰æ¨¡æ€æ¨¡å‹</li>
<li><strong>Coding Plan</strong>: åˆ›å»º Coding Plan Keyï¼Œä»…æ”¯æŒæ–‡æœ¬æ¨¡å‹</li>
</ol>
<h2 id="åŸºç¡€-url"><a class="header" href="#åŸºç¡€-url">åŸºç¡€ URL</a></h2>
<div class="table-wrapper"><table><thead><tr><th>åœ°å€ç±»å‹</th><th>URL</th></tr></thead><tbody>
<tr><td>ä¸»è¦åœ°å€</td><td><code>https://api.minimaxi.com</code></td></tr>
<tr><td>å¤‡ç”¨åœ°å€</td><td><code>https://api-bj.minimaxi.com</code></td></tr>
</tbody></table>
</div>
<h2 id="è¯·æ±‚å¤´"><a class="header" href="#è¯·æ±‚å¤´">è¯·æ±‚å¤´</a></h2>
<div class="table-wrapper"><table><thead><tr><th>å‚æ•°</th><th>ç±»å‹</th><th>å¿…å¡«</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td>Authorization</td><td>string</td><td>æ˜¯</td><td><code>Bearer &lt;api_key&gt;</code></td></tr>
<tr><td>Content-Type</td><td>string</td><td>æ˜¯</td><td><code>application/json</code></td></tr>
</tbody></table>
</div>
<h2 id="é”™è¯¯å¤„ç†"><a class="header" href="#é”™è¯¯å¤„ç†">é”™è¯¯å¤„ç†</a></h2>
<p>API è¿”å›çš„é”™è¯¯å“åº”æ ¼å¼ï¼š</p>
<pre><code class="language-json">{
  "base_resp": {
    "status_code": 1000,
    "status_msg": "error message"
  }
}
</code></pre>
<h2 id="å®˜æ–¹èµ„æº"><a class="header" href="#å®˜æ–¹èµ„æº">å®˜æ–¹èµ„æº</a></h2>
<ul>
<li><a href="https://platform.minimaxi.com">MiniMax å¼€æ”¾å¹³å°</a></li>
<li><a href="https://github.com/MiniMax-AI/MiniMax-MCP">å®˜æ–¹ MCP æœåŠ¡å™¨ (Python)</a></li>
<li><a href="https://github.com/MiniMax-AI/MiniMax-MCP-JS">å®˜æ–¹ MCP æœåŠ¡å™¨ (JavaScript)</a></li>
<li>æŠ€æœ¯æ”¯æŒé‚®ç®±: api-support@minimaxi.com</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dashscope-sdk"><a class="header" href="#dashscope-sdk">DashScope SDK</a></h1>
<p>Go and Rust SDK for Aliyun DashScope (ç™¾ç‚¼ Model Studio) APIs.</p>
<blockquote>
<p><strong>Official API Documentation</strong>: <a href="lib/dashscope/./api/README.html">api/README.md</a></p>
</blockquote>
<h2 id="design-goals-11"><a class="header" href="#design-goals-11">Design Goals</a></h2>
<ol>
<li><strong>Realtime Focus</strong>: Primarily implement Qwen-Omni-Realtime WebSocket API</li>
<li><strong>OpenAI Compatibility</strong>: Text/chat APIs use OpenAI-compatible SDK</li>
<li><strong>Native WebSocket</strong>: Direct WebSocket implementation, not polling</li>
</ol>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This SDK focuses on <strong>Qwen-Omni-Realtime</strong> API for real-time multimodal conversation. For standard text APIs, use OpenAI-compatible SDKs.</p>
<div class="table-wrapper"><table><thead><tr><th>API</th><th style="text-align: center">SDK Coverage</th><th>Alternative</th></tr></thead><tbody>
<tr><td>Text Chat</td><td style="text-align: center">âŒ</td><td>OpenAI SDK with custom base URL</td></tr>
<tr><td>App/Agent</td><td style="text-align: center">âŒ</td><td>Direct HTTP calls</td></tr>
<tr><td>Realtime</td><td style="text-align: center">âœ…</td><td><strong>This SDK</strong></td></tr>
</tbody></table>
</div>
<h2 id="api-coverage-1"><a class="header" href="#api-coverage-1">API Coverage</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>Official Doc</th></tr></thead><tbody>
<tr><td>Realtime Session</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td><a href="lib/dashscope/./api/realtime/">api/realtime/</a></td></tr>
<tr><td>Audio Input/Output</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td></td></tr>
<tr><td>Function Calls</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td></td></tr>
<tr><td>Text Input</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td></td></tr>
<tr><td>Video Input</td><td style="text-align: center">âš ï¸</td><td style="text-align: center">âš ï¸</td><td>Limited support</td></tr>
</tbody></table>
</div>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Client                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          RealtimeService                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚       RealtimeSession           â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚   â”‚  â”‚   Send    â”‚ â”‚  Receive  â”‚    â”‚   â”‚
â”‚   â”‚  â”‚  Events   â”‚ â”‚  Events   â”‚    â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
       wss://dashscope.aliyuncs.com/api-ws/v1/realtime
</code></pre>
<h2 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h2>
<pre><code>Authorization: Bearer &lt;api_key&gt;
</code></pre>
<p>Optional workspace isolation:</p>
<pre><code>X-DashScope-WorkSpace: &lt;workspace_id&gt;
</code></pre>
<h2 id="base-urls-1"><a class="header" href="#base-urls-1">Base URLs</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Region</th><th>WebSocket URL</th></tr></thead><tbody>
<tr><td>China (Beijing)</td><td><code>wss://dashscope.aliyuncs.com/api-ws/v1/realtime</code></td></tr>
<tr><td>International (Singapore)</td><td><code>wss://dashscope-intl.aliyuncs.com/api-ws/v1/realtime</code></td></tr>
</tbody></table>
</div>
<h2 id="models"><a class="header" href="#models">Models</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Model</th><th>Input</th><th>Output</th><th>Sample Rate</th></tr></thead><tbody>
<tr><td><code>qwen-omni-turbo-realtime</code></td><td>audio/text</td><td>audio/text</td><td>16kHz</td></tr>
<tr><td><code>qwen3-omni-flash-realtime</code></td><td>audio/text/video</td><td>audio/text</td><td>24kHz</td></tr>
</tbody></table>
</div>
<h2 id="event-flow"><a class="header" href="#event-flow">Event Flow</a></h2>
<pre><code>Client                                     Server
   |                                         |
   |------ session.update ------------------&gt;|
   |                                         |
   |------ input_audio_buffer.append -------&gt;|
   |                                         |
   |------ response.create -----------------&gt;|
   |                                         |
   |&lt;----- response.audio.delta -------------|
   |&lt;----- response.audio.delta -------------|
   |&lt;----- response.done --------------------|
   |                                         |
</code></pre>
<h2 id="examples-directory-7"><a class="header" href="#examples-directory-7">Examples Directory</a></h2>
<ul>
<li><code>examples/go/dashscope/</code> - Go SDK examples</li>
<li><code>examples/cmd/dashscope/</code> - CLI test scripts</li>
</ul>
<h2 id="for-textchat-apis"><a class="header" href="#for-textchat-apis">For Text/Chat APIs</a></h2>
<p>Use OpenAI-compatible SDK:</p>
<p><strong>Go:</strong></p>
<pre><code class="language-go">import "github.com/sashabaranov/go-openai"

config := openai.DefaultConfig(apiKey)
config.BaseURL = "https://dashscope.aliyuncs.com/compatible-mode/v1"
client := openai.NewClientWithConfig(config)
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use async-openai with custom base URL
<span class="boring">}</span></code></pre></pre>
<h2 id="related-1"><a class="header" href="#related-1">Related</a></h2>
<ul>
<li>CLI tool: <code>go/cmd/dashscope/</code></li>
<li>CLI tests: <code>examples/cmd/dashscope/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dashscope-sdk---go-implementation"><a class="header" href="#dashscope-sdk---go-implementation">DashScope SDK - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/dashscope</code></p>
<h2 id="client-2"><a class="header" href="#client-2">Client</a></h2>
<pre><code class="language-go">type Client struct {
    Realtime *RealtimeService
}
</code></pre>
<p><strong>Constructor:</strong></p>
<pre><code class="language-go">// Basic
client := dashscope.NewClient("sk-xxxxxxxx")

// With workspace
client := dashscope.NewClient("sk-xxxxxxxx",
    dashscope.WithWorkspace("ws-xxxxxxxx"),
)

// Custom endpoint (international)
client := dashscope.NewClient("sk-xxxxxxxx",
    dashscope.WithBaseURL("wss://dashscope-intl.aliyuncs.com/api-ws/v1/realtime"),
)
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>WithWorkspace(id)</code></td><td>Workspace ID for isolation</td></tr>
<tr><td><code>WithBaseURL(url)</code></td><td>Custom WebSocket URL</td></tr>
<tr><td><code>WithHTTPBaseURL(url)</code></td><td>Custom HTTP URL</td></tr>
<tr><td><code>WithHTTPClient(client)</code></td><td>Custom HTTP client</td></tr>
</tbody></table>
</div>
<h2 id="realtimeservice"><a class="header" href="#realtimeservice">RealtimeService</a></h2>
<h3 id="connect-session"><a class="header" href="#connect-session">Connect Session</a></h3>
<pre><code class="language-go">session, err := client.Realtime.Connect(ctx, &amp;dashscope.RealtimeConfig{
    Model: dashscope.ModelQwenOmniTurboRealtimeLatest,
})
if err != nil {
    log.Fatal(err)
}
defer session.Close()
</code></pre>
<h3 id="send-events"><a class="header" href="#send-events">Send Events</a></h3>
<pre><code class="language-go">// Update session configuration
session.UpdateSession(&amp;dashscope.SessionUpdate{
    Modalities: []string{"text", "audio"},
    Voice: "Cherry",
    InputAudioFormat: "pcm16",
    OutputAudioFormat: "pcm16",
})

// Append audio data
session.AppendAudio(audioData)

// Commit audio (finalize input)
session.CommitAudio()

// Create response (start inference)
session.CreateResponse()

// Send text
session.AppendText("Hello!")

// Cancel response
session.CancelResponse()
</code></pre>
<h3 id="receive-events"><a class="header" href="#receive-events">Receive Events</a></h3>
<pre><code class="language-go">// Using Go 1.23+ iter.Seq2
for event, err := range session.Events() {
    if err != nil {
        log.Fatal(err)
    }
    
    switch event.Type {
    case dashscope.EventResponseAudioDelta:
        // Audio chunk received
        play(event.Delta)
        
    case dashscope.EventResponseTextDelta:
        // Text chunk received
        fmt.Print(event.Delta)
        
    case dashscope.EventResponseDone:
        // Response complete
        
    case dashscope.EventError:
        // Error occurred
        log.Printf("Error: %s", event.Error.Message)
    }
}
</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="client-events-send"><a class="header" href="#client-events-send">Client Events (Send)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>session.update</code></td><td>Update session configuration</td></tr>
<tr><td><code>input_audio_buffer.append</code></td><td>Append audio data</td></tr>
<tr><td><code>input_audio_buffer.commit</code></td><td>Finalize audio input</td></tr>
<tr><td><code>response.create</code></td><td>Request response</td></tr>
<tr><td><code>response.cancel</code></td><td>Cancel current response</td></tr>
</tbody></table>
</div>
<h3 id="server-events-receive"><a class="header" href="#server-events-receive">Server Events (Receive)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>session.created</code></td><td>Session established</td></tr>
<tr><td><code>session.updated</code></td><td>Configuration updated</td></tr>
<tr><td><code>response.created</code></td><td>Response started</td></tr>
<tr><td><code>response.audio.delta</code></td><td>Audio chunk</td></tr>
<tr><td><code>response.text.delta</code></td><td>Text chunk</td></tr>
<tr><td><code>response.done</code></td><td>Response complete</td></tr>
<tr><td><code>error</code></td><td>Error occurred</td></tr>
</tbody></table>
</div>
<h2 id="models-1"><a class="header" href="#models-1">Models</a></h2>
<pre><code class="language-go">const (
    ModelQwenOmniTurboRealtimeLatest  = "qwen-omni-turbo-realtime-latest"
    ModelQwen3OmniFlashRealtimeLatest = "qwen3-omni-flash-realtime-latest"
)
</code></pre>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<pre><code class="language-go">for event, err := range session.Events() {
    if err != nil {
        // Connection error
        log.Fatal(err)
    }
    
    if event.Type == dashscope.EventError {
        // API error
        log.Printf("API Error [%s]: %s", event.Error.Code, event.Error.Message)
    }
}
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><code class="language-go">func main() {
    client := dashscope.NewClient(os.Getenv("DASHSCOPE_API_KEY"))
    
    session, err := client.Realtime.Connect(context.Background(), &amp;dashscope.RealtimeConfig{
        Model: dashscope.ModelQwenOmniTurboRealtimeLatest,
    })
    if err != nil {
        log.Fatal(err)
    }
    defer session.Close()
    
    // Configure session
    session.UpdateSession(&amp;dashscope.SessionUpdate{
        Voice: "Cherry",
    })
    
    // Send audio (from microphone, etc.)
    session.AppendAudio(audioData)
    session.CommitAudio()
    session.CreateResponse()
    
    // Receive and play response
    for event, err := range session.Events() {
        if err != nil {
            break
        }
        if event.Type == dashscope.EventResponseAudioDelta {
            player.Write(event.Delta)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dashscope-sdk---rust-implementation"><a class="header" href="#dashscope-sdk---rust-implementation">DashScope SDK - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-dashscope</code></p>
<h2 id="client-3"><a class="header" href="#client-3">Client</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Client {
    // Internal configuration
}

impl Client {
    pub fn realtime(&amp;self) -&gt; RealtimeService;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Constructor:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_dashscope::{Client, DEFAULT_REALTIME_URL};

// Basic
let client = Client::new("sk-xxxxxxxx")?;

// With builder
let client = Client::builder("sk-xxxxxxxx")
    .workspace("ws-xxxxxxxx")
    .base_url("wss://dashscope-intl.aliyuncs.com/api-ws/v1/realtime")
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="realtimeservice-1"><a class="header" href="#realtimeservice-1">RealtimeService</a></h2>
<h3 id="connect-session-1"><a class="header" href="#connect-session-1">Connect Session</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_dashscope::{RealtimeConfig, ModelQwenOmniTurboRealtimeLatest};

let session = client.realtime().connect(&amp;RealtimeConfig {
    model: ModelQwenOmniTurboRealtimeLatest.to_string(),
    ..Default::default()
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="send-events-1"><a class="header" href="#send-events-1">Send Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update session
session.update_session(&amp;SessionUpdate {
    modalities: vec!["text".to_string(), "audio".to_string()],
    voice: Some("Cherry".to_string()),
    ..Default::default()
}).await?;

// Append audio
session.append_audio(&amp;audio_data).await?;

// Commit audio
session.commit_audio().await?;

// Create response
session.create_response().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="receive-events-1"><a class="header" href="#receive-events-1">Receive Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_dashscope::ServerEvent;

while let Some(event) = session.recv().await {
    let event = event?;
    
    match event {
        ServerEvent::ResponseAudioDelta { delta, .. } =&gt; {
            // Play audio
            player.write(&amp;delta)?;
        }
        ServerEvent::ResponseTextDelta { delta, .. } =&gt; {
            // Print text
            print!("{}", delta);
        }
        ServerEvent::ResponseDone { .. } =&gt; {
            // Complete
            break;
        }
        ServerEvent::Error { error } =&gt; {
            eprintln!("Error: {}", error.message);
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<h3 id="client-events-send-1"><a class="header" href="#client-events-send-1">Client Events (Send)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ClientEvent {
    SessionUpdate(SessionUpdate),
    InputAudioBufferAppend { audio: Vec&lt;u8&gt; },
    InputAudioBufferCommit,
    ResponseCreate(ResponseCreateOptions),
    ResponseCancel,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="server-events-receive-1"><a class="header" href="#server-events-receive-1">Server Events (Receive)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ServerEvent {
    SessionCreated { session: SessionInfo },
    SessionUpdated { session: SessionInfo },
    ResponseCreated { response: ResponseInfo },
    ResponseAudioDelta { delta: Vec&lt;u8&gt; },
    ResponseTextDelta { delta: String },
    ResponseDone { response: ResponseInfo },
    Error { error: ErrorInfo },
    // ... more events
}
<span class="boring">}</span></code></pre></pre>
<h2 id="models-2"><a class="header" href="#models-2">Models</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const MODEL_QWEN_OMNI_TURBO_REALTIME_LATEST: &amp;str = "qwen-omni-turbo-realtime-latest";
pub const MODEL_QWEN3_OMNI_FLASH_REALTIME_LATEST: &amp;str = "qwen3-omni-flash-realtime-latest";
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_dashscope::{Error, Result};

match session.recv().await {
    Some(Ok(event)) =&gt; {
        // Process event
    }
    Some(Err(Error::WebSocket(e))) =&gt; {
        eprintln!("WebSocket error: {}", e);
    }
    Some(Err(Error::Api { code, message })) =&gt; {
        eprintln!("API error [{}]: {}", code, message);
    }
    None =&gt; {
        // Connection closed
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use giztoy_dashscope::{Client, RealtimeConfig, ServerEvent};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let api_key = std::env::var("DASHSCOPE_API_KEY")?;
    let client = Client::new(&amp;api_key)?;
    
    let session = client.realtime().connect(&amp;RealtimeConfig {
        model: "qwen-omni-turbo-realtime-latest".to_string(),
        ..Default::default()
    }).await?;
    
    // Configure
    session.update_session(&amp;SessionUpdate {
        voice: Some("Cherry".to_string()),
        ..Default::default()
    }).await?;
    
    // Send audio
    session.append_audio(&amp;audio_data).await?;
    session.commit_audio().await?;
    session.create_response().await?;
    
    // Receive response
    while let Some(event) = session.recv().await {
        match event? {
            ServerEvent::ResponseAudioDelta { delta, .. } =&gt; {
                player.write(&amp;delta)?;
            }
            ServerEvent::ResponseDone { .. } =&gt; break,
            _ =&gt; {}
        }
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="differences-from-go-10"><a class="header" href="#differences-from-go-10">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>Event receiving</td><td><code>iter.Seq2</code> (sync-like)</td><td><code>async Stream</code></td></tr>
<tr><td>Session lifetime</td><td>Manual <code>defer Close()</code></td><td>Drop trait</td></tr>
<tr><td>Audio encoding</td><td><code>[]byte</code></td><td><code>Vec&lt;u8&gt;</code></td></tr>
<tr><td>WebSocket</td><td>gorilla/websocket</td><td>tokio-tungstenite</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dashscope-sdk---known-issues"><a class="header" href="#dashscope-sdk---known-issues">DashScope SDK - Known Issues</a></h1>
<h2 id="-minor-issues-10"><a class="header" href="#-minor-issues-10">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="ds-001-go-newclient-panics-on-empty-api-key"><a class="header" href="#ds-001-go-newclient-panics-on-empty-api-key">DS-001: Go NewClient panics on empty API key</a></h3>
<p><strong>File:</strong> <code>go/pkg/dashscope/client.go:39-41</code></p>
<p><strong>Description:</strong><br />
NewClient panics instead of returning an error:</p>
<pre><code class="language-go">func NewClient(apiKey string, opts ...Option) *Client {
    if apiKey == "" {
        panic("dashscope: API key is required")
    }
</code></pre>
<p><strong>Impact:</strong> Unrecoverable error at construction time.</p>
<p><strong>Suggestion:</strong> Return <code>(*Client, error)</code> like Rust version.</p>
<hr />
<h3 id="ds-002-limited-to-realtime-api-only"><a class="header" href="#ds-002-limited-to-realtime-api-only">DS-002: Limited to Realtime API only</a></h3>
<p><strong>Description:</strong><br />
SDK only implements Realtime API. Text/Chat APIs require separate OpenAI-compatible SDK.</p>
<p><strong>Impact:</strong> Users need two SDKs for full DashScope usage.</p>
<p><strong>Note:</strong> This is intentional design choice - text APIs are OpenAI-compatible.</p>
<hr />
<h3 id="ds-003-no-http-api-implementation"><a class="header" href="#ds-003-no-http-api-implementation">DS-003: No HTTP API implementation</a></h3>
<p><strong>Description:</strong><br />
No HTTP client for non-realtime operations (file upload, app calls, etc.).</p>
<p><strong>Suggestion:</strong> Add HTTP service for app/agent API calls.</p>
<hr />
<h3 id="ds-004-video-input-support-limited"><a class="header" href="#ds-004-video-input-support-limited">DS-004: Video input support limited</a></h3>
<p><strong>Description:</strong><br />
Qwen3-Omni-Flash supports video input, but SDK support may be incomplete.</p>
<p><strong>Status:</strong> âš ï¸ Needs verification.</p>
<hr />
<h2 id="-enhancements-11"><a class="header" href="#-enhancements-11">ğŸ”µ Enhancements</a></h2>
<h3 id="ds-005-no-automatic-reconnection"><a class="header" href="#ds-005-no-automatic-reconnection">DS-005: No automatic reconnection</a></h3>
<p><strong>Description:</strong><br />
WebSocket sessions don't auto-reconnect on disconnection.</p>
<p><strong>Suggestion:</strong> Add reconnection with backoff for long-running sessions.</p>
<hr />
<h3 id="ds-006-no-audio-transcoding"><a class="header" href="#ds-006-no-audio-transcoding">DS-006: No audio transcoding</a></h3>
<p><strong>Description:</strong><br />
Audio must be in correct format (PCM16/PCM24). No built-in transcoding.</p>
<p><strong>Suggestion:</strong> Add optional audio format conversion.</p>
<hr />
<h3 id="ds-007-no-vad-voice-activity-detection-integration"><a class="header" href="#ds-007-no-vad-voice-activity-detection-integration">DS-007: No VAD (Voice Activity Detection) integration</a></h3>
<p><strong>Description:</strong><br />
Manual audio buffer management. No built-in VAD for automatic speech detection.</p>
<p><strong>Suggestion:</strong> Integrate with <code>audio/pcm</code> for silence detection.</p>
<hr />
<h3 id="ds-008-missing-tool-call-examples"><a class="header" href="#ds-008-missing-tool-call-examples">DS-008: Missing tool call examples</a></h3>
<p><strong>Description:</strong><br />
Function/tool calling is supported but not well documented with examples.</p>
<hr />
<h2 id="-notes-11"><a class="header" href="#-notes-11">âšª Notes</a></h2>
<h3 id="ds-009-clean-websocket-event-model"><a class="header" href="#ds-009-clean-websocket-event-model">DS-009: Clean WebSocket event model</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust implement clean event-based model matching OpenAI Realtime API patterns. This is well-designed.</p>
<hr />
<h3 id="ds-010-model-constants-provided"><a class="header" href="#ds-010-model-constants-provided">DS-010: Model constants provided</a></h3>
<p><strong>Description:</strong><br />
Both SDKs provide model name constants:</p>
<pre><code class="language-go">const ModelQwenOmniTurboRealtimeLatest = "qwen-omni-turbo-realtime-latest"
</code></pre>
<p>Good for discoverability and avoiding typos.</p>
<hr />
<h3 id="ds-011-workspace-support"><a class="header" href="#ds-011-workspace-support">DS-011: Workspace support</a></h3>
<p><strong>Description:</strong><br />
Both SDKs support workspace isolation via <code>WithWorkspace()</code> option:</p>
<pre><code class="language-go">client := dashscope.NewClient(apiKey, dashscope.WithWorkspace("ws-xxx"))
</code></pre>
<p>Useful for enterprise environments.</p>
<hr />
<h3 id="ds-012-international-endpoint-support"><a class="header" href="#ds-012-international-endpoint-support">DS-012: International endpoint support</a></h3>
<p><strong>Description:</strong><br />
SDKs support both China and international endpoints:</p>
<ul>
<li>China: <code>wss://dashscope.aliyuncs.com/...</code></li>
<li>International: <code>wss://dashscope-intl.aliyuncs.com/...</code></li>
</ul>
<hr />
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>DS-001</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go Client</td></tr>
<tr><td>DS-002</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Both</td></tr>
<tr><td>DS-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>DS-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>DS-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DS-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DS-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DS-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DS-009</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>DS-010</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>DS-011</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>DS-012</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Focused SDK for Realtime API with clean design. Main limitation is narrow scope (Realtime only), which is intentional since text APIs are OpenAI-compatible. Both Go and Rust implementations are feature-complete for their scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dashscope-é˜¿é‡Œäº‘ç™¾ç‚¼-api-æ–‡æ¡£"><a class="header" href="#dashscope-é˜¿é‡Œäº‘ç™¾ç‚¼-api-æ–‡æ¡£">DashScope (é˜¿é‡Œäº‘ç™¾ç‚¼) API æ–‡æ¡£</a></h1>
<h2 id="åŸå§‹æ–‡æ¡£"><a class="header" href="#åŸå§‹æ–‡æ¡£">åŸå§‹æ–‡æ¡£</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ–‡æ¡£</th><th>é“¾æ¥</th></tr></thead><tbody>
<tr><td>ç™¾ç‚¼å¹³å°é¦–é¡µ</td><td>https://help.aliyun.com/zh/model-studio/</td></tr>
<tr><td>API å‚è€ƒ</td><td>https://help.aliyun.com/zh/model-studio/qwen-api-reference</td></tr>
<tr><td>å¼€é€šæœåŠ¡</td><td>https://help.aliyun.com/zh/dashscope/opening-service</td></tr>
<tr><td>è·å– API Key</td><td>https://help.aliyun.com/zh/model-studio/get-api-key</td></tr>
<tr><td>æ¨¡å‹åˆ—è¡¨</td><td>https://help.aliyun.com/zh/model-studio/model-list</td></tr>
</tbody></table>
</div>
<blockquote>
<p>å¦‚æœæœ¬æ–‡æ¡£ä¿¡æ¯ä¸å®Œæ•´ï¼Œè¯·è®¿é—®ä¸Šè¿°é“¾æ¥è·å–æœ€æ–°å†…å®¹ã€‚</p>
</blockquote>
<hr />
<h2 id="æ¦‚è¿°-1"><a class="header" href="#æ¦‚è¿°-1">æ¦‚è¿°</a></h2>
<p>DashScope æ˜¯é˜¿é‡Œäº‘å¤§æ¨¡å‹æœåŠ¡å¹³å°ç™¾ç‚¼ï¼ˆModel Studioï¼‰æä¾›çš„ API æœåŠ¡ã€‚æ”¯æŒï¼š</p>
<ul>
<li><strong>æ–‡æœ¬ç”Ÿæˆ</strong> - é€šä¹‰åƒé—®ï¼ˆQwenï¼‰ç³»åˆ—å¤§è¯­è¨€æ¨¡å‹ï¼Œå…¼å®¹ OpenAI API</li>
<li><strong>å¤šæ¨¡æ€</strong> - å›¾åƒç†è§£ã€éŸ³é¢‘ç†è§£</li>
<li><strong>å®æ—¶å¯¹è¯</strong> - Qwen-Omni-Realtime å®æ—¶éŸ³é¢‘/è§†é¢‘å¯¹è¯</li>
<li><strong>æ™ºèƒ½ä½“åº”ç”¨</strong> - è°ƒç”¨å·²é…ç½®çš„ Agent/å·¥ä½œæµåº”ç”¨</li>
<li><strong>çŸ¥è¯†åº“</strong> - æ–‡æ¡£ä¸Šä¼ ã€ç´¢å¼•ã€æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰</li>
</ul>
<hr />
<h2 id="ç›®å½•ç»“æ„"><a class="header" href="#ç›®å½•ç»“æ„">ç›®å½•ç»“æ„</a></h2>
<pre><code>docs/dashscope/
â”œâ”€â”€ README.md           # æœ¬æ–‡æ¡£ - æ¦‚è¿°
â”œâ”€â”€ auth.md             # è®¤è¯ä¸é‰´æƒ
â”œâ”€â”€ text.md             # æ–‡æœ¬æ¨¡å‹ API (Qwen)
â”œâ”€â”€ app.md              # åº”ç”¨è°ƒç”¨ API
â””â”€â”€ realtime/           # å®æ—¶å¤šæ¨¡æ€ API
    â”œâ”€â”€ README.md       # æ¦‚è¿°
    â”œâ”€â”€ client-events.md # å®¢æˆ·ç«¯äº‹ä»¶
    â””â”€â”€ server-events.md # æœåŠ¡ç«¯äº‹ä»¶
</code></pre>
<hr />
<h2 id="æœåŠ¡ç«¯ç‚¹"><a class="header" href="#æœåŠ¡ç«¯ç‚¹">æœåŠ¡ç«¯ç‚¹</a></h2>
<h3 id="http-api"><a class="header" href="#http-api">HTTP API</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åœ°åŸŸ</th><th>ç«¯ç‚¹</th><th>ç”¨é€”</th></tr></thead><tbody>
<tr><td>åŒ—äº¬ï¼ˆä¸­å›½å¤§é™†ï¼‰</td><td><code>https://dashscope.aliyuncs.com/compatible-mode/v1</code></td><td>OpenAI å…¼å®¹</td></tr>
<tr><td>æ–°åŠ å¡ï¼ˆå›½é™…ï¼‰</td><td><code>https://dashscope-intl.aliyuncs.com/compatible-mode/v1</code></td><td>OpenAI å…¼å®¹</td></tr>
<tr><td>å¼—å‰å°¼äºšï¼ˆç¾å›½ï¼‰</td><td><code>https://dashscope-us.aliyuncs.com/compatible-mode/v1</code></td><td>OpenAI å…¼å®¹</td></tr>
</tbody></table>
</div>
<h3 id="websocket-api"><a class="header" href="#websocket-api">WebSocket API</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åœ°åŸŸ</th><th>ç«¯ç‚¹</th><th>ç”¨é€”</th></tr></thead><tbody>
<tr><td>åŒ—äº¬</td><td><code>wss://dashscope.aliyuncs.com/api-ws/v1/realtime</code></td><td>å®æ—¶å¯¹è¯</td></tr>
<tr><td>æ–°åŠ å¡</td><td><code>wss://dashscope-intl.aliyuncs.com/api-ws/v1/realtime</code></td><td>å®æ—¶å¯¹è¯</td></tr>
</tbody></table>
</div>
<h3 id="åº”ç”¨-api"><a class="header" href="#åº”ç”¨-api">åº”ç”¨ API</a></h3>
<pre><code>POST https://dashscope.aliyuncs.com/api/v1/apps/{APP_ID}/completion
</code></pre>
<hr />
<h2 id="æ”¯æŒçš„æ¨¡å‹"><a class="header" href="#æ”¯æŒçš„æ¨¡å‹">æ”¯æŒçš„æ¨¡å‹</a></h2>
<h3 id="æ–‡æœ¬æ¨¡å‹-qwen"><a class="header" href="#æ–‡æœ¬æ¨¡å‹-qwen">æ–‡æœ¬æ¨¡å‹ (Qwen)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¨¡å‹</th><th>ä¸Šä¸‹æ–‡</th><th>ç‰¹ç‚¹</th></tr></thead><tbody>
<tr><td>qwen-turbo</td><td>128K</td><td>å¿«é€Ÿå“åº”ï¼Œæ€§ä»·æ¯”é«˜</td></tr>
<tr><td>qwen-plus</td><td>128K</td><td>å¹³è¡¡æ€§èƒ½ä¸æˆæœ¬</td></tr>
<tr><td>qwen-max</td><td>32K</td><td>æœ€å¼ºèƒ½åŠ›</td></tr>
<tr><td>qwen-long</td><td>1M</td><td>è¶…é•¿ä¸Šä¸‹æ–‡</td></tr>
</tbody></table>
</div>
<h3 id="å¤šæ¨¡æ€æ¨¡å‹"><a class="header" href="#å¤šæ¨¡æ€æ¨¡å‹">å¤šæ¨¡æ€æ¨¡å‹</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¨¡å‹</th><th>èƒ½åŠ›</th></tr></thead><tbody>
<tr><td>qwen-vl-plus</td><td>è§†è§‰ç†è§£</td></tr>
<tr><td>qwen-vl-max</td><td>è§†è§‰ç†è§£ï¼ˆå¼ºåŒ–ç‰ˆï¼‰</td></tr>
<tr><td>qwen-audio-turbo</td><td>éŸ³é¢‘ç†è§£</td></tr>
</tbody></table>
</div>
<h3 id="å®æ—¶å¤šæ¨¡æ€æ¨¡å‹"><a class="header" href="#å®æ—¶å¤šæ¨¡æ€æ¨¡å‹">å®æ—¶å¤šæ¨¡æ€æ¨¡å‹</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¨¡å‹</th><th>è¾“å‡ºæ ¼å¼</th><th>é»˜è®¤éŸ³è‰²</th></tr></thead><tbody>
<tr><td>Qwen3-Omni-Flash-Realtime</td><td>pcm24</td><td>Cherry</td></tr>
<tr><td>Qwen-Omni-Turbo-Realtime</td><td>pcm16</td><td>Chelsie</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="å¿«é€Ÿå¼€å§‹"><a class="header" href="#å¿«é€Ÿå¼€å§‹">å¿«é€Ÿå¼€å§‹</a></h2>
<h3 id="1-è·å–-api-key"><a class="header" href="#1-è·å–-api-key">1. è·å– API Key</a></h3>
<ol>
<li>ç™»å½• <a href="https://bailian.console.aliyun.com/">ç™¾ç‚¼æ§åˆ¶å°</a></li>
<li>è¿›å…¥"å¯†é’¥ç®¡ç†"</li>
<li>åˆ›å»º API Key</li>
</ol>
<h3 id="2-è®¾ç½®ç¯å¢ƒå˜é‡"><a class="header" href="#2-è®¾ç½®ç¯å¢ƒå˜é‡">2. è®¾ç½®ç¯å¢ƒå˜é‡</a></h3>
<pre><code class="language-bash">export DASHSCOPE_API_KEY="sk-xxxxxxxxxxxxxxxx"
</code></pre>
<h3 id="3-è°ƒç”¨ç¤ºä¾‹"><a class="header" href="#3-è°ƒç”¨ç¤ºä¾‹">3. è°ƒç”¨ç¤ºä¾‹</a></h3>
<pre><code class="language-bash">curl https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions \
  -H "Authorization: Bearer $DASHSCOPE_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "qwen-turbo",
    "messages": [{"role": "user", "content": "Hello!"}]
  }'
</code></pre>
<hr />
<h2 id="è¯¦ç»†æ–‡æ¡£"><a class="header" href="#è¯¦ç»†æ–‡æ¡£">è¯¦ç»†æ–‡æ¡£</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ–‡æ¡£</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td><a href="lib/dashscope/api/./auth.html">è®¤è¯ä¸é‰´æƒ</a></td><td>API Key ç®¡ç†ã€æƒé™æ§åˆ¶ã€å·¥ä½œç©ºé—´</td></tr>
<tr><td><a href="lib/dashscope/api/./text.html">æ–‡æœ¬æ¨¡å‹ API</a></td><td>Qwen ç³»åˆ—æ¨¡å‹ã€OpenAI å…¼å®¹æ¥å£</td></tr>
<tr><td><a href="lib/dashscope/api/./app.html">åº”ç”¨è°ƒç”¨ API</a></td><td>æ™ºèƒ½ä½“åº”ç”¨ã€å·¥ä½œæµã€çŸ¥è¯†åº“æ£€ç´¢</td></tr>
<tr><td><a href="lib/dashscope/api/./realtime/README.html">å®æ—¶å¤šæ¨¡æ€</a></td><td>Qwen-Omni-Realtime å®æ—¶è¯­éŸ³å¯¹è¯</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<h3 id="python-openai-sdk"><a class="header" href="#python-openai-sdk">Python (OpenAI SDK)</a></h3>
<pre><code class="language-python">from openai import OpenAI

client = OpenAI(
    api_key=os.getenv("DASHSCOPE_API_KEY"),
    base_url="https://dashscope.aliyuncs.com/compatible-mode/v1"
)

response = client.chat.completions.create(
    model="qwen-turbo",
    messages=[{"role": "user", "content": "Hello!"}]
)
</code></pre>
<h3 id="go-go-openai"><a class="header" href="#go-go-openai">Go (go-openai)</a></h3>
<pre><code class="language-go">import "github.com/sashabaranov/go-openai"

config := openai.DefaultConfig(os.Getenv("DASHSCOPE_API_KEY"))
config.BaseURL = "https://dashscope.aliyuncs.com/compatible-mode/v1"

client := openai.NewClientWithConfig(config)
</code></pre>
<h3 id="go-giztoydashscope---realtime-api"><a class="header" href="#go-giztoydashscope---realtime-api">Go (giztoy/dashscope) - Realtime API</a></h3>
<p>æœ¬é¡¹ç›®æä¾›äº†åŸç”Ÿ Go SDK æ”¯æŒ Qwen-Omni-Realtime APIï¼š</p>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/dashscope"

client := dashscope.NewClient(os.Getenv("DASHSCOPE_API_KEY"))
session, err := client.Realtime.Connect(ctx, &amp;dashscope.RealtimeConfig{
    Model: dashscope.ModelQwenOmniTurboRealtimeLatest,
})
// å‘é€éŸ³é¢‘ã€æ¥æ”¶äº‹ä»¶...
</code></pre>
<p>CLI å·¥å…·: <code>bazel run //go/cmd/dashscope -- omni chat</code></p>
<h3 id="å®˜æ–¹-sdk"><a class="header" href="#å®˜æ–¹-sdk">å®˜æ–¹ SDK</a></h3>
<ul>
<li>Python: <code>pip install dashscope</code></li>
<li>Java: Maven ä¾èµ– <code>com.alibaba:dashscope-sdk</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doubao-speech-sdk"><a class="header" href="#doubao-speech-sdk">Doubao Speech SDK</a></h1>
<p>Go and Rust SDK for Volcengine Doubao Speech API (è±†åŒ…è¯­éŸ³).</p>
<blockquote>
<p><strong>Official API Documentation</strong>: <a href="lib/doubaospeech/./api/README.html">api/README.md</a></p>
</blockquote>
<h2 id="design-goals-12"><a class="header" href="#design-goals-12">Design Goals</a></h2>
<ol>
<li><strong>Dual API Version Support</strong>: V1 (Classic) and V2/V3 (BigModel) APIs</li>
<li><strong>Multiple Auth Methods</strong>: Bearer Token, API Key, V2 API Key</li>
<li><strong>Comprehensive Coverage</strong>: TTS, ASR, Voice Clone, Realtime, Meeting, Podcast, etc.</li>
<li><strong>Streaming-first</strong>: WebSocket-based streaming for real-time scenarios</li>
</ol>
<h2 id="api-versions"><a class="header" href="#api-versions">API Versions</a></h2>
<p>Doubao Speech has two API generations:</p>
<div class="table-wrapper"><table><thead><tr><th>Version</th><th>Name</th><th>Features</th><th>Recommended</th></tr></thead><tbody>
<tr><td>V1</td><td>Classic</td><td>Basic TTS/ASR</td><td>Legacy use</td></tr>
<tr><td>V2/V3</td><td>BigModel</td><td>Advanced TTS/ASR, Realtime</td><td>âœ… New projects</td></tr>
</tbody></table>
</div>
<h2 id="api-coverage-2"><a class="header" href="#api-coverage-2">API Coverage</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th style="text-align: center">V1 (Classic)</th><th style="text-align: center">V2 (BigModel)</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td>TTS Sync</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>TTS Stream</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>TTS Async (Long Text)</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td></tr>
<tr><td>ASR One-sentence</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>ASR Stream</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>ASR File</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td></tr>
<tr><td>Voice Clone</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Realtime Dialogue</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Meeting Transcription</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Podcast Synthesis</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Translation (SIMT)</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Media Subtitle</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Console API</td><td style="text-align: center">N/A</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
</tbody></table>
</div>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Client                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚               V1 Services (Classic)                 â”‚ â”‚
â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚ â”‚
â”‚ â”‚  â”‚   TTS    â”‚ â”‚   ASR    â”‚                         â”‚ â”‚
â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚               V2 Services (BigModel)                â”‚ â”‚
â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚ â”‚  â”‚  TTSV2   â”‚ â”‚  ASRV2   â”‚ â”‚ VoiceClone, Realtime â”‚â”‚ â”‚
â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Meeting, Podcast     â”‚â”‚ â”‚
â”‚ â”‚                            â”‚ Translation, Media   â”‚â”‚ â”‚
â”‚ â”‚                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Console Client                       â”‚
â”‚          (AK/SK Signature Authentication)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="authentication-methods"><a class="header" href="#authentication-methods">Authentication Methods</a></h2>
<h3 id="speech-api-client"><a class="header" href="#speech-api-client">Speech API Client</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Header</th><th>Use Case</th></tr></thead><tbody>
<tr><td>API Key</td><td><code>x-api-key: {key}</code></td><td>Simplest, recommended</td></tr>
<tr><td>Bearer Token</td><td><code>Authorization: Bearer;{token}</code></td><td>V1 APIs</td></tr>
<tr><td>V2 API Key</td><td><code>X-Api-Access-Key</code>, <code>X-Api-App-Key</code></td><td>V2/V3 APIs</td></tr>
</tbody></table>
</div>
<h3 id="console-client"><a class="header" href="#console-client">Console Client</a></h3>
<p>Uses Volcengine OpenAPI AK/SK signature (HMAC-SHA256).</p>
<h2 id="resource-ids-v2v3"><a class="header" href="#resource-ids-v2v3">Resource IDs (V2/V3)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Service</th><th>Resource ID</th></tr></thead><tbody>
<tr><td>TTS 2.0</td><td><code>seed-tts-2.0</code></td></tr>
<tr><td>TTS 2.0 Concurrent</td><td><code>seed-tts-2.0-concurr</code></td></tr>
<tr><td>ASR Stream</td><td><code>volc.bigasr.sauc.duration</code></td></tr>
<tr><td>ASR File</td><td><code>volc.bigasr.auc.duration</code></td></tr>
<tr><td>Realtime</td><td><code>volc.speech.dialog</code></td></tr>
<tr><td>Podcast</td><td><code>volc.service_type.10050</code></td></tr>
<tr><td>Translation</td><td><code>volc.megatts.simt</code></td></tr>
<tr><td>Voice Clone</td><td><code>seed-icl-2.0</code></td></tr>
</tbody></table>
</div>
<h2 id="clusters-v1"><a class="header" href="#clusters-v1">Clusters (V1)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Cluster</th><th>Service</th></tr></thead><tbody>
<tr><td><code>volcano_tts</code></td><td>TTS Standard</td></tr>
<tr><td><code>volcano_mega</code></td><td>TTS BigModel</td></tr>
<tr><td><code>volcano_icl</code></td><td>Voice Clone</td></tr>
<tr><td><code>volcengine_streaming_common</code></td><td>ASR Streaming</td></tr>
</tbody></table>
</div>
<h2 id="examples-directory-8"><a class="header" href="#examples-directory-8">Examples Directory</a></h2>
<ul>
<li><code>examples/go/doubaospeech/</code> - Go SDK examples</li>
<li><code>examples/cmd/doubaospeech/</code> - CLI test scripts</li>
</ul>
<h2 id="related-2"><a class="header" href="#related-2">Related</a></h2>
<ul>
<li>CLI tool: <code>go/cmd/doubaospeech/</code></li>
<li>CLI tests: <code>examples/cmd/doubaospeech/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doubao-speech-sdk---go-implementation"><a class="header" href="#doubao-speech-sdk---go-implementation">Doubao Speech SDK - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/doubaospeech</code></p>
<h2 id="clients"><a class="header" href="#clients">Clients</a></h2>
<h3 id="speech-api-client-1"><a class="header" href="#speech-api-client-1">Speech API Client</a></h3>
<pre><code class="language-go">type Client struct {
    // V1 Services (Classic)
    TTS *TTSService
    ASR *ASRService
    
    // V2 Services (BigModel)
    TTSV2 *TTSServiceV2
    ASRV2 *ASRServiceV2
    
    // Shared Services
    VoiceClone  *VoiceCloneService
    Realtime    *RealtimeService
    Meeting     *MeetingService
    Podcast     *PodcastService
    Translation *TranslationService
    Media       *MediaService
}
</code></pre>
<p><strong>Constructor:</strong></p>
<pre><code class="language-go">// With API Key (recommended)
client := doubaospeech.NewClient("app-id",
    doubaospeech.WithAPIKey("your-api-key"),
    doubaospeech.WithCluster("volcano_tts"),
)

// With Bearer Token
client := doubaospeech.NewClient("app-id",
    doubaospeech.WithBearerToken("your-token"),
)

// With V2 API Key (for BigModel APIs)
client := doubaospeech.NewClient("app-id",
    doubaospeech.WithV2APIKey("access-key", "app-key"),
    doubaospeech.WithResourceID("seed-tts-2.0"),
)
</code></pre>
<h3 id="console-api-client"><a class="header" href="#console-api-client">Console API Client</a></h3>
<pre><code class="language-go">console := doubaospeech.NewConsole("access-key", "secret-key")
</code></pre>
<h2 id="services-3"><a class="header" href="#services-3">Services</a></h2>
<h3 id="tts-v1-classic"><a class="header" href="#tts-v1-classic">TTS V1 (Classic)</a></h3>
<pre><code class="language-go">// Synchronous
resp, err := client.TTS.Synthesize(ctx, &amp;doubaospeech.TTSRequest{
    Text:      "ä½ å¥½ï¼Œä¸–ç•Œï¼",
    VoiceType: "zh_female_cancan",
})
// resp.Audio contains audio bytes

// Streaming (Go 1.23+ iter.Seq2)
for chunk, err := range client.TTS.SynthesizeStream(ctx, req) {
    if err != nil {
        return err
    }
    buf.Write(chunk.Audio)
}
</code></pre>
<h3 id="tts-v2-bigmodel"><a class="header" href="#tts-v2-bigmodel">TTS V2 (BigModel)</a></h3>
<pre><code class="language-go">// Streaming HTTP
for chunk, err := range client.TTSV2.SynthesizeStream(ctx, &amp;doubaospeech.TTSV2Request{
    Text:       "ä½ å¥½ï¼Œä¸–ç•Œï¼",
    VoiceType:  "zh_female_cancan",
    ResourceID: "seed-tts-2.0",
}) {
    // Process chunk
}

// Async (long text)
task, err := client.TTSV2.SubmitAsync(ctx, &amp;doubaospeech.AsyncTTSRequest{
    Text: longText,
})
result, err := task.Wait(ctx)
</code></pre>
<h3 id="asr-speech-recognition"><a class="header" href="#asr-speech-recognition">ASR (Speech Recognition)</a></h3>
<pre><code class="language-go">// One-sentence (V1)
resp, err := client.ASR.Recognize(ctx, &amp;doubaospeech.ASRRequest{
    Audio:    audioData,
    Format:   "pcm",
    Language: "zh-CN",
})

// Streaming (WebSocket)
session, err := client.ASR.OpenStreamSession(ctx, &amp;doubaospeech.StreamASRConfig{
    Format:     "pcm",
    SampleRate: 16000,
})
defer session.Close()

// Send audio chunks
session.SendAudio(ctx, audioData, false)
session.SendAudio(ctx, lastData, true)

// Receive results
for chunk, err := range session.Recv() {
    if err != nil {
        break
    }
    fmt.Println(chunk.Text)
}
</code></pre>
<h3 id="voice-clone"><a class="header" href="#voice-clone">Voice Clone</a></h3>
<pre><code class="language-go">// Upload audio for training
result, err := client.VoiceClone.Upload(ctx, &amp;doubaospeech.VoiceCloneRequest{
    AudioData: audioData,
    VoiceID:   "my-custom-voice",
})

// Check status
status, err := client.VoiceClone.GetStatus(ctx, "my-custom-voice")

// Activate voice
err := client.VoiceClone.Activate(ctx, "my-custom-voice")
</code></pre>
<h3 id="realtime-dialogue"><a class="header" href="#realtime-dialogue">Realtime Dialogue</a></h3>
<pre><code class="language-go">session, err := client.Realtime.Connect(ctx, &amp;doubaospeech.RealtimeConfig{
    Model: "speech-dialog-001",
})
defer session.Close()

// Send audio
session.SendAudio(audioData)

// Receive events
for event := range session.Events() {
    switch event.Type {
    case "asr_result":
        fmt.Println("User:", event.AsrResult.Text)
    case "tts_audio":
        play(event.TtsAudio)
    }
}
</code></pre>
<h3 id="console-api"><a class="header" href="#console-api">Console API</a></h3>
<pre><code class="language-go">// List available voices
voices, err := console.ListSpeakers(ctx, &amp;doubaospeech.ListSpeakersRequest{})

// List timbres
timbres, err := console.ListTimbres(ctx, &amp;doubaospeech.ListTimbresRequest{})

// Check voice clone status
status, err := console.ListVoiceCloneStatus(ctx, &amp;doubaospeech.ListVoiceCloneStatusRequest{
    VoiceID: "my-custom-voice",
})
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>WithAPIKey(key)</code></td><td>x-api-key authentication</td></tr>
<tr><td><code>WithBearerToken(token)</code></td><td>Bearer token authentication</td></tr>
<tr><td><code>WithV2APIKey(access, app)</code></td><td>V2/V3 API authentication</td></tr>
<tr><td><code>WithCluster(cluster)</code></td><td>Set cluster name (V1)</td></tr>
<tr><td><code>WithResourceID(id)</code></td><td>Set resource ID (V2)</td></tr>
<tr><td><code>WithBaseURL(url)</code></td><td>Custom HTTP base URL</td></tr>
<tr><td><code>WithWebSocketURL(url)</code></td><td>Custom WebSocket URL</td></tr>
<tr><td><code>WithHTTPClient(client)</code></td><td>Custom HTTP client</td></tr>
<tr><td><code>WithTimeout(duration)</code></td><td>Request timeout</td></tr>
<tr><td><code>WithUserID(id)</code></td><td>User identifier</td></tr>
</tbody></table>
</div>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<pre><code class="language-go">if err != nil {
    if e, ok := doubaospeech.AsError(err); ok {
        fmt.Printf("Error %d: %s\n", e.Code, e.Message)
        if e.IsRateLimit() {
            // Handle rate limiting
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doubao-speech-sdk---rust-implementation"><a class="header" href="#doubao-speech-sdk---rust-implementation">Doubao Speech SDK - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-doubaospeech</code></p>
<h2 id="clients-1"><a class="header" href="#clients-1">Clients</a></h2>
<h3 id="speech-api-client-2"><a class="header" href="#speech-api-client-2">Speech API Client</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Client {
    // Internal HTTP/WebSocket clients
}

impl Client {
    pub fn tts(&amp;self) -&gt; TtsService;
    pub fn asr(&amp;self) -&gt; AsrService;
    pub fn voice_clone(&amp;self) -&gt; VoiceCloneService;
    pub fn realtime(&amp;self) -&gt; RealtimeService;
    pub fn meeting(&amp;self) -&gt; MeetingService;
    pub fn podcast(&amp;self) -&gt; PodcastService;
    pub fn translation(&amp;self) -&gt; TranslationService;
    pub fn media(&amp;self) -&gt; MediaService;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Constructor:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::Client;

// With API Key (recommended)
let client = Client::builder("app-id")
    .api_key("your-api-key")
    .cluster("volcano_tts")
    .build()?;

// With Bearer Token
let client = Client::builder("app-id")
    .bearer_token("your-token")
    .build()?;

// With V2 API Key
let client = Client::builder("app-id")
    .v2_api_key("access-key", "app-key")
    .resource_id("seed-tts-2.0")
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="console-client-1"><a class="header" href="#console-client-1">Console Client</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::Console;

let console = Console::new("access-key", "secret-key");
<span class="boring">}</span></code></pre></pre>
<h2 id="services-4"><a class="header" href="#services-4">Services</a></h2>
<h3 id="tts-service"><a class="header" href="#tts-service">TTS Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::{TtsRequest, TtsService};

// Synchronous
let response = client.tts().synthesize(&amp;TtsRequest {
    text: "ä½ å¥½ï¼Œä¸–ç•Œï¼".to_string(),
    voice_type: "zh_female_cancan".to_string(),
    ..Default::default()
}).await?;
// response.audio contains bytes

// Streaming
let stream = client.tts().synthesize_stream(&amp;req).await?;
while let Some(chunk) = stream.next().await {
    let chunk = chunk?;
    if let Some(audio) = chunk.audio {
        buf.extend(&amp;audio);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="asr-service"><a class="header" href="#asr-service">ASR Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::{OneSentenceRequest, StreamAsrConfig};

// One-sentence
let result = client.asr().recognize(&amp;OneSentenceRequest {
    audio: audio_data,
    format: "pcm".to_string(),
    language: "zh-CN".to_string(),
    ..Default::default()
}).await?;

// Streaming
let session = client.asr().open_stream_session(&amp;StreamAsrConfig {
    format: "pcm".to_string(),
    sample_rate: 16000,
    ..Default::default()
}).await?;

// Send audio
session.send_audio(&amp;audio_data, false).await?;
session.send_audio(&amp;last_data, true).await?;

// Receive results
while let Some(result) = session.recv().await {
    let chunk = result?;
    println!("Text: {}", chunk.text);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="voice-clone-service"><a class="header" href="#voice-clone-service">Voice Clone Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Upload for training
let result = client.voice_clone().upload(&amp;VoiceCloneTrainRequest {
    audio_data: audio_bytes,
    voice_id: "my-custom-voice".to_string(),
    ..Default::default()
}).await?;

// Check status
let status = client.voice_clone().get_status("my-custom-voice").await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="realtime-service"><a class="header" href="#realtime-service">Realtime Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::{RealtimeConfig, RealtimeEventType};

let session = client.realtime().connect(&amp;RealtimeConfig {
    model: "speech-dialog-001".to_string(),
    ..Default::default()
}).await?;

// Send audio
session.send_audio(&amp;audio_data).await?;

// Receive events
while let Some(event) = session.recv().await {
    let event = event?;
    match event.event_type {
        RealtimeEventType::AsrResult =&gt; {
            println!("User: {}", event.asr_result.text);
        }
        RealtimeEventType::TtsAudio =&gt; {
            play(&amp;event.tts_audio);
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="console-api-1"><a class="header" href="#console-api-1">Console API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::{Console, ListSpeakersRequest};

let console = Console::new("access-key", "secret-key");

// List speakers
let speakers = console.list_speakers(&amp;ListSpeakersRequest::default()).await?;

// List timbres
let timbres = console.list_timbres(&amp;ListTimbresRequest::default()).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="builder-options"><a class="header" href="#builder-options">Builder Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>api_key(key)</code></td><td>x-api-key authentication</td></tr>
<tr><td><code>bearer_token(token)</code></td><td>Bearer token authentication</td></tr>
<tr><td><code>v2_api_key(access, app)</code></td><td>V2/V3 API authentication</td></tr>
<tr><td><code>cluster(cluster)</code></td><td>Set cluster name (V1)</td></tr>
<tr><td><code>resource_id(id)</code></td><td>Set resource ID (V2)</td></tr>
<tr><td><code>base_url(url)</code></td><td>Custom HTTP base URL</td></tr>
<tr><td><code>ws_url(url)</code></td><td>Custom WebSocket URL</td></tr>
<tr><td><code>timeout(duration)</code></td><td>Request timeout</td></tr>
<tr><td><code>user_id(id)</code></td><td>User identifier</td></tr>
</tbody></table>
</div>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_doubaospeech::{Error, Result};

match client.tts().synthesize(&amp;req).await {
    Ok(resp) =&gt; { /* ... */ }
    Err(Error::Api { code, message }) =&gt; {
        eprintln!("API Error {}: {}", code, message);
    }
    Err(e) =&gt; {
        eprintln!("Error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="differences-from-go-11"><a class="header" href="#differences-from-go-11">Differences from Go</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Go</th><th>Rust</th></tr></thead><tbody>
<tr><td>V1/V2 service access</td><td>Separate fields (TTS, TTSV2)</td><td>Single service with version param</td></tr>
<tr><td>Streaming</td><td><code>iter.Seq2</code></td><td><code>Stream&lt;Item=Result&lt;T&gt;&gt;</code></td></tr>
<tr><td>Session management</td><td>Manual close</td><td>Drop trait</td></tr>
<tr><td>WebSocket</td><td>gorilla/websocket</td><td>tokio-tungstenite</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="doubao-speech-sdk---known-issues"><a class="header" href="#doubao-speech-sdk---known-issues">Doubao Speech SDK - Known Issues</a></h1>
<h2 id="-minor-issues-11"><a class="header" href="#-minor-issues-11">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="dbs-001-go-auth-header-format-unusual"><a class="header" href="#dbs-001-go-auth-header-format-unusual">DBS-001: Go auth header format unusual</a></h3>
<p><strong>File:</strong> <code>go/pkg/doubaospeech/client.go:238-239</code></p>
<p><strong>Description:</strong><br />
Bearer token format is <code>Bearer;{token}</code> instead of standard <code>Bearer {token}</code>:</p>
<pre><code class="language-go">req.Header.Set("Authorization", "Bearer;"+c.config.accessToken)
</code></pre>
<p><strong>Impact:</strong> Non-standard but required by Volcengine API.</p>
<p><strong>Note:</strong> This is API requirement, not SDK issue.</p>
<hr />
<h3 id="dbs-002-multiple-auth-method-complexity"><a class="header" href="#dbs-002-multiple-auth-method-complexity">DBS-002: Multiple auth method complexity</a></h3>
<p><strong>Description:</strong><br />
SDK supports 4+ authentication methods:</p>
<ul>
<li>API Key (<code>x-api-key</code>)</li>
<li>Bearer Token (<code>Authorization: Bearer;</code>)</li>
<li>V2 API Key (<code>X-Api-Access-Key</code>, <code>X-Api-App-Key</code>)</li>
<li>Resource-specific fixed keys</li>
</ul>
<p><strong>Impact:</strong> Confusing for users which method to use for which service.</p>
<p><strong>Suggestion:</strong> Add helper methods like <code>NewTTSClient()</code>, <code>NewRealtimeClient()</code> with correct defaults.</p>
<hr />
<h3 id="dbs-003-resource-id-vs-cluster-confusion"><a class="header" href="#dbs-003-resource-id-vs-cluster-confusion">DBS-003: Resource ID vs Cluster confusion</a></h3>
<p><strong>Description:</strong><br />
V1 uses "cluster", V2 uses "resource_id" for service selection:</p>
<ul>
<li>V1: <code>WithCluster("volcano_tts")</code></li>
<li>V2: <code>WithResourceID("seed-tts-2.0")</code></li>
</ul>
<p><strong>Impact:</strong> Easy to mix up, unclear which to use when.</p>
<hr />
<h3 id="dbs-004-rust-async-tts-incomplete"><a class="header" href="#dbs-004-rust-async-tts-incomplete">DBS-004: Rust async TTS incomplete</a></h3>
<p><strong>Description:</strong><br />
Rust implementation for async long-text TTS may be incomplete or missing compared to Go.</p>
<p><strong>Status:</strong> âš ï¸ Needs verification.</p>
<hr />
<h3 id="dbs-005-rust-file-asr-incomplete"><a class="header" href="#dbs-005-rust-file-asr-incomplete">DBS-005: Rust file ASR incomplete</a></h3>
<p><strong>Description:</strong><br />
Rust implementation for file-based ASR may be incomplete compared to Go.</p>
<p><strong>Status:</strong> âš ï¸ Needs verification.</p>
<hr />
<h3 id="dbs-006-fixed-app-keys-hardcoded"><a class="header" href="#dbs-006-fixed-app-keys-hardcoded">DBS-006: Fixed app keys hardcoded</a></h3>
<p><strong>File:</strong> <code>go/pkg/doubaospeech/client.go:17-24</code></p>
<p><strong>Description:</strong><br />
Some V3 APIs use fixed app keys from documentation:</p>
<pre><code class="language-go">const (
    AppKeyRealtime = "PlgvMymc7f3tQnJ6"
    AppKeyPodcast = "aGjiRDfUWi"
)
</code></pre>
<p><strong>Impact:</strong> If Volcengine changes these, SDK breaks until updated.</p>
<p><strong>Note:</strong> This is documented API behavior.</p>
<hr />
<h2 id="-enhancements-12"><a class="header" href="#-enhancements-12">ğŸ”µ Enhancements</a></h2>
<h3 id="dbs-007-no-automatic-service-version-selection"><a class="header" href="#dbs-007-no-automatic-service-version-selection">DBS-007: No automatic service version selection</a></h3>
<p><strong>Description:</strong><br />
User must manually choose between V1 and V2 services. No automatic selection based on features needed.</p>
<p><strong>Suggestion:</strong> Add unified service that routes to correct version.</p>
<hr />
<h3 id="dbs-008-no-connection-pooling-documentation"><a class="header" href="#dbs-008-no-connection-pooling-documentation">DBS-008: No connection pooling documentation</a></h3>
<p><strong>Description:</strong><br />
WebSocket connections for streaming services could benefit from pooling documentation.</p>
<hr />
<h3 id="dbs-009-no-retry-for-websocket-connections"><a class="header" href="#dbs-009-no-retry-for-websocket-connections">DBS-009: No retry for WebSocket connections</a></h3>
<p><strong>Description:</strong><br />
HTTP requests have retry, but WebSocket connections don't auto-reconnect on failure.</p>
<p><strong>Suggestion:</strong> Add reconnection logic for streaming sessions.</p>
<hr />
<h3 id="dbs-010-console-api-missing-some-endpoints"><a class="header" href="#dbs-010-console-api-missing-some-endpoints">DBS-010: Console API missing some endpoints</a></h3>
<p><strong>Description:</strong><br />
Console client may not cover all management APIs available on Volcengine.</p>
<hr />
<h2 id="-notes-12"><a class="header" href="#-notes-12">âšª Notes</a></h2>
<h3 id="dbs-011-dual-api-version-design"><a class="header" href="#dbs-011-dual-api-version-design">DBS-011: Dual API version design</a></h3>
<p><strong>Description:</strong><br />
Having both V1 (Classic) and V2 (BigModel) services in same client reflects Volcengine's actual API structure. This is intentional, not a flaw.</p>
<hr />
<h3 id="dbs-012-protocol-module-for-websocket"><a class="header" href="#dbs-012-protocol-module-for-websocket">DBS-012: Protocol module for WebSocket</a></h3>
<p><strong>Description:</strong><br />
Both Go and Rust have a <code>protocol</code> module for WebSocket message serialization. This is well-structured for the binary protocol requirements.</p>
<hr />
<h3 id="dbs-013-comprehensive-service-coverage"><a class="header" href="#dbs-013-comprehensive-service-coverage">DBS-013: Comprehensive service coverage</a></h3>
<p><strong>Description:</strong><br />
SDK covers nearly all Doubao Speech services:</p>
<ul>
<li>TTS (sync, stream, async)</li>
<li>ASR (one-sentence, stream, file)</li>
<li>Voice Clone</li>
<li>Realtime Dialogue</li>
<li>Meeting Transcription</li>
<li>Podcast Synthesis</li>
<li>Translation</li>
<li>Media Subtitle</li>
</ul>
<p>This is impressive coverage.</p>
<hr />
<h3 id="dbs-014-console-uses-aksk-signature"><a class="header" href="#dbs-014-console-uses-aksk-signature">DBS-014: Console uses AK/SK signature</a></h3>
<p><strong>Description:</strong><br />
Console API uses Volcengine OpenAPI signature (HMAC-SHA256), not simple token. This is standard for Volcengine management APIs.</p>
<hr />
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>DBS-001</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Go Auth</td></tr>
<tr><td>DBS-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>DBS-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Both</td></tr>
<tr><td>DBS-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust</td></tr>
<tr><td>DBS-005</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust</td></tr>
<tr><td>DBS-006</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Both</td></tr>
<tr><td>DBS-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DBS-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DBS-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DBS-010</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>DBS-011</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>DBS-012</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>DBS-013</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>DBS-014</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Comprehensive SDK with excellent API coverage. Main complexity is from Volcengine's dual API version system and multiple authentication methods. Rust implementation may have some gaps compared to Go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è±†åŒ…è¯­éŸ³doubao-speechapi-æ–‡æ¡£"><a class="header" href="#è±†åŒ…è¯­éŸ³doubao-speechapi-æ–‡æ¡£">è±†åŒ…è¯­éŸ³ï¼ˆDoubao Speechï¼‰API æ–‡æ¡£</a></h1>
<h2 id="åŸå§‹æ–‡æ¡£-1"><a class="header" href="#åŸå§‹æ–‡æ¡£-1">åŸå§‹æ–‡æ¡£</a></h2>
<ul>
<li><strong>æ–‡æ¡£é¦–é¡µ</strong>: https://www.volcengine.com/docs/6561/162929</li>
<li><strong>æ§åˆ¶å°</strong>: https://console.volcengine.com/speech/app</li>
</ul>
<blockquote>
<p>å¦‚æœæœ¬æ–‡æ¡£ä¿¡æ¯ä¸å®Œæ•´ï¼Œè¯·è®¿é—®ä¸Šè¿°é“¾æ¥è·å–æœ€æ–°å†…å®¹ã€‚</p>
</blockquote>
<h2 id="äº§å“ä½“ç³»"><a class="header" href="#äº§å“ä½“ç³»">äº§å“ä½“ç³»</a></h2>
<p>è±†åŒ…è¯­éŸ³åˆ†ä¸ºä¸¤ä»£äº§å“ï¼š<strong>å¤§æ¨¡å‹ç‰ˆï¼ˆ2.0ï¼‰</strong> å’Œ <strong>ç»å…¸ç‰ˆï¼ˆ1.0ï¼‰</strong>ã€‚æ¨èä½¿ç”¨å¤§æ¨¡å‹ç‰ˆã€‚</p>
<hr />
<h2 id="è¯­éŸ³åˆæˆtts"><a class="header" href="#è¯­éŸ³åˆæˆtts">è¯­éŸ³åˆæˆï¼ˆTTSï¼‰</a></h2>
<h3 id="å¤§æ¨¡å‹è¯­éŸ³åˆæˆ-20"><a class="header" href="#å¤§æ¨¡å‹è¯­éŸ³åˆæˆ-20">å¤§æ¨¡å‹è¯­éŸ³åˆæˆ 2.0</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Resource ID</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>å•å‘æµå¼ HTTP V3</td><td><code>POST /api/v3/tts/unidirectional</code></td><td><code>seed-tts-2.0</code></td><td><a href="lib/doubaospeech/api/./tts2.0/stream-http.html">stream-http.md</a></td></tr>
<tr><td>å•å‘æµå¼ WebSocket V3</td><td><code>WSS /api/v3/tts/unidirectional</code></td><td><code>seed-tts-2.0</code></td><td><a href="lib/doubaospeech/api/./tts2.0/stream-ws.html">stream-ws.md</a></td></tr>
<tr><td>åŒå‘æµå¼ WebSocket V3</td><td><code>WSS /api/v3/tts/bidirection</code></td><td><code>seed-tts-2.0</code></td><td><a href="lib/doubaospeech/api/./tts2.0/duplex-ws.html">duplex-ws.md</a></td></tr>
<tr><td>å¼‚æ­¥é•¿æ–‡æœ¬</td><td><code>POST /api/v3/tts/async/submit</code></td><td><code>seed-tts-2.0-concurr</code></td><td><a href="lib/doubaospeech/api/./tts2.0/async.html">async.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1598757 (å•å‘æµå¼HTTP-V3)</li>
<li>https://www.volcengine.com/docs/6561/1719100 (å•å‘æµå¼WebSocket-V3)</li>
<li>https://www.volcengine.com/docs/6561/1329505 (åŒå‘æµå¼WebSocket-V3)</li>
<li>https://www.volcengine.com/docs/6561/1330194 (å¼‚æ­¥é•¿æ–‡æœ¬)</li>
</ul>
<h3 id="ç»å…¸ç‰ˆè¯­éŸ³åˆæˆ-10"><a class="header" href="#ç»å…¸ç‰ˆè¯­éŸ³åˆæˆ-10">ç»å…¸ç‰ˆè¯­éŸ³åˆæˆ 1.0</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Cluster</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>HTTP ä¸€æ¬¡æ€§åˆæˆ</td><td><code>POST /api/v1/tts</code></td><td><code>volcano_tts</code></td><td><a href="lib/doubaospeech/api/./tts1.0/http.html">http.md</a></td></tr>
<tr><td>WebSocket æµå¼</td><td><code>WSS /api/v1/tts/ws_binary</code></td><td><code>volcano_tts</code></td><td><a href="lib/doubaospeech/api/./tts1.0/websocket.html">websocket.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/79820 (HTTPæ¥å£)</li>
<li>https://www.volcengine.com/docs/6561/79821 (WebSocketæ¥å£)</li>
<li>https://www.volcengine.com/docs/6561/97465 (å‚æ•°è¯´æ˜)</li>
</ul>
<h3 id="ç²¾å“é•¿æ–‡æœ¬è¯­éŸ³åˆæˆ"><a class="header" href="#ç²¾å“é•¿æ–‡æœ¬è¯­éŸ³åˆæˆ">ç²¾å“é•¿æ–‡æœ¬è¯­éŸ³åˆæˆ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>å¼‚æ­¥é•¿æ–‡æœ¬</td><td><code>POST /api/v1/long_tts/submit</code></td><td><a href="lib/doubaospeech/api/./tts1.0/long-tts.html">long-tts.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1096680</li>
</ul>
<hr />
<h2 id="è¯­éŸ³è¯†åˆ«asr"><a class="header" href="#è¯­éŸ³è¯†åˆ«asr">è¯­éŸ³è¯†åˆ«ï¼ˆASRï¼‰</a></h2>
<h3 id="å¤§æ¨¡å‹è¯­éŸ³è¯†åˆ«-20"><a class="header" href="#å¤§æ¨¡å‹è¯­éŸ³è¯†åˆ«-20">å¤§æ¨¡å‹è¯­éŸ³è¯†åˆ« 2.0</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Resource ID</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>æµå¼è¯†åˆ« WebSocket</td><td><code>WSS /api/v3/sauc/bigmodel</code></td><td><code>volc.bigasr.sauc.duration</code></td><td><a href="lib/doubaospeech/api/./asr2.0/streaming.html">streaming.md</a></td></tr>
<tr><td>å½•éŸ³æ–‡ä»¶è¯†åˆ«ï¼ˆæ ‡å‡†ç‰ˆï¼‰</td><td><code>POST /api/v3/asr/bigmodel/submit</code></td><td><code>volc.bigasr.auc.duration</code></td><td><a href="lib/doubaospeech/api/./asr2.0/file-standard.html">file-standard.md</a></td></tr>
<tr><td>å½•éŸ³æ–‡ä»¶è¯†åˆ«ï¼ˆæé€Ÿç‰ˆï¼‰</td><td><code>POST /api/v3/asr/bigmodel_async/submit</code></td><td><code>volc.bigasr.auc.duration</code></td><td><a href="lib/doubaospeech/api/./asr2.0/file-fast.html">file-fast.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1354869 (å¤§æ¨¡å‹æµå¼è¯­éŸ³è¯†åˆ«)</li>
<li>https://www.volcengine.com/docs/6561/1354868 (å¤§æ¨¡å‹å½•éŸ³æ–‡ä»¶è¯†åˆ«æ ‡å‡†ç‰ˆ)</li>
<li>https://www.volcengine.com/docs/6561/1631584 (å¤§æ¨¡å‹å½•éŸ³æ–‡ä»¶æé€Ÿç‰ˆ)</li>
<li>https://www.volcengine.com/docs/6561/1840838 (å¤§æ¨¡å‹å½•éŸ³æ–‡ä»¶é—²æ—¶ç‰ˆ)</li>
</ul>
<h3 id="ç»å…¸ç‰ˆè¯­éŸ³è¯†åˆ«-10"><a class="header" href="#ç»å…¸ç‰ˆè¯­éŸ³è¯†åˆ«-10">ç»å…¸ç‰ˆè¯­éŸ³è¯†åˆ« 1.0</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Cluster</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>ä¸€å¥è¯è¯†åˆ«</td><td><code>POST /api/v1/asr</code></td><td><code>volcengine_input_common</code></td><td><a href="lib/doubaospeech/api/./asr1.0/one-sentence.html">one-sentence.md</a></td></tr>
<tr><td>æµå¼è¯†åˆ«</td><td><code>WSS /api/v2/asr</code></td><td><code>volcengine_streaming_common</code></td><td><a href="lib/doubaospeech/api/./asr1.0/streaming.html">streaming.md</a></td></tr>
<tr><td>å½•éŸ³æ–‡ä»¶æ ‡å‡†ç‰ˆ</td><td><code>POST /api/v1/asr/submit</code></td><td><code>volc.megatts.default</code></td><td><a href="lib/doubaospeech/api/./asr1.0/file-standard.html">file-standard.md</a></td></tr>
<tr><td>å½•éŸ³æ–‡ä»¶æé€Ÿç‰ˆ</td><td><code>POST /api/v1/asr/async/submit</code></td><td><code>volc.megatts.default</code></td><td><a href="lib/doubaospeech/api/./asr1.0/file-fast.html">file-fast.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/104897 (ä¸€å¥è¯è¯†åˆ«)</li>
<li>https://www.volcengine.com/docs/6561/80816 (æµå¼è¯­éŸ³è¯†åˆ«)</li>
<li>https://www.volcengine.com/docs/6561/80818 (å½•éŸ³æ–‡ä»¶è¯†åˆ«æ ‡å‡†ç‰ˆ)</li>
<li>https://www.volcengine.com/docs/6561/80820 (å½•éŸ³æ–‡ä»¶è¯†åˆ«æé€Ÿç‰ˆ)</li>
</ul>
<hr />
<h2 id="å£°éŸ³å¤åˆ»"><a class="header" href="#å£°éŸ³å¤åˆ»">å£°éŸ³å¤åˆ»</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Cluster</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>è®­ç»ƒæäº¤</td><td><code>POST /api/v1/mega_tts/audio/upload</code></td><td><code>volcano_icl</code></td><td><a href="lib/doubaospeech/api/./voice-clone/api.html">api.md</a></td></tr>
<tr><td>çŠ¶æ€æŸ¥è¯¢</td><td><code>POST /api/v1/mega_tts/status</code></td><td><code>volcano_icl</code></td><td><a href="lib/doubaospeech/api/./voice-clone/api.html">api.md</a></td></tr>
<tr><td>æ¿€æ´»éŸ³è‰²</td><td><code>POST /api/v1/mega_tts/audio/activate</code></td><td><code>volcano_icl</code></td><td><a href="lib/doubaospeech/api/./voice-clone/api.html">api.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1305191 (å£°éŸ³å¤åˆ»API)</li>
<li>https://www.volcengine.com/docs/6561/1829010 (å£°éŸ³å¤åˆ»ä¸‹å•åŠä½¿ç”¨æŒ‡å—)</li>
</ul>
<hr />
<h2 id="å®æ—¶è¯­éŸ³å¤§æ¨¡å‹"><a class="header" href="#å®æ—¶è¯­éŸ³å¤§æ¨¡å‹">å®æ—¶è¯­éŸ³å¤§æ¨¡å‹</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Resource ID</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>å®æ—¶å¯¹è¯</td><td><code>WSS /api/v3/realtime/dialogue</code></td><td><code>volc.speech.dialog</code></td><td><a href="lib/doubaospeech/api/./realtime/api.html">api.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1257584 (ç«¯åˆ°ç«¯å®æ—¶è¯­éŸ³å¤§æ¨¡å‹API)</li>
</ul>
<hr />
<h2 id="æ’­å®¢åˆæˆ"><a class="header" href="#æ’­å®¢åˆæˆ">æ’­å®¢åˆæˆ</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Resource ID</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>WebSocket V3</td><td><code>WSS /api/v3/sami/podcasttts</code></td><td><code>volc.megatts.podcast</code></td><td><a href="lib/doubaospeech/api/./podcast/api.html">api.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1668014 (æ’­å®¢API-websocket-v3åè®®)</li>
</ul>
<hr />
<h2 id="åŒå£°ä¼ è¯‘"><a class="header" href="#åŒå£°ä¼ è¯‘">åŒå£°ä¼ è¯‘</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>Resource ID</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>WebSocket V3</td><td><code>WSS /api/v3/saas/simt</code></td><td><code>volc.megatts.simt</code></td><td><a href="lib/doubaospeech/api/./translation/api.html">api.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/xxx (åŒå£°ä¼ è¯‘2.0-API)</li>
</ul>
<hr />
<h2 id="è¯­éŸ³å¦™è®°ä¼šè®®çºªè¦"><a class="header" href="#è¯­éŸ³å¦™è®°ä¼šè®®çºªè¦">è¯­éŸ³å¦™è®°ï¼ˆä¼šè®®çºªè¦ï¼‰</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>å¼‚æ­¥æäº¤</td><td><code>POST /api/v1/meeting/submit</code></td><td><a href="lib/doubaospeech/api/./meeting/api.html">api.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/xxx (è±†åŒ…è¯­éŸ³å¦™è®°-API)</li>
</ul>
<hr />
<h2 id="éŸ³è§†é¢‘å­—å¹•"><a class="header" href="#éŸ³è§†é¢‘å­—å¹•">éŸ³è§†é¢‘å­—å¹•</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>å­—å¹•ç”Ÿæˆ</td><td><code>POST /api/v1/subtitle/submit</code></td><td><a href="lib/doubaospeech/api/./media/subtitle.html">subtitle.md</a></td></tr>
<tr><td>å­—å¹•æ‰“è½´</td><td><code>POST /api/v1/subtitle/align</code></td><td><a href="lib/doubaospeech/api/./media/align.html">align.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/192519 (éŸ³è§†é¢‘å­—å¹•ç”Ÿæˆ)</li>
<li>https://www.volcengine.com/docs/6561/113635 (è‡ªåŠ¨å­—å¹•æ‰“è½´)</li>
</ul>
<hr />
<h2 id="æ§åˆ¶å°ç®¡ç†-api"><a class="header" href="#æ§åˆ¶å°ç®¡ç†-api">æ§åˆ¶å°ç®¡ç† API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¥å£</th><th>ç«¯ç‚¹</th><th>è®¤è¯æ–¹å¼</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>å¤§æ¨¡å‹éŸ³è‰²åˆ—è¡¨</td><td><code>POST /ListBigModelTTSTimbres</code></td><td>AK/SK</td><td><a href="lib/doubaospeech/api/./console-api/timbre.html">timbre.md</a></td></tr>
<tr><td>å¤§æ¨¡å‹éŸ³è‰²åˆ—è¡¨(æ–°)</td><td><code>POST /ListSpeakers</code></td><td>AK/SK</td><td><a href="lib/doubaospeech/api/./console-api/timbre.html">timbre.md</a></td></tr>
<tr><td>API Key ç®¡ç†</td><td><code>POST /ListAPIKeys</code></td><td>AK/SK</td><td><a href="lib/doubaospeech/api/./console-api/apikey.html">apikey.md</a></td></tr>
<tr><td>æœåŠ¡çŠ¶æ€ç®¡ç†</td><td><code>POST /ServiceStatus</code></td><td>AK/SK</td><td><a href="lib/doubaospeech/api/./console-api/service.html">service.md</a></td></tr>
<tr><td>é…é¢ç›‘æ§</td><td><code>POST /QuotaMonitoring</code></td><td>AK/SK</td><td><a href="lib/doubaospeech/api/./console-api/monitoring.html">monitoring.md</a></td></tr>
<tr><td>å£°éŸ³å¤åˆ»çŠ¶æ€</td><td><code>POST /ListMegaTTSTrainStatus</code></td><td>AK/SK</td><td><a href="lib/doubaospeech/api/./console-api/voice-clone-status.html">voice-clone-status.md</a></td></tr>
</tbody></table>
</div>
<p><strong>åŸå§‹æ–‡æ¡£é“¾æ¥ï¼š</strong></p>
<ul>
<li>https://www.volcengine.com/docs/6561/1770994 (ListBigModelTTSTimbres)</li>
<li>https://www.volcengine.com/docs/6561/2160690 (ListSpeakers)</li>
</ul>
<hr />
<h2 id="è®¤è¯æ–¹å¼-1"><a class="header" href="#è®¤è¯æ–¹å¼-1">è®¤è¯æ–¹å¼</a></h2>
<h3 id="speech-apiè¯­éŸ³æœåŠ¡"><a class="header" href="#speech-apiè¯­éŸ³æœåŠ¡">Speech APIï¼ˆè¯­éŸ³æœåŠ¡ï¼‰</a></h3>
<p>è¯­éŸ³æœåŠ¡ä½¿ç”¨ä»¥ä¸‹è®¤è¯æ–¹å¼ï¼š</p>
<div class="table-wrapper"><table><thead><tr><th>è®¤è¯æ–¹å¼</th><th>Header</th><th>é€‚ç”¨åœºæ™¯</th></tr></thead><tbody>
<tr><td>Access Token</td><td><code>Authorization: Bearer; {token}</code></td><td>HTTP/WebSocket V1-V2</td></tr>
<tr><td>X-Api è®¤è¯</td><td><code>X-Api-App-Id</code>, <code>X-Api-Access-Key</code></td><td>WebSocket V3</td></tr>
<tr><td>Request Body</td><td><code>app.token</code></td><td>éƒ¨åˆ† HTTP æ¥å£</td></tr>
</tbody></table>
</div>
<h3 id="console-apiæ§åˆ¶å°æœåŠ¡"><a class="header" href="#console-apiæ§åˆ¶å°æœåŠ¡">Console APIï¼ˆæ§åˆ¶å°æœåŠ¡ï¼‰</a></h3>
<p>æ§åˆ¶å° API ä½¿ç”¨ <strong>Volcengine OpenAPI AK/SK ç­¾åè®¤è¯</strong>ï¼š</p>
<pre><code>Authorization: HMAC-SHA256 Credential={AccessKeyId}/...
</code></pre>
<p>è¯¦è§ <a href="lib/doubaospeech/api/./auth.html">auth.md</a></p>
<hr />
<h2 id="å¿«é€Ÿé€‰æ‹©"><a class="header" href="#å¿«é€Ÿé€‰æ‹©">å¿«é€Ÿé€‰æ‹©</a></h2>
<div class="table-wrapper"><table><thead><tr><th>éœ€æ±‚</th><th>æ¨èæ¥å£</th><th>æ–‡æ¡£</th></tr></thead><tbody>
<tr><td>çŸ­æ–‡æœ¬å®æ—¶åˆæˆ</td><td>TTS 2.0 å•å‘æµå¼ HTTP V3</td><td><a href="lib/doubaospeech/api/./tts2.0/stream-http.html">stream-http.md</a></td></tr>
<tr><td>é•¿æ–‡æœ¬æ‰¹é‡åˆæˆ</td><td>TTS 2.0 å¼‚æ­¥æ¥å£</td><td><a href="lib/doubaospeech/api/./tts2.0/async.html">async.md</a></td></tr>
<tr><td>å®æ—¶è¯­éŸ³äº¤äº’</td><td>å®æ—¶å¯¹è¯ API</td><td><a href="lib/doubaospeech/api/./realtime/api.html">realtime/api.md</a></td></tr>
<tr><td>å®šåˆ¶éŸ³è‰²</td><td>å£°éŸ³å¤åˆ» API</td><td><a href="lib/doubaospeech/api/./voice-clone/api.html">voice-clone/api.md</a></td></tr>
<tr><td>å®æ—¶è¯­éŸ³è¯†åˆ«</td><td>ASR 2.0 æµå¼</td><td><a href="lib/doubaospeech/api/./asr2.0/streaming.html">asr2.0/streaming.md</a></td></tr>
<tr><td>å½•éŸ³æ–‡ä»¶è½¬å†™</td><td>ASR 2.0 æ–‡ä»¶è¯†åˆ«</td><td><a href="lib/doubaospeech/api/./asr2.0/file-standard.html">asr2.0/file-standard.md</a></td></tr>
<tr><td>æ’­å®¢ç”Ÿæˆ</td><td>æ’­å®¢ API</td><td><a href="lib/doubaospeech/api/./podcast/api.html">podcast/api.md</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="jiutian-api-documentation"><a class="header" href="#jiutian-api-documentation">Jiutian API Documentation</a></h1>
<p>ä¹å¤©å¤§æ¨¡å‹ (Jiutian) - China Mobile's AI Service Platform.</p>
<blockquote>
<p><strong>Official API Documentation</strong>: <a href="lib/jiutian/./api/README.html">api/README.md</a></p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Jiutian is China Mobile's terminal intelligent agent service management platform for AI/LLM cloud integration.</p>
<p><strong>Note:</strong> This is API documentation only. No Go/Rust SDK implementation exists in this repository.</p>
<h2 id="api-features"><a class="header" href="#api-features">API Features</a></h2>
<ul>
<li><strong>Chat Completions</strong>: OpenAI-compatible chat API</li>
<li><strong>Device Integration</strong>: Device registration and heartbeat protocols</li>
<li><strong>Assistant Management</strong>: Configure AI assistants</li>
</ul>
<h2 id="integration-notes"><a class="header" href="#integration-notes">Integration Notes</a></h2>
<p>For integration with Jiutian API:</p>
<ol>
<li>Use OpenAI-compatible SDK with custom base URL</li>
<li>Follow device authentication protocols</li>
<li>See <a href="lib/jiutian/./api/tutorial.html">api/tutorial.md</a> for quick start</li>
</ol>
<h2 id="authentication-2"><a class="header" href="#authentication-2">Authentication</a></h2>
<p>Requires:</p>
<ul>
<li>AI Token (obtained via email application)</li>
<li>IP whitelist registration</li>
<li>Product ID from management platform</li>
</ul>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Environment</th><th>URL</th></tr></thead><tbody>
<tr><td>Test</td><td><code>https://z5f3vhk2.cxzfdm.com:30101</code></td></tr>
<tr><td>Production</td><td><code>https://ivs.chinamobiledevice.com:30100</code></td></tr>
</tbody></table>
</div>
<h2 id="sdk-implementation-status"><a class="header" href="#sdk-implementation-status">SDK Implementation Status</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th>Status</th></tr></thead><tbody>
<tr><td>Go</td><td>âŒ Not implemented</td></tr>
<tr><td>Rust</td><td>âŒ Not implemented</td></tr>
</tbody></table>
</div>
<p>For basic integration, use OpenAI-compatible SDK:</p>
<p><strong>Go:</strong></p>
<pre><code class="language-go">config := openai.DefaultConfig(jiutianToken)
config.BaseURL = "https://ivs.chinamobiledevice.com:30100/v1"
client := openai.NewClientWithConfig(config)
</code></pre>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="lib/jiutian/./api/tutorial.html">Quick Start Tutorial</a></li>
<li><a href="lib/jiutian/./api/concepts.html">Concepts &amp; Terms</a></li>
<li><a href="lib/jiutian/./api/auth.html">Authentication</a></li>
<li><a href="lib/jiutian/./api/chat.html">Chat API</a></li>
<li><a href="lib/jiutian/./api/device.html">Device Protocol</a></li>
<li><a href="lib/jiutian/./api/faq.html">FAQ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jiutian---go-implementation"><a class="header" href="#jiutian---go-implementation">Jiutian - Go Implementation</a></h1>
<h2 id="status-not-implemented"><a class="header" href="#status-not-implemented">Status: Not Implemented</a></h2>
<p>No native Go SDK for Jiutian API exists in this repository.</p>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Use OpenAI-compatible SDK since Jiutian API follows OpenAI chat completions format:</p>
<pre><code class="language-go">import "github.com/sashabaranov/go-openai"

config := openai.DefaultConfig("sk-your-jiutian-token")
config.BaseURL = "https://ivs.chinamobiledevice.com:30100/v1"

client := openai.NewClientWithConfig(config)

resp, err := client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
    Model: "jiutian",
    Messages: []openai.ChatCompletionMessage{
        {
            Role:    "system",
            Content: "æ‚¨å¥½ï¼Œæˆ‘æ˜¯ä¸­å›½ç§»åŠ¨çš„æ™ºèƒ½åŠ©ç†çµçŠ€ã€‚",
        },
        {
            Role:    "user", 
            Content: "ä½ æ˜¯è°ï¼Ÿ",
        },
    },
})
</code></pre>
<h2 id="device-protocol"><a class="header" href="#device-protocol">Device Protocol</a></h2>
<p>For device-specific features (registration, heartbeat), implement HTTP client directly:</p>
<pre><code class="language-go">// Device heartbeat
type HeartbeatRequest struct {
    DeviceID  string `json:"device_id"`
    ProductID string `json:"product_id"`
    Timestamp int64  `json:"timestamp"`
}

func sendHeartbeat(ctx context.Context, client *http.Client, req *HeartbeatRequest) error {
    // POST to /api/device/heartbeat
}
</code></pre>
<h2 id="future-work"><a class="header" href="#future-work">Future Work</a></h2>
<p>A native SDK could provide:</p>
<ul>
<li>Device registration/heartbeat management</li>
<li>Token refresh handling</li>
<li>Jiutian-specific features</li>
</ul>
<p>See <a href="lib/jiutian/./api/device.html">api/device.md</a> for device protocol details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jiutian---rust-implementation"><a class="header" href="#jiutian---rust-implementation">Jiutian - Rust Implementation</a></h1>
<h2 id="status-not-implemented-1"><a class="header" href="#status-not-implemented-1">Status: Not Implemented</a></h2>
<p>No native Rust SDK for Jiutian API exists in this repository.</p>
<h2 id="recommendation-1"><a class="header" href="#recommendation-1">Recommendation</a></h2>
<p>Use OpenAI-compatible SDK since Jiutian API follows OpenAI chat completions format:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_openai::{Client, config::OpenAIConfig};

let config = OpenAIConfig::new()
    .with_api_key("sk-your-jiutian-token")
    .with_api_base("https://ivs.chinamobiledevice.com:30100/v1");

let client = Client::with_config(config);

let request = CreateChatCompletionRequestArgs::default()
    .model("jiutian")
    .messages([
        ChatCompletionRequestMessage::System(
            ChatCompletionRequestSystemMessageArgs::default()
                .content("æ‚¨å¥½ï¼Œæˆ‘æ˜¯ä¸­å›½ç§»åŠ¨çš„æ™ºèƒ½åŠ©ç†çµçŠ€ã€‚")
                .build()?
        ),
        ChatCompletionRequestMessage::User(
            ChatCompletionRequestUserMessageArgs::default()
                .content("ä½ æ˜¯è°ï¼Ÿ")
                .build()?
        ),
    ])
    .build()?;

let response = client.chat().create(request).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="device-protocol-1"><a class="header" href="#device-protocol-1">Device Protocol</a></h2>
<p>For device-specific features, implement HTTP client using <code>reqwest</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Serialize)]
struct HeartbeatRequest {
    device_id: String,
    product_id: String,
    timestamp: i64,
}

async fn send_heartbeat(
    client: &amp;reqwest::Client,
    base_url: &amp;str,
    req: &amp;HeartbeatRequest,
) -&gt; Result&lt;(), Error&gt; {
    client
        .post(format!("{}/api/device/heartbeat", base_url))
        .json(req)
        .send()
        .await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="future-work-1"><a class="header" href="#future-work-1">Future Work</a></h2>
<p>A native SDK could provide:</p>
<ul>
<li>Device registration/heartbeat management</li>
<li>Token refresh handling</li>
<li>Jiutian-specific features</li>
</ul>
<p>See <a href="lib/jiutian/./api/device.html">api/device.md</a> for device protocol details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jiutian---known-issues"><a class="header" href="#jiutian---known-issues">Jiutian - Known Issues</a></h1>
<h2 id="-major-issues-3"><a class="header" href="#-major-issues-3">ğŸ”´ Major Issues</a></h2>
<h3 id="jt-001-no-sdk-implementation"><a class="header" href="#jt-001-no-sdk-implementation">JT-001: No SDK implementation</a></h3>
<p><strong>Description:</strong><br />
No Go or Rust SDK implementation exists for Jiutian API.</p>
<p><strong>Impact:</strong> Users must use OpenAI-compatible SDK or implement HTTP calls directly.</p>
<p><strong>Recommendation:</strong></p>
<ol>
<li>For chat completions: Use OpenAI SDK with custom base URL</li>
<li>For device features: Implement direct HTTP calls</li>
</ol>
<hr />
<h2 id="-enhancements-13"><a class="header" href="#-enhancements-13">ğŸ”µ Enhancements</a></h2>
<h3 id="jt-002-native-sdk-desired"><a class="header" href="#jt-002-native-sdk-desired">JT-002: Native SDK desired</a></h3>
<p><strong>Description:</strong><br />
A native SDK would be useful for:</p>
<ul>
<li>Device registration/heartbeat protocols</li>
<li>Token management</li>
<li>Jiutian-specific error handling</li>
</ul>
<p><strong>Priority:</strong> Low - OpenAI SDK covers main use case.</p>
<hr />
<h3 id="jt-003-device-protocol-documentation-only"><a class="header" href="#jt-003-device-protocol-documentation-only">JT-003: Device protocol documentation only</a></h3>
<p><strong>Description:</strong><br />
Device registration and heartbeat protocols are documented but not implemented.</p>
<p><strong>Files affected:</strong></p>
<ul>
<li><a href="lib/jiutian/./api/device.html">api/device.md</a></li>
</ul>
<hr />
<h2 id="-notes-13"><a class="header" href="#-notes-13">âšª Notes</a></h2>
<h3 id="jt-004-openai-compatible-api"><a class="header" href="#jt-004-openai-compatible-api">JT-004: OpenAI-compatible API</a></h3>
<p><strong>Description:</strong><br />
Jiutian chat API is OpenAI-compatible, so existing OpenAI SDKs work:</p>
<ul>
<li>Go: <code>github.com/sashabaranov/go-openai</code></li>
<li>Rust: <code>async-openai</code></li>
<li>Python: <code>openai</code></li>
</ul>
<p>Just set custom base URL and use Jiutian token.</p>
<hr />
<h3 id="jt-005-access-requirements"><a class="header" href="#jt-005-access-requirements">JT-005: Access requirements</a></h3>
<p><strong>Description:</strong><br />
Jiutian API requires:</p>
<ol>
<li>IP whitelist registration</li>
<li>Product ID from management platform</li>
<li>AI token (obtained via email application)</li>
</ol>
<p>This is documented in <a href="lib/jiutian/./api/README.html">api/README.md</a>.</p>
<hr />
<h3 id="jt-006-china-mobile-specific"><a class="header" href="#jt-006-china-mobile-specific">JT-006: China Mobile specific</a></h3>
<p><strong>Description:</strong><br />
This API is specific to China Mobile's terminal intelligent agent service management platform. May not be relevant for all users of this repository.</p>
<hr />
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>JT-001</td><td>ğŸ”´ Major</td><td>Open</td><td>Both</td></tr>
<tr><td>JT-002</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>JT-003</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>JT-004</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>JT-005</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
<tr><td>JT-006</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Documentation-only module without SDK implementation. OpenAI-compatible SDK recommended for chat functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä¹å¤©å¤§æ¨¡å‹-api-æ–‡æ¡£"><a class="header" href="#ä¹å¤©å¤§æ¨¡å‹-api-æ–‡æ¡£">ä¹å¤©å¤§æ¨¡å‹ API æ–‡æ¡£</a></h1>
<p>ç»ˆç«¯æ™ºèƒ½ä½“æœåŠ¡ç®¡ç†å¹³å° AI å¤§æ¨¡å‹äº‘äº‘å¯¹æ¥æ–‡æ¡£</p>
<h2 id="æ–‡æ¡£ç´¢å¼•"><a class="header" href="#æ–‡æ¡£ç´¢å¼•">æ–‡æ¡£ç´¢å¼•</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ–‡æ¡£</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td><a href="lib/jiutian/api/tutorial.html"><strong>tutorial.md</strong></a></td><td><strong>ğŸš€ å¿«é€Ÿå…¥é—¨æ•™ç¨‹ï¼ˆæ¨èå…ˆçœ‹ï¼‰</strong></td></tr>
<tr><td><a href="lib/jiutian/api/concepts.html">concepts.md</a></td><td>å…³é”®è¯è¯´æ˜ï¼ˆæ–‡æœ¬ç”Ÿæˆæ¨¡å‹ã€åŠ©æ‰‹ã€ä»¤ç‰Œï¼‰</td></tr>
<tr><td><a href="lib/jiutian/api/auth.html">auth.md</a></td><td>èº«ä»½éªŒè¯è¯´æ˜</td></tr>
<tr><td><a href="lib/jiutian/api/chat.html">chat.md</a></td><td>Chat Completions API</td></tr>
<tr><td><a href="lib/jiutian/api/device.html">device.md</a></td><td>è®¾å¤‡æ¥å…¥åè®®ï¼ˆè·å–è®¾å¤‡ä¿¡æ¯ã€å¿ƒè·³ä¸ŠæŠ¥ï¼‰</td></tr>
<tr><td><a href="lib/jiutian/api/faq.html">faq.md</a></td><td>å¸¸è§é—®é¢˜ Q&amp;A</td></tr>
</tbody></table>
</div>
<h2 id="æ–‡æ¡£å˜æ›´è®°å½•"><a class="header" href="#æ–‡æ¡£å˜æ›´è®°å½•">æ–‡æ¡£å˜æ›´è®°å½•</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ—¥æœŸ</th><th>ç‰ˆæœ¬</th><th>æ“ä½œå†…å®¹</th><th>æ“ä½œäºº</th></tr></thead><tbody>
<tr><td>25.02.28</td><td>V1.0</td><td>å®šä¹‰AIç¡¬ä»¶å‚å•†ä¸­æ§å¹³å°å¯¹æ¥ç»ˆç«¯æ™ºèƒ½ä½“æœåŠ¡ç®¡ç†å¹³å°å¤§æ¨¡å‹æœåŠ¡çš„æ¥å£åè®®</td><td>é‚¹ç›Šå¼º</td></tr>
<tr><td>25.04.30</td><td>v1.0.1</td><td>è°ƒæ•´æ–‡æ¡£æ ¼å¼</td><td>é‚¹ç›Šå¼º</td></tr>
<tr><td>25.11.14</td><td>v1.0.2</td><td>å¢åŠ ç”³è¯·é‚®ä»¶è¯´æ˜</td><td>é‚¹ç›Šå¼º</td></tr>
<tr><td>25.12.29</td><td>v1.0.3</td><td>å¢åŠ éç”Ÿæˆå¼aiæ¥å…¥è¯´æ˜</td><td>é‚¹ç›Šå¼º</td></tr>
</tbody></table>
</div>
<h2 id="ai-æœåŠ¡æ¥å…¥æµç¨‹"><a class="header" href="#ai-æœåŠ¡æ¥å…¥æµç¨‹">AI æœåŠ¡æ¥å…¥æµç¨‹</a></h2>
<ol>
<li>è¯·æä¾›å‚å•†æœåŠ¡å™¨IPå¼€é€šè®¿é—®ç™½åå•ï¼Œä»¥åŠå‘çº³ç®¡å¹³å°ç”³è¯·çš„äº§å“idï¼ˆproductIdï¼‰æ¥ç”³è¯·AI token</li>
<li>é‚®ä»¶å‘é€è‡³ï¼š
<ul>
<li>zouyiqiang_fx@cmdc.chinamobile.com</li>
<li>zhucaiwen_fx@cmdc.chinamobile.com</li>
<li>æŠ„é€ï¼šzhengzhongwei_fx@cmdc.chinamobile.com</li>
</ul>
</li>
<li>ç™½åå•å¼€é€šåï¼Œå‚å•†æœåŠ¡å™¨å°±å¯ä»¥ä½¿ç”¨ AI TOKEN è°ƒç”¨ä¹å¤©å¤§æ¨¡å‹æ¥å£</li>
</ol>
<h2 id="ç¯å¢ƒé…ç½®"><a class="header" href="#ç¯å¢ƒé…ç½®">ç¯å¢ƒé…ç½®</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ç¯å¢ƒ</th><th>åœ°å€</th></tr></thead><tbody>
<tr><td>æµ‹è¯•ç¯å¢ƒ</td><td>https://z5f3vhk2.cxzfdm.com:30101</td></tr>
<tr><td>ç”Ÿäº§ç¯å¢ƒ</td><td>https://ivs.chinamobiledevice.com:30100</td></tr>
</tbody></table>
</div>
<p><strong>æµ‹è¯• Token</strong>: <code>sk-Y73NAU0tArvGRlpUE9060529470b42Ac8bA34d40F48b0564</code></p>
<p><strong>ç³»ç»Ÿæç¤ºè¯</strong>: æ‚¨å¥½ï¼Œæˆ‘æ˜¯ä¸­å›½ç§»åŠ¨çš„æ™ºèƒ½åŠ©ç†çµçŠ€ã€‚å¦‚æœæ‚¨è¯¢é—®æˆ‘çš„èº«ä»½ï¼Œæˆ‘ä¼šå›ç­”ï¼š"æ‚¨å¥½ï¼Œæˆ‘æ˜¯ä¸­å›½ç§»åŠ¨æ™ºèƒ½åŠ©ç†çµçŠ€"ã€‚</p>
<p><strong>æ¨¡å‹ä¸Šä¸‹æ–‡é•¿åº¦</strong>: 8K</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mqtt0"><a class="header" href="#mqtt0">mqtt0</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>mqtt0 is a lightweight MQTT implementation focused on QoS 0. It provides both
client and broker components with explicit control over authentication and ACL.
The Go implementation is synchronous and net.Conn-based, while the Rust
implementation is async (Tokio) with optional TLS/WebSocket transport features.</p>
<h2 id="design-goals-13"><a class="header" href="#design-goals-13">Design Goals</a></h2>
<ul>
<li>Minimal MQTT feature set with strong QoS 0 focus</li>
<li>Explicit ACL/auth hooks for connect/publish/subscribe</li>
<li>Simple broker suitable for embedded or internal services</li>
<li>Support MQTT 3.1.1 (v4) and MQTT 5.0 (v5)</li>
<li>Provide transport flexibility (TCP/TLS/WebSocket)</li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<ul>
<li>Client: QoS 0 publish/subscribe, keepalive, protocol v4/v5</li>
<li>Broker: connection lifecycle, ACL checks, topic routing</li>
<li>Shared subscriptions: $share/{group}/{topic}</li>
<li>Topic alias (v5): reduce bandwidth by reusing alias per client</li>
<li>Transports: TCP/TLS/WebSocket based on URL scheme or feature flags</li>
</ul>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<ul>
<li>Client</li>
<li>Broker</li>
<li>Protocol parser/encoder</li>
<li>Topic trie (subscription routing)</li>
<li>Transport layer</li>
</ul>
<h2 id="protocol-and-transport-support"><a class="header" href="#protocol-and-transport-support">Protocol and Transport Support</a></h2>
<ul>
<li>MQTT 3.1.1 and MQTT 5.0 for client and broker</li>
<li>TCP and TLS by default</li>
<li>WebSocket/WSS when enabled (Rust feature flags)</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<ul>
<li>Go: use <code>Connect</code>, <code>Subscribe</code>, <code>Publish</code>, <code>Recv</code></li>
<li>Rust: use <code>Client::connect</code>, <code>client.subscribe</code>, <code>client.publish</code>, <code>client.recv</code></li>
</ul>
<h2 id="related-modules-4"><a class="header" href="#related-modules-4">Related Modules</a></h2>
<ul>
<li><code>docs/lib/trie</code> (topic routing)</li>
<li><code>docs/lib/encoding</code> (protocol helpers)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mqtt0-go"><a class="header" href="#mqtt0-go">mqtt0 (Go)</a></h1>
<h2 id="package-layout"><a class="header" href="#package-layout">Package Layout</a></h2>
<ul>
<li><code>doc.go</code>: high-level overview and usage examples</li>
<li><code>client.go</code>: QoS 0 client implementation</li>
<li><code>broker.go</code>: broker implementation with ACL hooks</li>
<li><code>packet_v4.go</code>, <code>packet_v5.go</code>, <code>packet.go</code>: protocol encode/decode</li>
<li><code>listener.go</code>, <code>dialer.go</code>: transport helpers</li>
<li><code>trie.go</code>: subscription routing</li>
</ul>
<h2 id="public-interfaces"><a class="header" href="#public-interfaces">Public Interfaces</a></h2>
<ul>
<li><code>ClientConfig</code>: broker address, protocol version, TLS config, keepalive, etc.</li>
<li><code>Client</code>: <code>Connect</code>, <code>Subscribe</code>, <code>Unsubscribe</code>, <code>Publish</code>, <code>Recv</code>, <code>Close</code></li>
<li><code>Broker</code>: <code>Serve</code>, <code>ServeConn</code>, ACL hooks, callbacks</li>
<li><code>Authenticator</code>: access control on connect/publish/subscribe</li>
<li><code>Handler</code>: callback for inbound broker messages</li>
<li><code>Message</code>, <code>ProtocolVersion</code>, <code>QoS</code></li>
</ul>
<h2 id="design-notes"><a class="header" href="#design-notes">Design Notes</a></h2>
<ul>
<li>Single connection with separate read/write locks to guard concurrent access.</li>
<li>Request/response operations (SUBSCRIBE/UNSUBSCRIBE) read from the same stream
as inbound PUBLISH messages.</li>
<li>Keepalive runs in a goroutine when <code>AutoKeepalive</code> is enabled.</li>
<li>Shared subscriptions and topic aliasing are handled in the broker.</li>
</ul>
<h2 id="transport"><a class="header" href="#transport">Transport</a></h2>
<ul>
<li>URL-based address parsing: <code>tcp://</code>, <code>tls://</code>, <code>ws://</code>, <code>wss://</code></li>
<li><code>Dialer</code> hook allows custom connection logic</li>
<li>TLS config supported via <code>ClientConfig.TLSConfig</code></li>
</ul>
<h2 id="notable-behaviors"><a class="header" href="#notable-behaviors">Notable Behaviors</a></h2>
<ul>
<li>QoS 0 only; no packet persistence or retransmission.</li>
<li>Broker drops messages when per-client channel is full (non-blocking send).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mqtt0-rust"><a class="header" href="#mqtt0-rust">mqtt0 (Rust)</a></h1>
<h2 id="crate-layout"><a class="header" href="#crate-layout">Crate Layout</a></h2>
<ul>
<li><code>lib.rs</code>: public exports, crate overview</li>
<li><code>client.rs</code>: async QoS 0 client</li>
<li><code>broker.rs</code>: async broker with ACL hooks</li>
<li><code>protocol.rs</code>: MQTT encode/decode</li>
<li><code>transport.rs</code>: TCP/TLS/WebSocket transport abstraction</li>
<li><code>trie.rs</code>: subscription routing</li>
<li><code>types.rs</code>: public types and traits</li>
</ul>
<h2 id="public-interfaces-1"><a class="header" href="#public-interfaces-1">Public Interfaces</a></h2>
<ul>
<li><code>Client</code>, <code>ClientConfig</code>: async connect/subscribe/publish/recv</li>
<li><code>Broker</code>, <code>BrokerConfig</code>, <code>BrokerBuilder</code>: broker setup and lifecycle</li>
<li><code>Authenticator</code>, <code>Handler</code>: ACL and message handling</li>
<li><code>Message</code>, <code>ProtocolVersion</code>, <code>QoS</code></li>
<li><code>TransportType</code>, <code>Transport</code> (feature-gated TLS/WebSocket)</li>
</ul>
<h2 id="design-notes-1"><a class="header" href="#design-notes-1">Design Notes</a></h2>
<ul>
<li>Fully async, based on Tokio and mpsc channels.</li>
<li>Builder pattern for broker configuration and hooks.</li>
<li>Transport features are behind Cargo feature flags (TLS, WebSocket).</li>
</ul>
<h2 id="differences-vs-go"><a class="header" href="#differences-vs-go">Differences vs Go</a></h2>
<ul>
<li>Rust uses async traits for client/broker operations.</li>
<li>TLS/WebSocket support is feature-gated.</li>
<li>Broker construction encourages builder configuration.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mqtt0---known-issues"><a class="header" href="#mqtt0---known-issues">mqtt0 - Known Issues</a></h1>
<h2 id="-major-issues-4"><a class="header" href="#-major-issues-4">ğŸŸ  Major Issues</a></h2>
<h3 id="mqtt0-001-go-client-read-path-is-not-demultiplexed"><a class="header" href="#mqtt0-001-go-client-read-path-is-not-demultiplexed">MQTT0-001: Go Client read path is not demultiplexed</a></h3>
<p><strong>File:</strong> <code>go/pkg/mqtt0/client.go</code></p>
<p><strong>Description:</strong>
<code>Subscribe</code>, <code>Unsubscribe</code>, and other request/response operations read directly
from the same stream as <code>Recv()</code>. If callers run <code>Recv()</code> concurrently with
<code>Subscribe()</code> or <code>Unsubscribe()</code>, whichever acquires <code>readMu</code> first may consume
packets that belong to the other operation, causing unexpected packet errors.</p>
<p><strong>Impact:</strong>
Hard-to-debug race between subscription changes and inbound message handling.</p>
<p><strong>Suggestion:</strong>
Introduce a single read loop with protocol demuxing, or document that
<code>Recv()</code> must not run concurrently with subscribe/unsubscribe calls.</p>
<hr />
<h2 id="-minor-issues-12"><a class="header" href="#-minor-issues-12">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="mqtt0-002-go-broker-drops-messages-on-backpressure"><a class="header" href="#mqtt0-002-go-broker-drops-messages-on-backpressure">MQTT0-002: Go Broker drops messages on backpressure</a></h3>
<p><strong>File:</strong> <code>go/pkg/mqtt0/broker.go</code></p>
<p><strong>Description:</strong>
The broker uses a bounded channel for each client. When the channel is full,
messages are dropped with a debug log.</p>
<p><strong>Impact:</strong>
Message loss under bursty load beyond QoS 0 expectations; may surprise users.</p>
<p><strong>Suggestion:</strong>
Document the drop behavior clearly or make buffer size configurable.</p>
<hr />
<h3 id="mqtt0-003-rust-websocket-transport-requires-special-handling"><a class="header" href="#mqtt0-003-rust-websocket-transport-requires-special-handling">MQTT0-003: Rust WebSocket transport requires special handling</a></h3>
<p><strong>File:</strong> <code>rust/mqtt0/src/transport.rs</code></p>
<p><strong>Description:</strong>
<code>Transport::WebSocket</code> implements <code>AsyncRead/AsyncWrite</code> by returning
<code>Unsupported</code> errors. If code treats <code>Transport</code> uniformly, WebSocket
connections will fail at runtime.</p>
<p><strong>Impact:</strong>
Surprising runtime errors for WebSocket clients if not handled explicitly.</p>
<p><strong>Suggestion:</strong>
Expose dedicated websocket read/write APIs or document the required handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgear"><a class="header" href="#chatgear">chatgear</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>chatgear defines the core protocol types for device-to-server communication:
commands, state events, statistics, and audio streaming metadata. It focuses on
interface design rather than transport implementation, and provides an
in-process pipe for testing.</p>
<h2 id="design-goals-14"><a class="header" href="#design-goals-14">Design Goals</a></h2>
<ul>
<li>Stable, typed protocol for device state and control</li>
<li>Clear separation between uplink (device -&gt; server) and downlink (server -&gt; device)</li>
<li>Explicit metadata for timestamps and command issuance</li>
<li>Audio streaming with Opus frame stamping</li>
<li>Support both Go and Rust with comparable API surfaces</li>
</ul>
<h2 id="key-concepts-1"><a class="header" href="#key-concepts-1">Key Concepts</a></h2>
<ul>
<li><strong>Session commands</strong>: device control commands with typed payloads</li>
<li><strong>State events</strong>: gear state transitions with causes</li>
<li><strong>Stats events</strong>: telemetry snapshots and incremental changes</li>
<li><strong>Uplink/Downlink</strong>: split interfaces for bidirectional streams</li>
<li><strong>Ports</strong>: higher-level client/server port abstraction</li>
</ul>
<h2 id="submodules-1"><a class="header" href="#submodules-1">Submodules</a></h2>
<ul>
<li><code>transport</code>: uplink/downlink connection traits and pipe helpers</li>
<li><code>port</code>: client/server port traits and audio track controls</li>
</ul>
<h2 id="external-reference"><a class="header" href="#external-reference">External Reference</a></h2>
<ul>
<li><code>/Users/idy/Work/haivivi/x/docs/chatgear</code> (original protocol/design notes)</li>
</ul>
<h2 id="related-modules-5"><a class="header" href="#related-modules-5">Related Modules</a></h2>
<ul>
<li><code>docs/lib/audio/opusrt</code> for Opus frame handling</li>
<li><code>docs/lib/jsontime</code> for millisecond timestamps</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgear-go"><a class="header" href="#chatgear-go">chatgear (Go)</a></h1>
<h2 id="package-layout-1"><a class="header" href="#package-layout-1">Package Layout</a></h2>
<ul>
<li><code>state.go</code>: gear state enum, state events</li>
<li><code>stats.go</code>: telemetry structs, merge logic</li>
<li><code>command.go</code>: session command types and JSON mapping</li>
<li><code>conn.go</code>: uplink/downlink interfaces</li>
<li><code>port.go</code>: client/server port interfaces</li>
<li><code>conn_pipe.go</code>: in-process pipe connection for tests</li>
</ul>
<h2 id="public-interfaces-2"><a class="header" href="#public-interfaces-2">Public Interfaces</a></h2>
<ul>
<li><strong>State</strong>: <code>GearState</code>, <code>GearStateEvent</code>, <code>GearStateChangeCause</code></li>
<li><strong>Stats</strong>: <code>GearStatsEvent</code>, <code>GearStatsChanges</code> and related structs</li>
<li><strong>Commands</strong>: <code>SessionCommand</code> with <code>SessionCommandEvent</code></li>
<li><strong>Uplink/Downlink</strong>: <code>UplinkTx</code>, <code>UplinkRx</code>, <code>DownlinkTx</code>, <code>DownlinkRx</code></li>
<li><strong>Ports</strong>: <code>ClientPortTx/Rx</code>, <code>ServerPortTx/Rx</code></li>
<li><strong>Pipe</strong>: <code>NewPipe</code> for test or in-process wiring</li>
</ul>
<h2 id="design-notes-2"><a class="header" href="#design-notes-2">Design Notes</a></h2>
<ul>
<li>JSON encoding is typed via <code>commandType()</code> and a tagged event wrapper.</li>
<li>All time fields use <code>jsontime.Milli</code> for millisecond epoch values.</li>
<li>Opus frames are stamped with <code>opusrt.EpochMillis</code> during transport.</li>
<li>Stats merge logic performs partial updates with <code>GearStatsChanges</code>.</li>
</ul>
<h2 id="usage-notes"><a class="header" href="#usage-notes">Usage Notes</a></h2>
<ul>
<li><code>UplinkRx</code>/<code>DownlinkRx</code> expose iterators (<code>iter.Seq2</code>) instead of channels.</li>
<li><code>ServerPortTx</code> exposes track creation for background/foreground/overlay audio.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgear-rust"><a class="header" href="#chatgear-rust">chatgear (Rust)</a></h1>
<h2 id="crate-layout-1"><a class="header" href="#crate-layout-1">Crate Layout</a></h2>
<ul>
<li><code>state.rs</code>: gear state enum and events</li>
<li><code>stats.rs</code>: telemetry structs and merge logic</li>
<li><code>command.rs</code>: session commands and JSON helpers</li>
<li><code>conn.rs</code>: uplink/downlink async traits</li>
<li><code>port.rs</code>: client/server port traits</li>
<li><code>conn_pipe.rs</code>: in-process pipe helper</li>
</ul>
<h2 id="public-interfaces-3"><a class="header" href="#public-interfaces-3">Public Interfaces</a></h2>
<ul>
<li><strong>State</strong>: <code>GearState</code>, <code>GearStateEvent</code>, <code>GearStateChangeCause</code></li>
<li><strong>Stats</strong>: <code>GearStatsEvent</code>, <code>GearStatsChanges</code></li>
<li><strong>Commands</strong>: <code>SessionCommand</code>, <code>SessionCommandEvent</code>, <code>Command</code> enum</li>
<li><strong>Uplink/Downlink</strong>: <code>UplinkTx</code>, <code>UplinkRx</code>, <code>DownlinkTx</code>, <code>DownlinkRx</code></li>
<li><strong>Ports</strong>: <code>ClientPortTx/Rx</code>, <code>ServerPortTx/Rx</code></li>
<li><strong>Pipe</strong>: <code>new_pipe</code></li>
</ul>
<h2 id="design-notes-3"><a class="header" href="#design-notes-3">Design Notes</a></h2>
<ul>
<li>Async traits are used for most IO-facing APIs.</li>
<li>Commands serialize into JSON value payloads; a typed <code>Command</code> enum can parse
from <code>(type, payload)</code> pairs.</li>
<li>Port traits split audio track control and device command APIs.</li>
</ul>
<h2 id="differences-vs-go-1"><a class="header" href="#differences-vs-go-1">Differences vs Go</a></h2>
<ul>
<li>Rust favors async traits and owned <code>Vec&lt;u8&gt;</code> payloads.</li>
<li>Command event uses <code>serde_json::Value</code> instead of typed interface payloads.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgear---known-issues"><a class="header" href="#chatgear---known-issues">chatgear - Known Issues</a></h1>
<h2 id="-minor-issues-13"><a class="header" href="#-minor-issues-13">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="cg-001-go-readnfctag-equality-ignores-tag-data-changes"><a class="header" href="#cg-001-go-readnfctag-equality-ignores-tag-data-changes">CG-001: Go ReadNFCTag equality ignores tag data changes</a></h3>
<p><strong>File:</strong> <code>go/pkg/chatgear/stats.go</code></p>
<p><strong>Description:</strong>
<code>ReadNFCTag.Equal</code> compares only tag UIDs. If a tag's payload or metadata
changes but the UID remains the same, the merge logic will treat it as unchanged.</p>
<p><strong>Impact:</strong>
Telemetry updates can be silently skipped.</p>
<p><strong>Suggestion:</strong>
Include additional fields (e.g., <code>RawData</code>, <code>DataFormat</code>, <code>UpdateAt</code>) in equality
or document UID-only matching as a deliberate choice.</p>
<hr />
<h3 id="cg-002-rust-sessioncommandevent-swallows-serialization-errors"><a class="header" href="#cg-002-rust-sessioncommandevent-swallows-serialization-errors">CG-002: Rust SessionCommandEvent swallows serialization errors</a></h3>
<p><strong>File:</strong> <code>rust/chatgear/src/command.rs</code></p>
<p><strong>Description:</strong>
<code>SessionCommandEvent::new</code> uses <code>serde_json::to_value(cmd)</code> and replaces errors
with <code>Value::Null</code>, losing the original error context.</p>
<p><strong>Impact:</strong>
Serialization failures are silently ignored, making debugging difficult.</p>
<p><strong>Suggestion:</strong>
Return a <code>Result</code> or log/report serialization failures explicitly.</p>
<hr />
<h3 id="cg-003-go-pipe-connections-can-block-indefinitely-on-backpressure"><a class="header" href="#cg-003-go-pipe-connections-can-block-indefinitely-on-backpressure">CG-003: Go Pipe connections can block indefinitely on backpressure</a></h3>
<p><strong>File:</strong> <code>go/pkg/chatgear/conn_pipe.go</code></p>
<p><strong>Description:</strong>
<code>NewPipe</code> uses bounded channels. If the receiver stops reading, senders will
block in <code>SendOpusFrames</code> / <code>SendState</code> / <code>SendStats</code> without a timeout unless
the caller provides a cancellable context.</p>
<p><strong>Impact:</strong>
Potential goroutine leaks in tests or in-process usage.</p>
<p><strong>Suggestion:</strong>
Document this behavior and recommend context timeouts for pipe usage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgeartransport"><a class="header" href="#chatgeartransport">chatgear/transport</a></h1>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The transport layer defines bidirectional streaming interfaces for chatgear.
It splits data flow into uplink (device -&gt; server) and downlink (server -&gt;
device) and provides a test-friendly in-process pipe.</p>
<h2 id="design-goals-15"><a class="header" href="#design-goals-15">Design Goals</a></h2>
<ul>
<li>Separate uplink/downlink responsibilities</li>
<li>Provide a minimal interface that can be implemented by different transports</li>
<li>Keep Opus framing metadata explicit</li>
</ul>
<h2 id="key-concepts-2"><a class="header" href="#key-concepts-2">Key Concepts</a></h2>
<ul>
<li><code>UplinkTx</code> / <code>UplinkRx</code>: device -&gt; server</li>
<li><code>DownlinkTx</code> / <code>DownlinkRx</code>: server -&gt; device</li>
<li>Stamped Opus frames: carry timestamp for playback alignment</li>
<li>Pipe connection for in-process testing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgeartransport-go"><a class="header" href="#chatgeartransport-go">chatgear/transport (Go)</a></h1>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<ul>
<li><code>UplinkTx</code>: send stamped Opus frames, state events, stats events</li>
<li><code>UplinkRx</code>: receive Opus frames, state events, stats events (iter.Seq2)</li>
<li><code>DownlinkTx</code>: send Opus frames and commands; expose Opus encode options</li>
<li><code>DownlinkRx</code>: receive Opus frames and commands (iter.Seq2)</li>
</ul>
<h2 id="pipe-helper"><a class="header" href="#pipe-helper">Pipe Helper</a></h2>
<ul>
<li><code>NewPipe()</code> returns <code>PipeServerConn</code> (UplinkRx + DownlinkTx) and
<code>PipeClientConn</code> (UplinkTx + DownlinkRx).</li>
</ul>
<h2 id="design-notes-4"><a class="header" href="#design-notes-4">Design Notes</a></h2>
<ul>
<li>Iterators are used instead of channels for receiving streams.</li>
<li>Opus frame timestamps are derived from <code>opusrt.Frame</code> durations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgeartransport-rust"><a class="header" href="#chatgeartransport-rust">chatgear/transport (Rust)</a></h1>
<h2 id="interfaces-1"><a class="header" href="#interfaces-1">Interfaces</a></h2>
<ul>
<li><code>UplinkTx</code>: async send Opus frames, state events, stats events</li>
<li><code>UplinkRx</code>: async receive Opus frames, state events, stats events</li>
<li><code>DownlinkTx</code>: async send Opus frames and commands</li>
<li><code>DownlinkRx</code>: async receive Opus frames and commands</li>
<li><code>OpusEncodeOptions</code>: connection-level Opus encoding metadata</li>
</ul>
<h2 id="connection-traits"><a class="header" href="#connection-traits">Connection Traits</a></h2>
<ul>
<li><code>ServerConn</code>: <code>UplinkRx + DownlinkTx</code></li>
<li><code>ClientConn</code>: <code>UplinkTx + DownlinkRx</code></li>
</ul>
<h2 id="design-notes-5"><a class="header" href="#design-notes-5">Design Notes</a></h2>
<ul>
<li>All transport interfaces are async traits.</li>
<li>Opus encode metadata is modeled explicitly but not attached to the traits.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgeartransport---known-issues"><a class="header" href="#chatgeartransport---known-issues">chatgear/transport - Known Issues</a></h1>
<h2 id="-minor-issues-14"><a class="header" href="#-minor-issues-14">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="cgt-001-go-opus-encode-options-setter-is-not-in-interface"><a class="header" href="#cgt-001-go-opus-encode-options-setter-is-not-in-interface">CGT-001: Go Opus encode options setter is not in interface</a></h3>
<p><strong>File:</strong> <code>go/pkg/chatgear/conn.go</code>, <code>go/pkg/chatgear/conn_pipe.go</code></p>
<p><strong>Description:</strong>
<code>DownlinkTx</code> exposes <code>OpusEncodeOptions()</code> but there is no interface method to
set or update the options. <code>PipeServerConn</code> provides <code>SetOpusEncodeOptions</code>,
but it is not part of the public interface.</p>
<p><strong>Impact:</strong>
Callers holding a <code>DownlinkTx</code> cannot configure encode options generically.</p>
<p><strong>Suggestion:</strong>
Add a setter to <code>DownlinkTx</code> or move encode options into a separate config
interface.</p>
<hr />
<h3 id="cgt-002-rust-opusencodeoptions-not-wired-to-transport-traits"><a class="header" href="#cgt-002-rust-opusencodeoptions-not-wired-to-transport-traits">CGT-002: Rust OpusEncodeOptions not wired to transport traits</a></h3>
<p><strong>File:</strong> <code>rust/chatgear/src/conn.rs</code></p>
<p><strong>Description:</strong>
<code>OpusEncodeOptions</code> exists but is not exposed through <code>DownlinkTx</code> or other
transport traits.</p>
<p><strong>Impact:</strong>
Encoding parameters cannot be discovered or negotiated through the transport
API.</p>
<p><strong>Suggestion:</strong>
Add accessors to <code>DownlinkTx</code> or document external negotiation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgearport"><a class="header" href="#chatgearport">chatgear/port</a></h1>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Port interfaces represent higher-level client/server roles built on top of the
transport layer. They combine audio streaming, state/stats telemetry, and
command control into a single abstraction.</p>
<h2 id="design-goals-16"><a class="header" href="#design-goals-16">Design Goals</a></h2>
<ul>
<li>Provide a symmetric client/server API surface</li>
<li>Hide transport details while preserving real-time audio controls</li>
<li>Expose device control commands alongside audio output</li>
</ul>
<h2 id="key-concepts-3"><a class="header" href="#key-concepts-3">Key Concepts</a></h2>
<ul>
<li><strong>ClientPort</strong>: device-side send/receive split (Tx/Rx)</li>
<li><strong>ServerPort</strong>: server-side send/receive split (Tx/Rx)</li>
<li><strong>Audio tracks</strong>: background/foreground/overlay output streams</li>
<li><strong>Device commands</strong>: volume, brightness, WiFi, OTA, power, etc.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgearport-go"><a class="header" href="#chatgearport-go">chatgear/port (Go)</a></h1>
<h2 id="interfaces-2"><a class="header" href="#interfaces-2">Interfaces</a></h2>
<ul>
<li><code>ClientPortTx</code>: send Opus frames, state events, stats events</li>
<li><code>ClientPortRx</code>: receive Opus frames and commands</li>
<li><code>ServerPortTx</code>: create tracks, control tracks, issue commands</li>
<li><code>ServerPortRx</code>: receive Opus frames, state events, stats changes</li>
</ul>
<h2 id="audio-output"><a class="header" href="#audio-output">Audio Output</a></h2>
<ul>
<li>Track creation: <code>NewBackgroundTrack</code>, <code>NewForegroundTrack</code>, <code>NewOverlayTrack</code></li>
<li>Track controls: <code>BackgroundTrackCtrl</code>, <code>ForegroundTrackCtrl</code>, <code>OverlayTrackCtrl</code></li>
<li>Global stop: <code>Interrupt()</code></li>
</ul>
<h2 id="device-commands"><a class="header" href="#device-commands">Device Commands</a></h2>
<ul>
<li>Volume, brightness, light mode</li>
<li>WiFi set/delete, reset/unpair, sleep/shutdown, raise call</li>
<li>OTA firmware upgrade</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li><code>ServerPortRx</code> provides getters for cached state/stat values.</li>
<li>Audio tracks are based on <code>pcm.Track</code> and <code>pcm.TrackCtrl</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgearport-rust"><a class="header" href="#chatgearport-rust">chatgear/port (Rust)</a></h1>
<h2 id="interfaces-3"><a class="header" href="#interfaces-3">Interfaces</a></h2>
<ul>
<li><code>ClientPortTx</code>: async send Opus frames, state events, stats events</li>
<li><code>ClientPortRx</code>: async receive Opus frames and commands</li>
<li><code>ServerPortTx</code>: track creation + device command methods</li>
<li><code>ServerPortRx</code>: async receive telemetry + cached getters</li>
</ul>
<h2 id="audio-output-1"><a class="header" href="#audio-output-1">Audio Output</a></h2>
<ul>
<li><code>AudioTrack</code> and <code>AudioTrackCtrl</code> traits</li>
<li>Background/foreground/overlay track creation</li>
<li><code>interrupt()</code> to stop all output tracks</li>
</ul>
<h2 id="notes-1"><a class="header" href="#notes-1">Notes</a></h2>
<ul>
<li>Port errors are consolidated under <code>PortError</code>.</li>
<li>Track accessors return <code>Option&lt;&amp;dyn AudioTrackCtrl&gt;</code> to reflect optional state.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chatgearport---known-issues"><a class="header" href="#chatgearport---known-issues">chatgear/port - Known Issues</a></h1>
<h2 id="-minor-issues-15"><a class="header" href="#-minor-issues-15">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="cgp-001-wifi-security-not-exposed-by-port-command-api"><a class="header" href="#cgp-001-wifi-security-not-exposed-by-port-command-api">CGP-001: WiFi security not exposed by port command API</a></h3>
<p><strong>File:</strong> <code>go/pkg/chatgear/port.go</code>, <code>rust/chatgear/src/port.rs</code></p>
<p><strong>Description:</strong>
<code>SetWifi</code> command contains <code>security</code>, but <code>ServerPortTx::SetWifi</code> only accepts
<code>ssid</code> and <code>password</code>. The security mode cannot be specified through the port
interface.</p>
<p><strong>Impact:</strong>
Limits configuration for networks requiring explicit security types.</p>
<p><strong>Suggestion:</strong>
Add a <code>security</code> parameter or provide a higher-level WiFi config struct.</p>
<hr />
<h3 id="cgp-002-clientportrx-does-not-surface-receive-errors"><a class="header" href="#cgp-002-clientportrx-does-not-surface-receive-errors">CGP-002: ClientPortRx does not surface receive errors</a></h3>
<p><strong>File:</strong> <code>go/pkg/chatgear/port.go</code>, <code>rust/chatgear/src/port.rs</code></p>
<p><strong>Description:</strong>
Go returns commands via a channel without error context; Rust returns <code>Option</code>
from <code>recv_*</code> methods. Transport errors are not exposed on the receive side.</p>
<p><strong>Impact:</strong>
Callers cannot distinguish between clean shutdown and underlying IO errors.</p>
<p><strong>Suggestion:</strong>
Return <code>(value, error)</code> pairs or provide an error channel/stream.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="speech"><a class="header" href="#speech">speech</a></h1>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The speech module defines interfaces for voice and speech processing. It
separates pure audio streams (Voice) from speech streams that include
transcriptions (Speech). It also provides multiplexers for ASR (speech-to-text)
and TTS (text-to-speech) implementations.</p>
<h2 id="design-goals-17"><a class="header" href="#design-goals-17">Design Goals</a></h2>
<ul>
<li>Unified interfaces for ASR/TTS backends</li>
<li>Stream-first APIs for long-running audio</li>
<li>Clear separation between audio-only and audio+text</li>
<li>Pluggable providers via multiplexer registration</li>
</ul>
<h2 id="key-concepts-4"><a class="header" href="#key-concepts-4">Key Concepts</a></h2>
<ul>
<li><strong>Voice</strong>: audio-only stream of PCM segments</li>
<li><strong>Speech</strong>: audio stream with text transcription per segment</li>
<li><strong>ASR</strong>: Opus input -&gt; <code>Speech</code>/<code>SpeechStream</code></li>
<li><strong>TTS</strong>: text input -&gt; <code>Speech</code></li>
<li><strong>Sentence segmentation</strong>: split long text into manageable chunks</li>
</ul>
<h2 id="components-3"><a class="header" href="#components-3">Components</a></h2>
<ul>
<li>Voice/Speech interfaces</li>
<li>ASR/TTS muxers</li>
<li>Sentence segmentation utilities</li>
<li>Speech collection and copy helpers</li>
</ul>
<h2 id="related-modules-6"><a class="header" href="#related-modules-6">Related Modules</a></h2>
<ul>
<li><code>docs/lib/audio/pcm</code> for PCM formats</li>
<li><code>docs/lib/audio/opusrt</code> for Opus streaming input</li>
<li>Provider SDKs in <code>docs/lib/minimax</code>, <code>docs/lib/doubaospeech</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="speech-go"><a class="header" href="#speech-go">speech (Go)</a></h1>
<h2 id="package-layout-2"><a class="header" href="#package-layout-2">Package Layout</a></h2>
<ul>
<li><code>voice.go</code>: Voice/VoiceSegment interfaces</li>
<li><code>speech.go</code>: Speech/SpeechSegment interfaces</li>
<li><code>asr.go</code>: ASR multiplexer and interfaces</li>
<li><code>tts.go</code>: TTS multiplexer and interfaces</li>
<li><code>segment.go</code>: default sentence segmentation</li>
<li><code>util.go</code>: collectors and copy helpers</li>
<li>Provider implementations: <code>asr_doubao_sauc.go</code>, <code>tts_doubao_v1.go</code>,
<code>tts_doubao_v2.go</code>, <code>tts_minimax.go</code></li>
</ul>
<h2 id="public-interfaces-4"><a class="header" href="#public-interfaces-4">Public Interfaces</a></h2>
<ul>
<li><strong>Voice</strong>: <code>Voice</code>, <code>VoiceSegment</code>, <code>VoiceStream</code></li>
<li><strong>Speech</strong>: <code>Speech</code>, <code>SpeechSegment</code>, <code>SpeechStream</code></li>
<li><strong>ASR</strong>: <code>StreamTranscriber</code>, <code>Transcriber</code>, <code>ASR</code> mux + helpers</li>
<li><strong>TTS</strong>: <code>Synthesizer</code>, <code>TTS</code> mux + helpers</li>
<li><strong>Segmentation</strong>: <code>SentenceSegmenter</code>, <code>SentenceIterator</code></li>
</ul>
<h2 id="design-notes-6"><a class="header" href="#design-notes-6">Design Notes</a></h2>
<ul>
<li>Global muxes <code>ASRMux</code> and <code>TTSMux</code> provide default routing.</li>
<li>ASR uses Opus frame streams (<code>opusrt.FrameReader</code>).</li>
<li><code>DefaultSentenceSegmenter</code> splits by punctuation with a rune cap.</li>
<li><code>CollectSpeech</code> and <code>CopySpeech</code> help aggregate or export streams.</li>
</ul>
<h2 id="usage-notes-1"><a class="header" href="#usage-notes-1">Usage Notes</a></h2>
<ul>
<li><code>Transcribe</code> falls back to streaming when the backend does not implement
the <code>Transcriber</code> interface.</li>
<li><code>Revoice</code> streams existing speech into a TTS backend via a pipe.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="speech-rust"><a class="header" href="#speech-rust">speech (Rust)</a></h1>
<h2 id="crate-layout-2"><a class="header" href="#crate-layout-2">Crate Layout</a></h2>
<ul>
<li><code>voice.rs</code>: Voice/VoiceSegment interfaces</li>
<li><code>speech.rs</code>: Speech/SpeechSegment interfaces</li>
<li><code>asr.rs</code>: ASR multiplexer and traits</li>
<li><code>tts.rs</code>: TTS multiplexer and traits</li>
<li><code>segment.rs</code>: sentence segmentation utilities</li>
<li><code>util.rs</code>: speech collector and iterator helpers</li>
</ul>
<h2 id="public-interfaces-5"><a class="header" href="#public-interfaces-5">Public Interfaces</a></h2>
<ul>
<li><strong>Voice</strong>: <code>Voice</code>, <code>VoiceSegment</code>, <code>VoiceStream</code></li>
<li><strong>Speech</strong>: <code>Speech</code>, <code>SpeechSegment</code>, <code>SpeechStream</code></li>
<li><strong>ASR</strong>: <code>StreamTranscriber</code>, <code>Transcriber</code> (async), <code>ASR</code></li>
<li><strong>TTS</strong>: <code>Synthesizer</code>, <code>TTS</code> (async)</li>
<li><strong>Segmentation</strong>: <code>SentenceSegmenter</code>, <code>SentenceIterator</code></li>
</ul>
<h2 id="design-notes-7"><a class="header" href="#design-notes-7">Design Notes</a></h2>
<ul>
<li>Async traits are used across ASR/TTS and stream interfaces.</li>
<li><code>ASR</code> and <code>TTS</code> use a trie-based mux with async read/write locks.</li>
<li><code>SpeechCollector</code> composes a <code>SpeechStream</code> into a single <code>Speech</code>.</li>
</ul>
<h2 id="differences-vs-go-2"><a class="header" href="#differences-vs-go-2">Differences vs Go</a></h2>
<ul>
<li>No global mux singletons; callers construct <code>ASR</code>/<code>TTS</code> explicitly.</li>
<li>Async <code>AsyncRead</code> is used for text input in TTS.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="speech---known-issues"><a class="header" href="#speech---known-issues">speech - Known Issues</a></h1>
<h2 id="-minor-issues-16"><a class="header" href="#-minor-issues-16">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="spt-001-go-revoice-has-no-cancellation-propagation"><a class="header" href="#spt-001-go-revoice-has-no-cancellation-propagation">SPT-001: Go Revoice has no cancellation propagation</a></h3>
<p><strong>File:</strong> <code>go/pkg/speech/tts.go</code></p>
<p><strong>Description:</strong>
<code>Revoice</code> spawns a goroutine that copies the entire input speech into an
<code>io.Pipe</code>, but the goroutine is not tied to the caller's context. If the
synthesizer returns early or the context is canceled, the copy goroutine may
continue doing work until completion.</p>
<p><strong>Impact:</strong>
Wasted CPU or lingering goroutines on early cancellation.</p>
<p><strong>Suggestion:</strong>
Honor context cancellation inside the copy loop or use a pipe that is closed
when <code>ctx.Done()</code> fires.</p>
<hr />
<h3 id="spt-002-rust-asr-ignores-full-transcribe-implementations"><a class="header" href="#spt-002-rust-asr-ignores-full-transcribe-implementations">SPT-002: Rust ASR ignores full-transcribe implementations</a></h3>
<p><strong>File:</strong> <code>rust/speech/src/asr.rs</code></p>
<p><strong>Description:</strong>
<code>ASR::transcribe</code> always falls back to the streaming path, even though a
<code>Transcriber</code> trait exists for full transcription.</p>
<p><strong>Impact:</strong>
Backends that can provide a more efficient full-transcribe path cannot use it.</p>
<p><strong>Suggestion:</strong>
Detect and use <code>Transcriber</code> implementations when available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx---universal-llm-interface"><a class="header" href="#genx---universal-llm-interface">GenX - Universal LLM Interface</a></h1>
<p>GenX is a universal abstraction layer for Large Language Models (LLMs).</p>
<h2 id="design-goals-18"><a class="header" href="#design-goals-18">Design Goals</a></h2>
<ol>
<li><strong>Provider Agnostic</strong>: Single API for OpenAI, Gemini, and other providers</li>
<li><strong>Streaming First</strong>: Native support for streaming responses</li>
<li><strong>Tool Orchestration</strong>: Rich function calling and tool management</li>
<li><strong>Agent Framework</strong>: Build autonomous AI agents (Go only)</li>
</ol>
<h2 id="architecture-4"><a class="header" href="#architecture-4">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Application Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    Agent Framework (Go)                 â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚ â”‚
â”‚  â”‚  â”‚  ReActAgent  â”‚ â”‚  MatchAgent  â”‚ â”‚  SubAgents   â”‚    â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                      Tool System                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚FuncToolâ”‚ â”‚GeneratorToolâ”‚ â”‚HTTPToolâ”‚ â”‚CompositeToolâ”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Core Abstraction                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ModelContext  â”‚ â”‚  Generator   â”‚ â”‚      Stream          â”‚ â”‚
â”‚  â”‚  (Builder)   â”‚ â”‚  (Trait)     â”‚ â”‚   (Chunks)           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Provider Adapters                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚    OpenAI    â”‚ â”‚    Gemini    â”‚ â”‚       Other          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="modelcontext"><a class="header" href="#modelcontext">ModelContext</a></h3>
<p>Contains all inputs for LLM generation:</p>
<ul>
<li><strong>Prompts</strong>: System instructions (named prompts)</li>
<li><strong>Messages</strong>: Conversation history</li>
<li><strong>Tools</strong>: Available function definitions</li>
<li><strong>Params</strong>: Model parameters (temperature, max_tokens, etc.)</li>
<li><strong>CoTs</strong>: Chain-of-thought examples</li>
</ul>
<h3 id="generator"><a class="header" href="#generator">Generator</a></h3>
<p>Interface for LLM providers:</p>
<ul>
<li><code>GenerateStream()</code>: Streaming text generation</li>
<li><code>Invoke()</code>: Structured function call</li>
</ul>
<h3 id="stream-2"><a class="header" href="#stream-2">Stream</a></h3>
<p>Streaming response handler:</p>
<ul>
<li><code>Next()</code>: Get next message chunk</li>
<li><code>Close()</code>: Close stream</li>
<li><code>CloseWithError()</code>: Close with error</li>
</ul>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>user</code></td><td>User input</td></tr>
<tr><td><code>assistant</code></td><td>Model response</td></tr>
<tr><td><code>system</code></td><td>System prompt (in messages)</td></tr>
<tr><td><code>tool</code></td><td>Tool call/result</td></tr>
</tbody></table>
</div>
<h3 id="content-types"><a class="header" href="#content-types">Content Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Text</code></td><td>Plain text</td></tr>
<tr><td><code>Blob</code></td><td>Binary data (images, audio)</td></tr>
<tr><td><code>ToolCall</code></td><td>Function call request</td></tr>
<tr><td><code>ToolResult</code></td><td>Function call response</td></tr>
</tbody></table>
</div>
<h2 id="agent-framework-go-only"><a class="header" href="#agent-framework-go-only">Agent Framework (Go only)</a></h2>
<h3 id="agent-types"><a class="header" href="#agent-types">Agent Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Agent</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ReActAgent</code></td><td>Reasoning + Acting pattern</td></tr>
<tr><td><code>MatchAgent</code></td><td>Intent-based routing</td></tr>
</tbody></table>
</div>
<h3 id="tool-types"><a class="header" href="#tool-types">Tool Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FuncTool</code></td><td>Go function wrapper</td></tr>
<tr><td><code>GeneratorTool</code></td><td>LLM-based generation</td></tr>
<tr><td><code>HTTPTool</code></td><td>HTTP requests</td></tr>
<tr><td><code>CompositeTool</code></td><td>Tool pipeline</td></tr>
<tr><td><code>TextProcessorTool</code></td><td>Text manipulation</td></tr>
</tbody></table>
</div>
<h3 id="event-system"><a class="header" href="#event-system">Event System</a></h3>
<p>Agents emit events for fine-grained control:</p>
<ul>
<li><code>EventChunk</code>: Output chunk</li>
<li><code>EventEOF</code>: Round ended</li>
<li><code>EventClosed</code>: Agent completed</li>
<li><code>EventToolStart</code>: Tool execution started</li>
<li><code>EventToolDone</code>: Tool completed</li>
<li><code>EventToolError</code>: Tool failed</li>
<li><code>EventInterrupted</code>: Interrupted</li>
</ul>
<h2 id="configuration-agentcfg"><a class="header" href="#configuration-agentcfg">Configuration (agentcfg)</a></h2>
<p>YAML/JSON configuration for agents and tools:</p>
<pre><code class="language-yaml">type: react
name: assistant
prompt: |
  You are a helpful assistant.
generator:
  model: gpt-4
tools:
  - $ref: tool:search
  - $ref: tool:calculator
</code></pre>
<p>Supports <code>$ref</code> for reusable components.</p>
<h2 id="provider-support"><a class="header" href="#provider-support">Provider Support</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Provider</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td>OpenAI</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Gemini</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Compatible APIs</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
</tbody></table>
</div>
<h2 id="examples-directory-9"><a class="header" href="#examples-directory-9">Examples Directory</a></h2>
<ul>
<li><code>examples/go/genx/</code> - Go examples</li>
<li><code>examples/rust/genx/</code> - Rust examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx---go-implementation"><a class="header" href="#genx---go-implementation">GenX - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/genx</code></p>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody>
<tr><td><code>genx</code></td><td>Core types, interfaces, context builder</td></tr>
<tr><td><code>genx/agent</code></td><td>Agent framework (ReAct, Match)</td></tr>
<tr><td><code>genx/agentcfg</code></td><td>Configuration parsing (YAML/JSON)</td></tr>
<tr><td><code>genx/match</code></td><td>Intent matching patterns</td></tr>
<tr><td><code>genx/generators</code></td><td>Provider adapters (OpenAI, Gemini)</td></tr>
<tr><td><code>genx/modelcontexts</code></td><td>Pre-built contexts</td></tr>
<tr><td><code>genx/playground</code></td><td>Interactive testing</td></tr>
</tbody></table>
</div>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="generator-interface"><a class="header" href="#generator-interface">Generator Interface</a></h3>
<pre><code class="language-go">type Generator interface {
    GenerateStream(ctx context.Context, model string, mctx ModelContext) (Stream, error)
    Invoke(ctx context.Context, model string, mctx ModelContext, tool *FuncTool) (Usage, *FuncCall, error)
}
</code></pre>
<h3 id="modelcontext-interface"><a class="header" href="#modelcontext-interface">ModelContext Interface</a></h3>
<pre><code class="language-go">type ModelContext interface {
    Prompts() iter.Seq[*Prompt]
    Messages() iter.Seq[*Message]
    CoTs() iter.Seq[string]
    Tools() iter.Seq[Tool]
    Params() *ModelParams
}
</code></pre>
<h3 id="stream-interface"><a class="header" href="#stream-interface">Stream Interface</a></h3>
<pre><code class="language-go">type Stream interface {
    Next() (*MessageChunk, error)
    Close() error
    CloseWithError(error) error
}
</code></pre>
<h2 id="modelcontext-builder"><a class="header" href="#modelcontext-builder">ModelContext Builder</a></h2>
<pre><code class="language-go">builder := genx.NewModelContextBuilder()

// Add prompts
builder.Prompt("system", "You are a helpful assistant.")

// Add messages
builder.UserText("Hello!")
builder.AssistantText("Hi there!")

// Add tools
builder.Tool(&amp;genx.FuncTool{
    Name: "search",
    Description: "Search the web",
    Schema: `{"type":"object","properties":{"query":{"type":"string"}}}`,
})

// Set parameters
builder.Params(&amp;genx.ModelParams{
    Temperature: 0.7,
    MaxTokens: 1000,
})

ctx := builder.Build()
</code></pre>
<h2 id="functool"><a class="header" href="#functool">FuncTool</a></h2>
<pre><code class="language-go">// From schema
tool := &amp;genx.FuncTool{
    Name: "get_weather",
    Description: "Get weather for a city",
    Schema: `{
        "type": "object",
        "properties": {
            "city": {"type": "string"},
            "units": {"type": "string", "enum": ["celsius", "fahrenheit"]}
        },
        "required": ["city"]
    }`,
}

// With executor
tool := genx.NewFuncToolWithExecutor(
    "search",
    "Search the web",
    schema,
    func(ctx context.Context, args json.RawMessage) (string, error) {
        var params SearchParams
        json.Unmarshal(args, &amp;params)
        return doSearch(params.Query), nil
    },
)
</code></pre>
<h2 id="streaming-1"><a class="header" href="#streaming-1">Streaming</a></h2>
<pre><code class="language-go">stream, err := generator.GenerateStream(ctx, "gpt-4", mctx)
if err != nil {
    return err
}
defer stream.Close()

for {
    chunk, err := stream.Next()
    if err == io.EOF {
        break
    }
    if err != nil {
        return err
    }
    fmt.Print(chunk.Part)
}
</code></pre>
<h2 id="agent-framework"><a class="header" href="#agent-framework">Agent Framework</a></h2>
<h3 id="reactagent"><a class="header" href="#reactagent">ReActAgent</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/genx/agent"

ag, err := agent.NewReActAgent(runtime, &amp;agent.ReActConfig{
    Name: "assistant",
    Prompt: "You are a helpful assistant.",
    Generator: &amp;agentcfg.GeneratorConfig{Model: "gpt-4"},
    Tools: []agentcfg.ToolRef{
        {Ref: "tool:search"},
        {Ref: "tool:calculator"},
    },
})
if err != nil {
    return err
}
defer ag.Close()

// Input
ag.Input(genx.Contents{genx.Text("What's 2+2?")})

// Event loop
for {
    evt, err := ag.Next()
    if err != nil {
        return err
    }
    switch evt.Type {
    case agent.EventChunk:
        fmt.Print(evt.Chunk.Part)
    case agent.EventEOF:
        // Waiting for input
        ag.Input(genx.Contents{genx.Text(readline())})
    case agent.EventClosed:
        return nil
    case agent.EventToolStart:
        fmt.Printf("Calling %s...\n", evt.ToolName)
    case agent.EventToolDone:
        fmt.Printf("Tool returned: %s\n", evt.ToolResult)
    case agent.EventToolError:
        fmt.Printf("Tool error: %v\n", evt.ToolError)
    }
}
</code></pre>
<h3 id="matchagent"><a class="header" href="#matchagent">MatchAgent</a></h3>
<pre><code class="language-go">ag, err := agent.NewMatchAgent(runtime, &amp;agent.MatchConfig{
    Name: "router",
    Rules: []match.Rule{
        {Name: "weather", Patterns: []string{"å¤©æ°”", "weather"}},
        {Name: "music", Patterns: []string{"æ’­æ”¾", "play"}},
    },
    SubAgents: map[string]agentcfg.AgentRef{
        "weather": {Ref: "agent:weather_assistant"},
        "music":   {Ref: "agent:music_player"},
    },
})
</code></pre>
<h2 id="configuration-agentcfg-1"><a class="header" href="#configuration-agentcfg-1">Configuration (agentcfg)</a></h2>
<h3 id="load-from-yaml"><a class="header" href="#load-from-yaml">Load from YAML</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/genx/agentcfg"

cfg, err := agentcfg.LoadAgentFromFile("agent.yaml")

// Or from string
cfg, err := agentcfg.ParseAgent(yamlStr)
</code></pre>
<h3 id="agent-config-example"><a class="header" href="#agent-config-example">Agent Config Example</a></h3>
<pre><code class="language-yaml">type: react
name: assistant
prompt: |
  You are a helpful coding assistant.
generator:
  model: gpt-4
  temperature: 0.7
tools:
  - $ref: tool:search
    quit: false
  - $ref: tool:goodbye
    quit: true
</code></pre>
<h3 id="tool-config-example"><a class="header" href="#tool-config-example">Tool Config Example</a></h3>
<pre><code class="language-yaml">type: http
name: weather_api
description: Get weather data
url: https://api.weather.com/v1/current
method: GET
params:
  - name: city
    in: query
extract: .data.temperature
</code></pre>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<h3 id="openai"><a class="header" href="#openai">OpenAI</a></h3>
<pre><code class="language-go">import "github.com/haivivi/giztoy/pkg/genx/generators"

gen := generators.NewOpenAIGenerator(apiKey,
    generators.WithBaseURL("https://api.openai.com/v1"),
)
</code></pre>
<h3 id="gemini"><a class="header" href="#gemini">Gemini</a></h3>
<pre><code class="language-go">gen := generators.NewGeminiGenerator(apiKey)
</code></pre>
<h2 id="inspection"><a class="header" href="#inspection">Inspection</a></h2>
<pre><code class="language-go">// Inspect model context
output, _ := genx.InspectModelContext(mctx)
fmt.Println(output)

// Inspect message
fmt.Println(genx.InspectMessage(msg))

// Inspect tool
fmt.Println(genx.InspectTool(tool))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx---rust-implementation"><a class="header" href="#genx---rust-implementation">GenX - Rust Implementation</a></h1>
<p>Crate: <code>giztoy-genx</code></p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The Rust implementation provides core abstractions but lacks the full agent framework available in Go.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th></tr></thead><tbody>
<tr><td>ModelContext</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Generator trait</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Streaming</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>FuncTool</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>OpenAI adapter</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Gemini adapter</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td>Agent framework</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td></tr>
<tr><td>Configuration parser</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td></tr>
<tr><td>Match patterns</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td></tr>
</tbody></table>
</div>
<h2 id="core-types-1"><a class="header" href="#core-types-1">Core Types</a></h2>
<h3 id="generator-trait"><a class="header" href="#generator-trait">Generator Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Generator: Send + Sync {
    async fn generate_stream(
        &amp;self,
        model: &amp;str,
        ctx: &amp;dyn ModelContext,
    ) -&gt; Result&lt;Box&lt;dyn Stream&gt;, GenxError&gt;;

    async fn invoke(
        &amp;self,
        model: &amp;str,
        ctx: &amp;dyn ModelContext,
        tool: &amp;FuncTool,
    ) -&gt; Result&lt;(Usage, FuncCall), GenxError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="modelcontext-trait"><a class="header" href="#modelcontext-trait">ModelContext Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ModelContext: Send + Sync {
    fn prompts(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Prompt&gt; + '_&gt;;
    fn messages(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Message&gt; + '_&gt;;
    fn cots(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;str&gt; + '_&gt;;
    fn tools(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;dyn Tool&gt; + '_&gt;;
    fn params(&amp;self) -&gt; Option&lt;&amp;ModelParams&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stream-trait"><a class="header" href="#stream-trait">Stream Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Stream: Send {
    fn next(&amp;mut self) -&gt; StreamResult;
    fn close(&amp;mut self) -&gt; Result&lt;(), GenxError&gt;;
    fn close_with_error(&amp;mut self, err: GenxError) -&gt; Result&lt;(), GenxError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="modelcontextbuilder"><a class="header" href="#modelcontextbuilder">ModelContextBuilder</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::{ModelContextBuilder, FuncTool};
use schemars::JsonSchema;

#[derive(JsonSchema, serde::Deserialize)]
struct SearchArgs {
    query: String,
}

let mut builder = ModelContextBuilder::new();

// Add prompts
builder.prompt_text("system", "You are a helpful assistant.");

// Add messages
builder.user_text("user", "Hello!");
builder.assistant_text("assistant", "Hi there!");

// Add tools
builder.add_tool(FuncTool::new::&lt;SearchArgs&gt;("search", "Search the web"));

// Set parameters
builder.params(ModelParams {
    temperature: Some(0.7),
    max_tokens: Some(1000),
    ..Default::default()
});

let ctx = builder.build();
<span class="boring">}</span></code></pre></pre>
<h2 id="functool-1"><a class="header" href="#functool-1">FuncTool</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::FuncTool;
use schemars::JsonSchema;
use serde::Deserialize;

#[derive(JsonSchema, Deserialize)]
struct WeatherArgs {
    city: String,
    #[serde(default)]
    units: Option&lt;String&gt;,
}

// Create tool with schema derived from type
let tool = FuncTool::new::&lt;WeatherArgs&gt;(
    "get_weather",
    "Get weather for a city"
);

// Access schema
println!("{}", tool.schema());
<span class="boring">}</span></code></pre></pre>
<h2 id="streaming-2"><a class="header" href="#streaming-2">Streaming</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stream = generator.generate_stream("gpt-4", &amp;ctx).await?;

loop {
    match stream.next() {
        StreamResult::Chunk(chunk) =&gt; {
            if let Some(text) = chunk.text() {
                print!("{}", text);
            }
        }
        StreamResult::Done =&gt; break,
        StreamResult::Error(e) =&gt; return Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-types-1"><a class="header" href="#message-types-1">Message Types</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::{Message, Contents, Part, Role};

// User text message
let msg = Message::user_text("Hello!");

// Assistant message with content
let msg = Message {
    role: Role::Assistant,
    name: None,
    payload: Payload::Contents(vec![
        Part::Text("Here's what I found:".to_string()),
    ]),
};

// Tool call
let msg = Message::tool_call(ToolCall {
    id: "call_123".to_string(),
    func_call: FuncCall {
        name: "search".to_string(),
        arguments: r#"{"query":"rust"}"#.to_string(),
    },
});

// Tool result
let msg = Message::tool_result(ToolResult {
    id: "call_123".to_string(),
    result: "Found 10 results".to_string(),
});
<span class="boring">}</span></code></pre></pre>
<h2 id="provider-adapters"><a class="header" href="#provider-adapters">Provider Adapters</a></h2>
<h3 id="openai-1"><a class="header" href="#openai-1">OpenAI</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::openai::OpenAIGenerator;

let generator = OpenAIGenerator::new(api_key)
    .with_base_url("https://api.openai.com/v1");
<span class="boring">}</span></code></pre></pre>
<h3 id="gemini-1"><a class="header" href="#gemini-1">Gemini</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::gemini::GeminiGenerator;

let generator = GeminiGenerator::new(api_key);
<span class="boring">}</span></code></pre></pre>
<h2 id="inspection-1"><a class="header" href="#inspection-1">Inspection</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::{inspect_model_context, inspect_message, inspect_tool};

// Inspect context
println!("{}", inspect_model_context(&amp;ctx));

// Inspect message
println!("{}", inspect_message(&amp;msg));

// Inspect tool
println!("{}", inspect_tool(&amp;tool));
<span class="boring">}</span></code></pre></pre>
<h2 id="error-types-2"><a class="header" href="#error-types-2">Error Types</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use giztoy_genx::{GenxError, State, Status};

match result {
    Err(GenxError::Api { status, message }) =&gt; {
        eprintln!("API error: {} - {}", status, message);
    }
    Err(GenxError::Network(e)) =&gt; {
        eprintln!("Network error: {}", e);
    }
    Err(GenxError::Json(e)) =&gt; {
        eprintln!("JSON error: {}", e);
    }
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="missing-features-vs-go-1"><a class="header" href="#missing-features-vs-go-1">Missing Features (vs Go)</a></h2>
<p>The Rust implementation is missing:</p>
<ol>
<li><strong>Agent Framework</strong>: No ReActAgent, MatchAgent</li>
<li><strong>Configuration Parser</strong>: No YAML/JSON config loading</li>
<li><strong>Match Patterns</strong>: No intent matching system</li>
<li><strong>Tool Variants</strong>: No GeneratorTool, HTTPTool, CompositeTool</li>
<li><strong>Runtime Interface</strong>: No dependency injection system</li>
<li><strong>State Management</strong>: No memory/state persistence</li>
</ol>
<p>These would need to be implemented to reach feature parity with Go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx---known-issues"><a class="header" href="#genx---known-issues">GenX - Known Issues</a></h1>
<h2 id="-major-issues-5"><a class="header" href="#-major-issues-5">ğŸ”´ Major Issues</a></h2>
<h3 id="gx-001-rust-lacks-agent-framework"><a class="header" href="#gx-001-rust-lacks-agent-framework">GX-001: Rust lacks agent framework</a></h3>
<p><strong>Description:</strong><br />
Rust implementation missing the entire agent framework:</p>
<ul>
<li>No ReActAgent</li>
<li>No MatchAgent</li>
<li>No tool orchestration</li>
<li>No configuration parser</li>
</ul>
<p><strong>Impact:</strong> Cannot build autonomous agents in Rust.</p>
<p><strong>Effort:</strong> High - requires significant implementation work.</p>
<hr />
<h3 id="gx-002-rust-lacks-advanced-tool-types"><a class="header" href="#gx-002-rust-lacks-advanced-tool-types">GX-002: Rust lacks advanced tool types</a></h3>
<p><strong>Description:</strong><br />
Rust only has <code>FuncTool</code>. Missing:</p>
<ul>
<li><code>GeneratorTool</code></li>
<li><code>HTTPTool</code></li>
<li><code>CompositeTool</code></li>
<li><code>TextProcessorTool</code></li>
</ul>
<p><strong>Impact:</strong> Limited tool capabilities in Rust.</p>
<hr />
<h2 id="-minor-issues-17"><a class="header" href="#-minor-issues-17">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="gx-003-go-agent-uses-panics-for-some-errors"><a class="header" href="#gx-003-go-agent-uses-panics-for-some-errors">GX-003: Go agent uses panics for some errors</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/agent/agent.go</code></p>
<p><strong>Description:</strong><br />
Some internal errors use panic instead of returning errors.</p>
<p><strong>Impact:</strong> Can crash applications on unexpected states.</p>
<p><strong>Suggestion:</strong> Convert panics in public entry points to errors; keep panics only for truly unreachable states.</p>
<hr />
<h3 id="gx-004-configuration-parsing-is-complex"><a class="header" href="#gx-004-configuration-parsing-is-complex">GX-004: Configuration parsing is complex</a></h3>
<p><strong>Description:</strong><br />
The agentcfg package has complex unmarshal logic with many edge cases.</p>
<p><strong>Files:</strong></p>
<ul>
<li><code>go/pkg/genx/agentcfg/unmarshal.go</code></li>
<li><code>go/pkg/genx/agentcfg/*_unmarshal_test.go</code></li>
</ul>
<p><strong>Note:</strong> Extensive tests exist, so this is well-covered.</p>
<hr />
<h3 id="gx-006-streaming-tool-call-collection-parity-uncertain"><a class="header" href="#gx-006-streaming-tool-call-collection-parity-uncertain">GX-006: Streaming tool-call collection parity uncertain</a></h3>
<p><strong>Description:</strong><br />
Rust includes <code>collect_tool_calls_streamed</code>, but feature parity with Go streaming tool calls needs verification and tests.</p>
<hr />
<hr />
<h3 id="gx-019-messagechunkclone-drops-tool-calls"><a class="header" href="#gx-019-messagechunkclone-drops-tool-calls">GX-019: MessageChunk.Clone drops tool calls</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/message.go</code></p>
<p><strong>Description:</strong><br />
<code>MessageChunk.Clone()</code> copies <code>Role/Name/Part</code> but never copies <code>ToolCall</code>.</p>
<p><strong>Impact:</strong> Tool-call chunks can be silently lost when cloned.</p>
<p><strong>Suggestion:</strong> Copy <code>c.ToolCall</code> instead of checking <code>chk.ToolCall</code>.</p>
<hr />
<h3 id="gx-020-streambuilder-drops-unknown-tool-calls"><a class="header" href="#gx-020-streambuilder-drops-unknown-tool-calls">GX-020: StreamBuilder drops unknown tool calls</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/stream_builder.go</code></p>
<p><strong>Description:</strong><br />
If a tool call references a tool not found in <code>ModelContext</code>, the chunk is skipped:</p>
<pre><code class="language-go">if !ok { slog.Warn(...); continue }
</code></pre>
<p><strong>Impact:</strong> Tool-call chunks disappear without being forwarded to consumers.</p>
<p><strong>Suggestion:</strong> Emit the chunk anyway or return an error so callers can handle missing tools.</p>
<hr />
<h3 id="gx-021-openai-invoke-drops-usage-metrics"><a class="header" href="#gx-021-openai-invoke-drops-usage-metrics">GX-021: OpenAI Invoke drops usage metrics</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/openai.go</code></p>
<p><strong>Description:</strong><br />
<code>invokeJSONOutput</code> and <code>invokeToolCalls</code> return <code>Usage{}</code> instead of <code>resp.Usage</code>.</p>
<p><strong>Impact:</strong> Usage accounting is always zero for invoke paths.</p>
<p><strong>Suggestion:</strong> Return <code>oaiConvUsage(&amp;resp.Usage)</code> on success.</p>
<hr />
<h3 id="gx-022-generatestream-goroutine-can-leak-on-early-close"><a class="header" href="#gx-022-generatestream-goroutine-can-leak-on-early-close">GX-022: GenerateStream goroutine can leak on early close</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/openai.go</code></p>
<p><strong>Description:</strong><br />
<code>GenerateStream</code> spawns a goroutine reading the OpenAI stream. If the caller closes
the stream early without cancelling the context, the goroutine may continue until
the server ends the stream.</p>
<p><strong>Impact:</strong> Potential goroutine/resource leak in long-running sessions.</p>
<p><strong>Suggestion:</strong> Tie stream close to context cancellation or add a stop channel.</p>
<hr />
<h3 id="gx-023-hexstring-ignores-randread-error"><a class="header" href="#gx-023-hexstring-ignores-randread-error">GX-023: hexString ignores rand.Read error</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/json.go</code></p>
<p><strong>Description:</strong><br />
<code>rand.Read</code> errors are ignored when generating IDs.</p>
<p><strong>Impact:</strong> On RNG failure, ID may be all-zero without error signal.</p>
<p><strong>Suggestion:</strong> Check <code>rand.Read</code> error and fall back or return error.</p>
<hr />
<h2 id="-enhancements-14"><a class="header" href="#-enhancements-14">ğŸ”µ Enhancements</a></h2>
<h3 id="gx-007-add-more-provider-adapters"><a class="header" href="#gx-007-add-more-provider-adapters">GX-007: Add more provider adapters</a></h3>
<p><strong>Description:</strong><br />
Currently supports OpenAI and Gemini. Could add:</p>
<ul>
<li>Anthropic (Claude)</li>
<li>Mistral</li>
<li>Local models (Ollama)</li>
</ul>
<hr />
<h3 id="gx-008-add-retry-logic-to-generators"><a class="header" href="#gx-008-add-retry-logic-to-generators">GX-008: Add retry logic to generators</a></h3>
<p><strong>Description:</strong><br />
No built-in retry for transient failures.</p>
<p><strong>Suggestion:</strong> Add configurable retry with backoff.</p>
<hr />
<h3 id="gx-009-add-requestresponse-logging"><a class="header" href="#gx-009-add-requestresponse-logging">GX-009: Add request/response logging</a></h3>
<p><strong>Description:</strong><br />
No debug logging for API calls.</p>
<p><strong>Suggestion:</strong> Add optional verbose mode.</p>
<hr />
<h3 id="gx-010-document-match-pattern-syntax"><a class="header" href="#gx-010-document-match-pattern-syntax">GX-010: Document match pattern syntax</a></h3>
<p><strong>Description:</strong><br />
Match patterns have complex syntax; documentation exists but should stay in sync.</p>
<p><strong>Files:</strong></p>
<ul>
<li><code>docs/genx/match/</code></li>
<li><code>go/pkg/genx/match/</code></li>
</ul>
<hr />
<h3 id="gx-011-add-validation-for-agent-configs"><a class="header" href="#gx-011-add-validation-for-agent-configs">GX-011: Add validation for agent configs</a></h3>
<p><strong>Description:</strong><br />
YAML configs could have invalid references (<code>$ref</code>). No validation until runtime.</p>
<p><strong>Suggestion:</strong> Add config validation command/function.</p>
<hr />
<h3 id="gx-012-add-configuration-schema-generation"><a class="header" href="#gx-012-add-configuration-schema-generation">GX-012: Add configuration schema generation</a></h3>
<p><strong>Description:</strong><br />
No JSON Schema is provided for agent/tool configuration.</p>
<p><strong>Impact:</strong> No IDE auto-complete or static validation.</p>
<p><strong>Suggestion:</strong> Generate JSON Schema from <code>agentcfg</code> types and publish under <code>docs/</code>.</p>
<hr />
<h3 id="gx-013-add-stream-test-coverage-for-tool-calls-rust"><a class="header" href="#gx-013-add-stream-test-coverage-for-tool-calls-rust">GX-013: Add stream test coverage for tool calls (Rust)</a></h3>
<p><strong>Description:</strong><br />
Tool-call streaming helpers exist, but end-to-end tests are limited or missing.</p>
<p><strong>Impact:</strong> Potential regressions in streamed tool-call parsing.</p>
<p><strong>Suggestion:</strong> Add tests that simulate incremental chunks and verify parsed tool calls.</p>
<hr />
<h3 id="gx-024-streambuildernew-ignores-tools-rust"><a class="header" href="#gx-024-streambuildernew-ignores-tools-rust">GX-024: StreamBuilder::new ignores tools (Rust)</a></h3>
<p><strong>File:</strong> <code>rust/genx/src/stream.rs</code></p>
<p><strong>Description:</strong><br />
<code>StreamBuilder::new</code> ignores tools from <code>ModelContext</code>, leaving <code>func_tools</code> empty.</p>
<p><strong>Impact:</strong> Tool-call metadata cannot be linked unless callers use <code>with_tools</code>.</p>
<p><strong>Suggestion:</strong> Provide a way to downcast tools or pass tool list explicitly in generator code.</p>
<hr />
<h2 id="-notes-14"><a class="header" href="#-notes-14">âšª Notes</a></h2>
<h3 id="gx-014-well-structured-go-implementation"><a class="header" href="#gx-014-well-structured-go-implementation">GX-014: Well-structured Go implementation</a></h3>
<p><strong>Description:</strong><br />
The Go genx package is well-organized:</p>
<ul>
<li>Clear separation of concerns</li>
<li>Extensive test coverage</li>
<li>Comprehensive agent framework</li>
<li>YAML/JSON configuration support</li>
</ul>
<hr />
<h3 id="gx-015-event-based-agent-api"><a class="header" href="#gx-015-event-based-agent-api">GX-015: Event-based agent API</a></h3>
<p><strong>Description:</strong><br />
The agent event system is well-designed:</p>
<pre><code class="language-go">for {
    evt, err := ag.Next()
    switch evt.Type {
    case EventChunk: ...
    case EventToolStart: ...
    case EventClosed: ...
    }
}
</code></pre>
<p>Provides fine-grained control over agent execution.</p>
<hr />
<h3 id="gx-016-quit-tool-pattern"><a class="header" href="#gx-016-quit-tool-pattern">GX-016: Quit tool pattern</a></h3>
<p><strong>Description:</strong><br />
Tools can be marked as "quit tools" to signal agent completion:</p>
<pre><code class="language-yaml">tools:
  - $ref: tool:goodbye
    quit: true
</code></pre>
<p>Useful for conversational agents with explicit exit.</p>
<hr />
<h3 id="gx-017-ref-system-for-configuration"><a class="header" href="#gx-017-ref-system-for-configuration">GX-017: $ref system for configuration</a></h3>
<p><strong>Description:</strong><br />
Configuration supports references for reuse:</p>
<pre><code class="language-yaml">tools:
  - $ref: tool:search  # References registered tool
  - $ref: agent:helper # References registered agent
</code></pre>
<p>Good for modular configuration.</p>
<hr />
<h3 id="gx-018-multi-skill-assistant-pattern"><a class="header" href="#gx-018-multi-skill-assistant-pattern">GX-018: Multi-skill assistant pattern</a></h3>
<p><strong>Description:</strong><br />
MatchAgent enables router pattern:</p>
<pre><code>Router (Match) â†’ Weather Agent (ReAct)
              â†’ Music Agent (ReAct)
              â†’ Chat Agent
</code></pre>
<p>Well-documented in agent/doc.go.</p>
<hr />
<h3 id="gx-025-language-idioms-differ-go-vs-rust"><a class="header" href="#gx-025-language-idioms-differ-go-vs-rust">GX-025: Language idioms differ (Go vs Rust)</a></h3>
<p><strong>Description:</strong><br />
Go uses <code>iter.Seq</code>, Rust uses iterators/streams. This is idiomatic for each language
and not a functional issue.</p>
<hr />
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>GX-001</td><td>ğŸ”´ Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>GX-002</td><td>ğŸ”´ Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>GX-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-004</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Go</td></tr>
<tr><td>GX-006</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Rust</td></tr>
<tr><td>GX-019</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-020</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-021</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-022</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-023</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>GX-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>GX-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Both</td></tr>
<tr><td>GX-010</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-011</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-012</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>GX-013</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Rust</td></tr>
<tr><td>GX-024</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Rust</td></tr>
<tr><td>GX-014</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>GX-015</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>GX-016</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>GX-017</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>GX-018</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>GX-025</td><td>âšª Note</td><td>N/A</td><td>Both</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Go implementation is mature and feature-rich with comprehensive agent framework. Rust implementation provides basic LLM abstraction but lacks the agent framework, making it suitable only for simple use cases. Major effort needed to reach Rust feature parity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-agent-framework"><a class="header" href="#genx-agent-framework">GenX Agent Framework</a></h1>
<p>Framework for building LLM-powered autonomous agents.</p>
<blockquote>
<p><strong>Note:</strong> This package is Go-only. No Rust implementation exists.</p>
</blockquote>
<h2 id="design-goals-19"><a class="header" href="#design-goals-19">Design Goals</a></h2>
<ol>
<li><strong>Flexible Agent Architecture</strong>: Support multiple agent patterns</li>
<li><strong>Event-Based API</strong>: Fine-grained control over agent execution</li>
<li><strong>Tool Orchestration</strong>: Rich tool ecosystem for agents</li>
<li><strong>Multi-Skill Assistants</strong>: Router agents for complex workflows</li>
</ol>
<h2 id="agent-types-1"><a class="header" href="#agent-types-1">Agent Types</a></h2>
<h3 id="reactagent-1"><a class="header" href="#reactagent-1">ReActAgent</a></h3>
<p>Implements the Reasoning and Acting (ReAct) pattern:</p>
<ul>
<li>Thinks step-by-step about user requests</li>
<li>Selects and executes tools to accomplish tasks</li>
<li>Iterative reasoning until task completion</li>
</ul>
<h3 id="matchagent-1"><a class="header" href="#matchagent-1">MatchAgent</a></h3>
<p>Implements intent-based routing:</p>
<ul>
<li>Matches user input against predefined rules</li>
<li>Routes to appropriate sub-agents or actions</li>
<li>Useful for building multi-skill assistants</li>
</ul>
<h2 id="architecture-5"><a class="header" href="#architecture-5">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Agent Interface                          â”‚
â”‚   Input() â†’ Events() â†’ Close()                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚      ReActAgent         â”‚  â”‚      MatchAgent         â”‚  â”‚
â”‚  â”‚                         â”‚  â”‚                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚   Reasoning     â”‚   â”‚  â”‚  â”‚   Rule Matching â”‚   â”‚  â”‚
â”‚  â”‚  â”‚   + Acting      â”‚   â”‚  â”‚  â”‚   + Routing     â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â”‚           â”‚            â”‚  â”‚           â”‚            â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚    Tool Calls   â”‚   â”‚  â”‚  â”‚   Sub-Agents    â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Tool System                             â”‚
â”‚  FuncTool â”‚ GeneratorTool â”‚ HTTPTool â”‚ CompositeTool        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="event-system-1"><a class="header" href="#event-system-1">Event System</a></h2>
<p>Agents communicate through events:</p>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody>
<tr><td><code>EventChunk</code></td><td>Output text chunk</td></tr>
<tr><td><code>EventEOF</code></td><td>Round ended, waiting for input</td></tr>
<tr><td><code>EventClosed</code></td><td>Agent completed (quit tool called)</td></tr>
<tr><td><code>EventToolStart</code></td><td>Tool execution started</td></tr>
<tr><td><code>EventToolDone</code></td><td>Tool completed successfully</td></tr>
<tr><td><code>EventToolError</code></td><td>Tool execution failed</td></tr>
<tr><td><code>EventInterrupted</code></td><td>Agent was interrupted</td></tr>
</tbody></table>
</div>
<h2 id="tool-types-1"><a class="header" href="#tool-types-1">Tool Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>BuiltinTool</code></td><td>Wraps Go functions</td></tr>
<tr><td><code>GeneratorTool</code></td><td>LLM-based generation</td></tr>
<tr><td><code>HTTPTool</code></td><td>HTTP requests with jq extraction</td></tr>
<tr><td><code>CompositeTool</code></td><td>Sequential tool pipeline</td></tr>
<tr><td><code>TextProcessorTool</code></td><td>Text manipulation</td></tr>
</tbody></table>
</div>
<h2 id="quit-tools"><a class="header" href="#quit-tools">Quit Tools</a></h2>
<p>Tools can signal agent completion:</p>
<pre><code class="language-yaml">tools:
  - $ref: tool:goodbye
    quit: true
</code></pre>
<p>When executed, the agent finishes and returns <code>EventClosed</code>.</p>
<h2 id="multi-skill-assistant-pattern"><a class="header" href="#multi-skill-assistant-pattern">Multi-Skill Assistant Pattern</a></h2>
<pre><code>         Router Agent (Match)
        Rules: chat, fortune, music
               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚          â”‚          â”‚
    â–¼          â–¼          â–¼
  Chat      Fortune     Music
  Agent     Agent       Agent
           (ReAct)     (ReAct)
              â”‚           â”‚
          â”Œâ”€â”€â”€â”´â”€â”€â”€â”   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
          â”‚       â”‚   â”‚       â”‚
       lunar   calc  search  play
</code></pre>
<h2 id="related-3"><a class="header" href="#related-3">Related</a></h2>
<ul>
<li>Configuration: <a href="lib/genx/agent/../agentcfg/">../agentcfg/</a></li>
<li>Pattern matching: <a href="lib/genx/agent/../match/">../match/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-agent---go-implementation"><a class="header" href="#genx-agent---go-implementation">GenX Agent - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/genx/agent</code></p>
<h2 id="agent-interface"><a class="header" href="#agent-interface">Agent Interface</a></h2>
<pre><code class="language-go">type Agent interface {
    Input(contents genx.Contents)
    Next() (*AgentEvent, error)
    Close() error
}
</code></pre>
<h2 id="agentevent"><a class="header" href="#agentevent">AgentEvent</a></h2>
<pre><code class="language-go">type AgentEvent struct {
    Type       EventType
    Chunk      *genx.MessageChunk  // EventChunk
    ToolName   string              // EventToolStart/Done/Error
    ToolResult string              // EventToolDone
    ToolError  error               // EventToolError
}

type EventType int

const (
    EventChunk EventType = iota
    EventEOF
    EventClosed
    EventToolStart
    EventToolDone
    EventToolError
    EventInterrupted
)
</code></pre>
<h2 id="reactagent-2"><a class="header" href="#reactagent-2">ReActAgent</a></h2>
<pre><code class="language-go">ag, err := agent.NewReActAgent(runtime, &amp;agentcfg.ReActAgent{
    AgentBase: agentcfg.AgentBase{
        Name:   "assistant",
        Prompt: "You are a helpful assistant.",
        Generator: agentcfg.GeneratorRef{
            Config: &amp;agentcfg.GeneratorConfig{
                Model: "gpt-4",
            },
        },
    },
    Tools: []agentcfg.ToolRef{
        {Ref: "tool:search"},
        {Ref: "tool:calculator"},
    },
})
if err != nil {
    return err
}
defer ag.Close()
</code></pre>
<h2 id="matchagent-2"><a class="header" href="#matchagent-2">MatchAgent</a></h2>
<pre><code class="language-go">ag, err := agent.NewMatchAgent(runtime, &amp;agentcfg.MatchAgent{
    AgentBase: agentcfg.AgentBase{
        Name: "router",
    },
    Rules: []agentcfg.RuleRef{
        {Ref: "rule:weather"},
        {Ref: "rule:music"},
    },
    Route: []agentcfg.MatchRoute{
        {
            Rules: []string{"weather"},
            Agent: agentcfg.AgentRef{Ref: "agent:weather_assistant"},
        },
        {
            Rules: []string{"music"},
            Agent: agentcfg.AgentRef{Ref: "agent:music_player"},
        },
    },
})
</code></pre>
<h2 id="event-loop"><a class="header" href="#event-loop">Event Loop</a></h2>
<pre><code class="language-go">// Provide initial input
ag.Input(genx.Contents{genx.Text("Hello!")})

// Process events
for {
    evt, err := ag.Next()
    if err != nil {
        return err
    }
    
    switch evt.Type {
    case agent.EventChunk:
        // Output chunk
        fmt.Print(evt.Chunk.Part)
        
    case agent.EventEOF:
        // Round ended, provide new input
        fmt.Print("\n&gt; ")
        input := readline()
        ag.Input(genx.Contents{genx.Text(input)})
        
    case agent.EventClosed:
        // Agent completed (quit tool or closed)
        return nil
        
    case agent.EventToolStart:
        fmt.Printf("[Calling %s...]\n", evt.ToolName)
        
    case agent.EventToolDone:
        fmt.Printf("[%s returned: %s]\n", evt.ToolName, evt.ToolResult)
        
    case agent.EventToolError:
        fmt.Printf("[%s error: %v]\n", evt.ToolName, evt.ToolError)
        
    case agent.EventInterrupted:
        return nil
    }
}
</code></pre>
<h2 id="runtime-interface"><a class="header" href="#runtime-interface">Runtime Interface</a></h2>
<pre><code class="language-go">type Runtime interface {
    // Generator returns LLM generator for the given config
    Generator(cfg *agentcfg.GeneratorConfig) (genx.Generator, error)
    
    // Tool creates or retrieves a tool by reference
    Tool(ref string) (Tool, error)
    
    // Agent creates or retrieves an agent by reference
    Agent(ref string) (Agent, error)
    
    // State returns state manager for memory
    State() State
}
</code></pre>
<h2 id="tool-interface"><a class="header" href="#tool-interface">Tool Interface</a></h2>
<pre><code class="language-go">type Tool interface {
    genx.FuncTool
    
    // Execute runs the tool with given arguments
    Execute(ctx context.Context, args json.RawMessage) (string, error)
}
</code></pre>
<h2 id="built-in-tools"><a class="header" href="#built-in-tools">Built-in Tools</a></h2>
<h3 id="generatortool"><a class="header" href="#generatortool">GeneratorTool</a></h3>
<p>LLM-based text/JSON generation:</p>
<pre><code class="language-go">tool := &amp;agent.GeneratorTool{
    Name:        "summarize",
    Description: "Summarize text",
    Prompt:      "Summarize the following:\n{{.text}}",
    Generator:   generatorConfig,
}
</code></pre>
<h3 id="httptool"><a class="header" href="#httptool">HTTPTool</a></h3>
<p>HTTP requests with jq extraction:</p>
<pre><code class="language-go">tool := &amp;agent.HTTPTool{
    Name:        "weather",
    Description: "Get weather data",
    URL:         "https://api.weather.com/v1/current",
    Method:      "GET",
    Params: []agent.HTTPParam{
        {Name: "city", In: "query"},
    },
    Extract: ".data.temperature",
}
</code></pre>
<h3 id="compositetool"><a class="header" href="#compositetool">CompositeTool</a></h3>
<p>Sequential tool pipeline:</p>
<pre><code class="language-go">tool := &amp;agent.CompositeTool{
    Name:        "search_and_summarize",
    Description: "Search and summarize results",
    Steps: []agent.CompositeStep{
        {Tool: "search", OutputVar: "results"},
        {Tool: "summarize", InputVars: map[string]string{"text": "results"}},
    },
}
</code></pre>
<h3 id="textprocessortool"><a class="header" href="#textprocessortool">TextProcessorTool</a></h3>
<p>Text manipulation:</p>
<pre><code class="language-go">tool := &amp;agent.TextProcessorTool{
    Name:        "extract_json",
    Description: "Extract JSON from text",
    Prompt:      "Extract JSON from: {{.input}}",
    OutputType:  "json",
}
</code></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<pre><code class="language-go">type State interface {
    // Get retrieves value by key
    Get(key string) (any, bool)
    
    // Set stores value by key
    Set(key string, value any)
    
    // Memory returns conversation memory
    Memory() []genx.Message
    
    // AppendMemory adds message to memory
    AppendMemory(msg genx.Message)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-agent---known-issues"><a class="header" href="#genx-agent---known-issues">GenX Agent - Known Issues</a></h1>
<h2 id="-major-issues-6"><a class="header" href="#-major-issues-6">ğŸ”´ Major Issues</a></h2>
<h3 id="agt-001-no-rust-implementation"><a class="header" href="#agt-001-no-rust-implementation">AGT-001: No Rust implementation</a></h3>
<p><strong>Description:</strong><br />
The entire agent framework is Go-only. No Rust implementation exists.</p>
<p><strong>Impact:</strong> Cannot build autonomous agents in Rust.</p>
<p><strong>Effort:</strong> High - requires porting entire framework.</p>
<hr />
<h2 id="-minor-issues-18"><a class="header" href="#-minor-issues-18">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="agt-002-some-internal-errors-use-panic"><a class="header" href="#agt-002-some-internal-errors-use-panic">AGT-002: Some internal errors use panic</a></h3>
<p><strong>Description:</strong><br />
Some unexpected states trigger panic instead of returning errors.</p>
<p><strong>Impact:</strong> Can crash applications on edge cases.</p>
<p><strong>Suggestion:</strong> Convert panics to error returns.</p>
<hr />
<h3 id="agt-003-event-loop-complexity"><a class="header" href="#agt-003-event-loop-complexity">AGT-003: Event loop complexity</a></h3>
<p><strong>Description:</strong><br />
The event loop pattern requires careful handling of all event types.</p>
<p><strong>Impact:</strong> Easy to miss edge cases in client code.</p>
<p><strong>Suggestion:</strong> Add helper functions or simplified API.</p>
<hr />
<h3 id="agt-004-tool-execution-is-synchronous"><a class="header" href="#agt-004-tool-execution-is-synchronous">AGT-004: Tool execution is synchronous</a></h3>
<p><strong>Description:</strong><br />
Tools execute synchronously in the event loop, blocking other processing.</p>
<p><strong>Impact:</strong> Long-running tools can delay event delivery.</p>
<p><strong>Suggestion:</strong> Consider async tool execution option.</p>
<hr />
<h2 id="-enhancements-15"><a class="header" href="#-enhancements-15">ğŸ”µ Enhancements</a></h2>
<h3 id="agt-005-add-agent-persistence"><a class="header" href="#agt-005-add-agent-persistence">AGT-005: Add agent persistence</a></h3>
<p><strong>Description:</strong><br />
Agents don't persist state across restarts. State is in-memory only.</p>
<p><strong>Suggestion:</strong> Add state serialization/deserialization.</p>
<hr />
<h3 id="agt-006-add-agent-debugging-tools"><a class="header" href="#agt-006-add-agent-debugging-tools">AGT-006: Add agent debugging tools</a></h3>
<p><strong>Description:</strong><br />
Limited visibility into agent reasoning and tool selection.</p>
<p><strong>Suggestion:</strong> Add verbose mode, step-through debugging.</p>
<hr />
<h3 id="agt-007-add-rate-limiting-for-tools"><a class="header" href="#agt-007-add-rate-limiting-for-tools">AGT-007: Add rate limiting for tools</a></h3>
<p><strong>Description:</strong><br />
No built-in rate limiting for tool calls.</p>
<p><strong>Suggestion:</strong> Add configurable rate limiting per tool.</p>
<hr />
<h3 id="agt-008-add-tool-result-caching"><a class="header" href="#agt-008-add-tool-result-caching">AGT-008: Add tool result caching</a></h3>
<p><strong>Description:</strong><br />
Same tool calls aren't cached, even with identical inputs.</p>
<p><strong>Suggestion:</strong> Add optional result caching.</p>
<hr />
<h2 id="-notes-15"><a class="header" href="#-notes-15">âšª Notes</a></h2>
<h3 id="agt-009-well-designed-event-system"><a class="header" href="#agt-009-well-designed-event-system">AGT-009: Well-designed event system</a></h3>
<p><strong>Description:</strong><br />
The event-based API provides excellent control:</p>
<ul>
<li>Streaming output chunks</li>
<li>Tool execution visibility</li>
<li>Clean termination signals</li>
</ul>
<hr />
<h3 id="agt-010-quit-tool-pattern"><a class="header" href="#agt-010-quit-tool-pattern">AGT-010: Quit tool pattern</a></h3>
<p><strong>Description:</strong><br />
The quit tool pattern is elegant:</p>
<pre><code class="language-yaml">tools:
  - $ref: tool:goodbye
    quit: true
</code></pre>
<p>Allows explicit agent termination.</p>
<hr />
<h3 id="agt-011-multi-agent-routing"><a class="header" href="#agt-011-multi-agent-routing">AGT-011: Multi-agent routing</a></h3>
<p><strong>Description:</strong><br />
MatchAgent enables complex multi-skill architectures:</p>
<pre><code>Router â†’ Weather Agent
       â†’ Music Agent  
       â†’ Chat Agent
</code></pre>
<hr />
<h3 id="agt-012-comprehensive-tool-types"><a class="header" href="#agt-012-comprehensive-tool-types">AGT-012: Comprehensive tool types</a></h3>
<p><strong>Description:</strong><br />
Rich tool ecosystem:</p>
<ul>
<li>FuncTool (Go functions)</li>
<li>GeneratorTool (LLM)</li>
<li>HTTPTool (API calls)</li>
<li>CompositeTool (pipelines)</li>
<li>TextProcessorTool</li>
</ul>
<hr />
<h2 id="summary-15"><a class="header" href="#summary-15">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>AGT-001</td><td>ğŸ”´ Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>AGT-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>AGT-009</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>AGT-010</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>AGT-011</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>AGT-012</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Mature Go implementation with well-designed architecture. Main limitation is Go-only - no Rust support.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-agent-configuration"><a class="header" href="#genx-agent-configuration">GenX Agent Configuration</a></h1>
<p>Configuration parsing and serialization for agents and tools.</p>
<blockquote>
<p><strong>Note:</strong> This package is Go-only. No Rust implementation exists.</p>
</blockquote>
<h2 id="design-goals-20"><a class="header" href="#design-goals-20">Design Goals</a></h2>
<ol>
<li><strong>Declarative Configuration</strong>: Define agents/tools in YAML/JSON</li>
<li><strong>Reference System</strong>: Support <code>$ref</code> for reusable components</li>
<li><strong>Validation</strong>: Validate configuration at parse time</li>
<li><strong>Serialization</strong>: Support JSON, YAML, and MessagePack</li>
</ol>
<h2 id="configuration-types"><a class="header" href="#configuration-types">Configuration Types</a></h2>
<h3 id="agent-types-2"><a class="header" href="#agent-types-2">Agent Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Configuration</th></tr></thead><tbody>
<tr><td><code>react</code></td><td>ReAct pattern agent</td><td><code>ReActAgent</code></td></tr>
<tr><td><code>match</code></td><td>Router/matcher agent</td><td><code>MatchAgent</code></td></tr>
</tbody></table>
</div>
<h3 id="tool-types-2"><a class="header" href="#tool-types-2">Tool Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Configuration</th></tr></thead><tbody>
<tr><td><code>http</code></td><td>HTTP API tool</td><td><code>HTTPTool</code></td></tr>
<tr><td><code>generator</code></td><td>LLM generation tool</td><td><code>GeneratorTool</code></td></tr>
<tr><td><code>composite</code></td><td>Tool pipeline</td><td><code>CompositeTool</code></td></tr>
<tr><td><code>text_processor</code></td><td>Text manipulation</td><td><code>TextProcessorTool</code></td></tr>
</tbody></table>
</div>
<h2 id="reference-system"><a class="header" href="#reference-system">Reference System</a></h2>
<p>The <code>$ref</code> system allows reusing components:</p>
<pre><code class="language-yaml"># Reference an agent
agent:
  $ref: agent:weather_assistant

# Reference a tool
tools:
  - $ref: tool:search
  - $ref: tool:calculator
</code></pre>
<p>Reference format: <code>{type}:{name}</code></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>agent:{name}</code></td><td>Reference to registered agent</td></tr>
<tr><td><code>tool:{name}</code></td><td>Reference to registered tool</td></tr>
<tr><td><code>rule:{name}</code></td><td>Reference to match rule</td></tr>
<tr><td><code>prompt:{name}</code></td><td>Reference to prompt template</td></tr>
</tbody></table>
</div>
<h2 id="configuration-structure"><a class="header" href="#configuration-structure">Configuration Structure</a></h2>
<h3 id="reactagent-3"><a class="header" href="#reactagent-3">ReActAgent</a></h3>
<pre><code class="language-yaml">type: react
name: assistant
prompt: |
  You are a helpful assistant.
generator:
  model: gpt-4
  temperature: 0.7
context_layers:
  - type: env
    vars: ["USER_NAME"]
  - type: mem
    limit: 10
tools:
  - $ref: tool:search
    quit: false
  - $ref: tool:goodbye
    quit: true
</code></pre>
<h3 id="matchagent-3"><a class="header" href="#matchagent-3">MatchAgent</a></h3>
<pre><code class="language-yaml">type: match
name: router
rules:
  - $ref: rule:weather
  - $ref: rule:music
route:
  - rules: [weather]
    agent:
      $ref: agent:weather_assistant
  - rules: [music]
    agent:
      type: react
      name: music_inline
      prompt: |
        You are a music assistant.
default:
  $ref: agent:chat
</code></pre>
<h3 id="httptool-1"><a class="header" href="#httptool-1">HTTPTool</a></h3>
<pre><code class="language-yaml">type: http
name: weather_api
description: Get weather data
url: https://api.weather.com/v1/current
method: GET
headers:
  Authorization: "Bearer {{.api_key}}"
params:
  - name: city
    in: query
    required: true
  - name: units
    in: query
    default: "metric"
extract: .data.temperature
</code></pre>
<h3 id="generatortool-1"><a class="header" href="#generatortool-1">GeneratorTool</a></h3>
<pre><code class="language-yaml">type: generator
name: summarize
description: Summarize text
prompt: |
  Summarize the following text in 2-3 sentences:
  {{.text}}
generator:
  model: gpt-3.5-turbo
</code></pre>
<h3 id="compositetool-1"><a class="header" href="#compositetool-1">CompositeTool</a></h3>
<pre><code class="language-yaml">type: composite
name: search_and_summarize
description: Search and summarize
steps:
  - tool: search
    output_var: results
  - tool: summarize
    input_vars:
      text: results
</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Configuration is validated during parsing:</p>
<ul>
<li>Required fields checked</li>
<li>Type consistency verified</li>
<li>References validated (at runtime)</li>
<li>Enum values validated</li>
</ul>
<h2 id="related-4"><a class="header" href="#related-4">Related</a></h2>
<ul>
<li>Agent framework: <a href="lib/genx/agentcfg/../agent/">../agent/</a></li>
<li>Pattern matching: <a href="lib/genx/agentcfg/../match/">../match/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-agent-configuration---go-implementation"><a class="header" href="#genx-agent-configuration---go-implementation">GenX Agent Configuration - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/genx/agentcfg</code></p>
<h2 id="agent-types-3"><a class="header" href="#agent-types-3">Agent Types</a></h2>
<h3 id="agent-interface-1"><a class="header" href="#agent-interface-1">Agent Interface</a></h3>
<pre><code class="language-go">type Agent interface {
    AgentName() string
    AgentType() AgentType
}
</code></pre>
<h3 id="agentbase"><a class="header" href="#agentbase">AgentBase</a></h3>
<pre><code class="language-go">type AgentBase struct {
    Type          AgentType      `json:"type,omitzero"`
    Name          string         `json:"name"`
    Prompt        string         `json:"prompt,omitzero"`
    ContextLayers []ContextLayer `json:"context_layers,omitzero"`
    Generator     GeneratorRef   `json:"generator,omitzero"`
}
</code></pre>
<h3 id="reactagent-4"><a class="header" href="#reactagent-4">ReActAgent</a></h3>
<pre><code class="language-go">type ReActAgent struct {
    AgentBase
    Tools []ToolRef `json:"tools,omitzero"`
}
</code></pre>
<h3 id="matchagent-4"><a class="header" href="#matchagent-4">MatchAgent</a></h3>
<pre><code class="language-go">type MatchAgent struct {
    AgentBase
    Rules   []RuleRef    `json:"rules,omitzero"`
    Route   []MatchRoute `json:"route,omitzero"`
    Default *AgentRef    `json:"default,omitzero"`
}
</code></pre>
<h2 id="tool-types-3"><a class="header" href="#tool-types-3">Tool Types</a></h2>
<h3 id="toolref"><a class="header" href="#toolref">ToolRef</a></h3>
<pre><code class="language-go">type ToolRef struct {
    Ref  string `json:"$ref,omitzero"`
    Quit bool   `json:"quit,omitzero"`
    Tool Tool   `json:"-"`  // Inline definition
}
</code></pre>
<h3 id="httptool-2"><a class="header" href="#httptool-2">HTTPTool</a></h3>
<pre><code class="language-go">type HTTPTool struct {
    ToolBase
    URL       string         `json:"url"`
    Method    string         `json:"method,omitzero"`
    Headers   map[string]string `json:"headers,omitzero"`
    Params    []HTTPParam    `json:"params,omitzero"`
    Body      string         `json:"body,omitzero"`
    Extract   string         `json:"extract,omitzero"`  // jq expression
}

type HTTPParam struct {
    Name     string `json:"name"`
    In       string `json:"in"`  // "query", "path", "header"
    Required bool   `json:"required,omitzero"`
    Default  string `json:"default,omitzero"`
}
</code></pre>
<h3 id="generatortool-2"><a class="header" href="#generatortool-2">GeneratorTool</a></h3>
<pre><code class="language-go">type GeneratorTool struct {
    ToolBase
    Prompt    string        `json:"prompt"`
    Generator GeneratorRef  `json:"generator"`
    Schema    string        `json:"schema,omitzero"`  // JSON Schema for output
}
</code></pre>
<h3 id="compositetool-2"><a class="header" href="#compositetool-2">CompositeTool</a></h3>
<pre><code class="language-go">type CompositeTool struct {
    ToolBase
    Steps []CompositeStep `json:"steps"`
}

type CompositeStep struct {
    Tool      string            `json:"tool"`
    InputVars map[string]string `json:"input_vars,omitzero"`
    OutputVar string            `json:"output_var,omitzero"`
}
</code></pre>
<h3 id="textprocessortool-1"><a class="header" href="#textprocessortool-1">TextProcessorTool</a></h3>
<pre><code class="language-go">type TextProcessorTool struct {
    ToolBase
    Prompt     string       `json:"prompt"`
    Generator  GeneratorRef `json:"generator"`
    OutputType string       `json:"output_type,omitzero"`  // "text", "json"
}
</code></pre>
<h2 id="reference-types"><a class="header" href="#reference-types">Reference Types</a></h2>
<h3 id="agentref"><a class="header" href="#agentref">AgentRef</a></h3>
<pre><code class="language-go">type AgentRef struct {
    Ref   string `json:"$ref,omitzero"`
    Agent Agent  `json:"-"`  // Inline definition
}

func (a *AgentRef) IsRef() bool
func (a *AgentRef) IsEmpty() bool
</code></pre>
<h3 id="generatorref"><a class="header" href="#generatorref">GeneratorRef</a></h3>
<pre><code class="language-go">type GeneratorRef struct {
    Ref    string           `json:"$ref,omitzero"`
    Config *GeneratorConfig `json:"-"`
}

type GeneratorConfig struct {
    Model       string  `json:"model"`
    Temperature float32 `json:"temperature,omitzero"`
    MaxTokens   int     `json:"max_tokens,omitzero"`
}
</code></pre>
<h3 id="ruleref"><a class="header" href="#ruleref">RuleRef</a></h3>
<pre><code class="language-go">type RuleRef struct {
    Ref  string      `json:"$ref,omitzero"`
    Rule *match.Rule `json:"-"`
}
</code></pre>
<h2 id="context-layers"><a class="header" href="#context-layers">Context Layers</a></h2>
<pre><code class="language-go">type ContextLayer interface {
    LayerType() ContextLayerType
}

type EnvContextLayer struct {
    Vars []string `json:"vars"`
}

type MemContextLayer struct {
    Limit int `json:"limit"`
}

type PromptContextLayer struct {
    Ref  string `json:"$ref,omitzero"`
    Text string `json:"text,omitzero"`
}
</code></pre>
<h2 id="parsing"><a class="header" href="#parsing">Parsing</a></h2>
<h3 id="parse-agent"><a class="header" href="#parse-agent">Parse Agent</a></h3>
<pre><code class="language-go">// From JSON/YAML bytes
agent, err := agentcfg.UnmarshalAgent(data)

// Type assertion
if react := agentcfg.AsReActAgent(agent); react != nil {
    // Handle ReActAgent
}
if match := agentcfg.AsMatchAgent(agent); match != nil {
    // Handle MatchAgent
}
</code></pre>
<h3 id="parse-tool"><a class="header" href="#parse-tool">Parse Tool</a></h3>
<pre><code class="language-go">tool, err := agentcfg.UnmarshalTool(data)
</code></pre>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Supports JSON, YAML, and MessagePack:</p>
<pre><code class="language-go">// JSON
data, err := json.Marshal(agent)
err = json.Unmarshal(data, &amp;agent)

// YAML
data, err := yaml.Marshal(agent)
err = yaml.Unmarshal(data, &amp;agent)

// MessagePack
data, err := msgpack.Marshal(agent)
err = msgpack.Unmarshal(data, &amp;agent)
</code></pre>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<p>Validation happens during unmarshal:</p>
<pre><code class="language-go">// This will return error if validation fails
err := json.Unmarshal(data, &amp;agent)
// err: "react agent: name is required"
</code></pre>
<p>Validation rules:</p>
<ul>
<li>Agent name is required</li>
<li>Tool name and description required</li>
<li>HTTPTool URL required</li>
<li>GeneratorTool prompt and model required</li>
<li>CompositeTool must have steps</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-agent-configuration---known-issues"><a class="header" href="#genx-agent-configuration---known-issues">GenX Agent Configuration - Known Issues</a></h1>
<h2 id="-major-issues-7"><a class="header" href="#-major-issues-7">ğŸ”´ Major Issues</a></h2>
<h3 id="cfg-001-no-rust-implementation"><a class="header" href="#cfg-001-no-rust-implementation">CFG-001: No Rust implementation</a></h3>
<p><strong>Description:</strong><br />
No Rust configuration parser exists.</p>
<p><strong>Impact:</strong> Cannot define agents in Rust via config files.</p>
<hr />
<h2 id="-minor-issues-19"><a class="header" href="#-minor-issues-19">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="cfg-002-complex-unmarshal-logic"><a class="header" href="#cfg-002-complex-unmarshal-logic">CFG-002: Complex unmarshal logic</a></h3>
<p><strong>File:</strong> <code>go/pkg/genx/agentcfg/unmarshal.go</code></p>
<p><strong>Description:</strong><br />
The unmarshal logic handles many edge cases and type variations.</p>
<p><strong>Note:</strong> Well-tested (see <code>*_unmarshal_test.go</code> files).</p>
<hr />
<h3 id="cfg-003-reference-resolution-at-runtime"><a class="header" href="#cfg-003-reference-resolution-at-runtime">CFG-003: Reference resolution at runtime</a></h3>
<p><strong>Description:</strong><br />
<code>$ref</code> references are only validated at runtime, not parse time.</p>
<p><strong>Impact:</strong> Invalid references fail late.</p>
<p><strong>Suggestion:</strong> Add config validation command.</p>
<hr />
<h3 id="cfg-004-no-schema-generation"><a class="header" href="#cfg-004-no-schema-generation">CFG-004: No schema generation</a></h3>
<p><strong>Description:</strong><br />
No JSON Schema generation for config files.</p>
<p><strong>Impact:</strong> No IDE autocompletion support.</p>
<p><strong>Suggestion:</strong> Generate JSON Schema from types.</p>
<hr />
<h2 id="-enhancements-16"><a class="header" href="#-enhancements-16">ğŸ”µ Enhancements</a></h2>
<h3 id="cfg-005-add-config-inheritance"><a class="header" href="#cfg-005-add-config-inheritance">CFG-005: Add config inheritance</a></h3>
<p><strong>Description:</strong><br />
No way to extend/inherit agent configs.</p>
<p><strong>Suggestion:</strong> Add <code>extends</code> field:</p>
<pre><code class="language-yaml">extends: base_agent
name: specialized
</code></pre>
<hr />
<h3 id="cfg-006-add-config-includes"><a class="header" href="#cfg-006-add-config-includes">CFG-006: Add config includes</a></h3>
<p><strong>Description:</strong><br />
No way to include external config files.</p>
<p><strong>Suggestion:</strong> Add <code>$include</code> directive:</p>
<pre><code class="language-yaml">tools:
  - $include: common_tools.yaml
</code></pre>
<hr />
<h3 id="cfg-007-add-environment-variable-substitution"><a class="header" href="#cfg-007-add-environment-variable-substitution">CFG-007: Add environment variable substitution</a></h3>
<p><strong>Description:</strong><br />
No way to use env vars in config values.</p>
<p><strong>Suggestion:</strong> Support <code>${ENV_VAR}</code> syntax.</p>
<hr />
<h3 id="cfg-008-add-config-diffmerge"><a class="header" href="#cfg-008-add-config-diffmerge">CFG-008: Add config diff/merge</a></h3>
<p><strong>Description:</strong><br />
No utilities for comparing or merging configs.</p>
<hr />
<h2 id="-notes-16"><a class="header" href="#-notes-16">âšª Notes</a></h2>
<h3 id="cfg-009-comprehensive-type-system"><a class="header" href="#cfg-009-comprehensive-type-system">CFG-009: Comprehensive type system</a></h3>
<p><strong>Description:</strong><br />
Rich type system covering:</p>
<ul>
<li>Agent types (react, match)</li>
<li>Tool types (http, generator, composite, text_processor)</li>
<li>Reference system ($ref)</li>
<li>Context layers</li>
</ul>
<hr />
<h3 id="cfg-010-multi-format-support"><a class="header" href="#cfg-010-multi-format-support">CFG-010: Multi-format support</a></h3>
<p><strong>Description:</strong><br />
Supports JSON, YAML, and MessagePack serialization.</p>
<hr />
<h3 id="cfg-011-extensive-test-coverage"><a class="header" href="#cfg-011-extensive-test-coverage">CFG-011: Extensive test coverage</a></h3>
<p><strong>Description:</strong><br />
Comprehensive test files:</p>
<ul>
<li><code>agent_marshal_test.go</code></li>
<li><code>agent_unmarshal_test.go</code></li>
<li><code>tool_marshal_test.go</code></li>
<li><code>tool_unmarshal_test.go</code></li>
<li><code>testdata/</code> with JSON/YAML examples</li>
</ul>
<hr />
<h3 id="cfg-012-validation-during-unmarshal"><a class="header" href="#cfg-012-validation-during-unmarshal">CFG-012: Validation during unmarshal</a></h3>
<p><strong>Description:</strong><br />
Validation happens automatically during JSON/YAML unmarshal.</p>
<pre><code class="language-go">err := json.Unmarshal(data, &amp;agent)
// Validates required fields, types, etc.
</code></pre>
<hr />
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>CFG-001</td><td>ğŸ”´ Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>CFG-002</td><td>ğŸŸ¡ Minor</td><td>Note</td><td>Go</td></tr>
<tr><td>CFG-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>CFG-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>CFG-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>CFG-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>CFG-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>CFG-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>CFG-009</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>CFG-010</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>CFG-011</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>CFG-012</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Well-designed configuration system with comprehensive type coverage. Main limitation is Go-only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-match---pattern-matching-engine"><a class="header" href="#genx-match---pattern-matching-engine">GenX Match - Pattern Matching Engine</a></h1>
<p>LLM-based intent recognition and pattern matching.</p>
<blockquote>
<p><strong>Note:</strong> This package is Go-only. No Rust implementation exists.</p>
</blockquote>
<h2 id="design-goals-21"><a class="header" href="#design-goals-21">Design Goals</a></h2>
<ol>
<li><strong>Intent Recognition</strong>: Match user input to predefined intents</li>
<li><strong>Variable Extraction</strong>: Extract structured data from natural language</li>
<li><strong>Streaming Output</strong>: Process matches as they arrive</li>
<li><strong>LLM-Powered</strong>: Use LLM for flexible matching</li>
</ol>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<pre><code>Rules + User Input â†’ LLM â†’ Structured Output
                           â†“
                      "rule_name: var1=value1, var2=value2"
</code></pre>
<ol>
<li><strong>Compile</strong>: Rules are compiled into a system prompt</li>
<li><strong>Match</strong>: User input is sent to LLM with the prompt</li>
<li><strong>Parse</strong>: Output lines are parsed into structured Results</li>
</ol>
<h2 id="rule-definition"><a class="header" href="#rule-definition">Rule Definition</a></h2>
<h3 id="basic-rule"><a class="header" href="#basic-rule">Basic Rule</a></h3>
<pre><code class="language-yaml">name: weather
patterns:
  - æŸ¥å¤©æ°”
  - ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·
  - æ˜å¤©ä¸‹é›¨å—
</code></pre>
<h3 id="rule-with-variables"><a class="header" href="#rule-with-variables">Rule with Variables</a></h3>
<pre><code class="language-yaml">name: music
vars:
  title:
    label: æ­Œæ›²å
    type: string
  artist:
    label: æ­Œæ‰‹
    type: string
patterns:
  - æ’­æ”¾æ­Œæ›²
  - æˆ‘æƒ³å¬æ­Œ
  - ["æˆ‘æƒ³å¬[title]", "title=[æ­Œæ›²å]"]
  - ["æˆ‘æƒ³å¬[artist]çš„æ­Œ", "artist=[æ­Œæ‰‹]"]
  - ["æˆ‘æƒ³å¬[artist]çš„[title]", "artist=[æ­Œæ‰‹], title=[æ­Œæ›²å]"]
</code></pre>
<h3 id="pattern-format"><a class="header" href="#pattern-format">Pattern Format</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td>String</td><td>Simple pattern, no vars</td><td><code>"æ’­æ”¾æ­Œæ›²"</code></td></tr>
<tr><td>Array <code>[input, output]</code></td><td>Pattern with expected output</td><td><code>["æˆ‘æƒ³å¬[title]", "title=[æ­Œæ›²å]"]</code></td></tr>
</tbody></table>
</div>
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<p>LLM outputs one line per match:</p>
<pre><code>rule_name: var1=value1, var2=value2
</code></pre>
<p>Examples:</p>
<ul>
<li><code>weather</code> (no variables)</li>
<li><code>music: artist=å‘¨æ°ä¼¦</code> (one variable)</li>
<li><code>music: artist=å‘¨æ°ä¼¦, title=ç¨»é¦™</code> (multiple variables)</li>
</ul>
<h2 id="variable-types"><a class="header" href="#variable-types">Variable Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Parsing</th></tr></thead><tbody>
<tr><td><code>string</code></td><td>Text (default)</td><td>As-is</td></tr>
<tr><td><code>int</code></td><td>Integer</td><td><code>strconv.ParseInt</code></td></tr>
<tr><td><code>float</code></td><td>Floating point</td><td><code>strconv.ParseFloat</code></td></tr>
<tr><td><code>bool</code></td><td>Boolean</td><td><code>strconv.ParseBool</code></td></tr>
</tbody></table>
</div>
<h2 id="architecture-6"><a class="header" href="#architecture-6">Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Rules                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   weather   â”‚ â”‚    music    â”‚ â”‚    chat     â”‚        â”‚
â”‚  â”‚   patterns  â”‚ â”‚   vars      â”‚ â”‚   patterns  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                     Compile()
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Matcher                            â”‚
â”‚                   (System Prompt)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                Match(ctx, input, mctx)
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         LLM                              â”‚
â”‚              (Generates structured output)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   iter.Seq2[Result]                      â”‚
â”‚      Rule: "music", Args: {artist: "å‘¨æ°ä¼¦"}             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="integration-with-matchagent"><a class="header" href="#integration-with-matchagent">Integration with MatchAgent</a></h2>
<p>The match package is used by MatchAgent for intent routing:</p>
<pre><code class="language-yaml"># MatchAgent config
type: match
name: router
rules:
  - $ref: rule:weather
  - $ref: rule:music
route:
  - rules: [weather]
    agent: $ref: agent:weather_assistant
  - rules: [music]
    agent: $ref: agent:music_player
</code></pre>
<h2 id="related-5"><a class="header" href="#related-5">Related</a></h2>
<ul>
<li>Agent framework: <a href="lib/genx/match/../agent/">../agent/</a></li>
<li>Configuration: <a href="lib/genx/match/../agentcfg/">../agentcfg/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-match---go-implementation"><a class="header" href="#genx-match---go-implementation">GenX Match - Go Implementation</a></h1>
<p>Import: <code>github.com/haivivi/giztoy/pkg/genx/match</code></p>
<h2 id="rule-definition-1"><a class="header" href="#rule-definition-1">Rule Definition</a></h2>
<h3 id="rule-struct"><a class="header" href="#rule-struct">Rule Struct</a></h3>
<pre><code class="language-go">type Rule struct {
    Name     string         `yaml:"name"`
    Vars     map[string]Var `yaml:"vars,omitempty"`
    Patterns []Pattern      `yaml:"patterns"`
    Examples []Example      `yaml:"examples,omitempty"`
}

type Var struct {
    Label string `yaml:"label"`
    Type  string `yaml:"type"`  // "string", "int", "float", "bool"
}

type Pattern struct {
    Input  string
    Output string
}

type Example struct {
    Input  string
    Output string
}
</code></pre>
<h3 id="creating-rules"><a class="header" href="#creating-rules">Creating Rules</a></h3>
<pre><code class="language-go">// Programmatically
rule := &amp;match.Rule{
    Name: "music",
    Vars: map[string]match.Var{
        "title":  {Label: "æ­Œæ›²å", Type: "string"},
        "artist": {Label: "æ­Œæ‰‹", Type: "string"},
    },
    Patterns: []match.Pattern{
        {Input: "æ’­æ”¾æ­Œæ›²"},
        {Input: "æˆ‘æƒ³å¬[title]", Output: "title=[æ­Œæ›²å]"},
        {Input: "æˆ‘æƒ³å¬[artist]çš„[title]", Output: "artist=[æ­Œæ‰‹], title=[æ­Œæ›²å]"},
    },
}

// From YAML
var rule match.Rule
err := yaml.Unmarshal(data, &amp;rule)
</code></pre>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<pre><code class="language-go">rules := []*match.Rule{weatherRule, musicRule, chatRule}

matcher, err := match.Compile(rules)
if err != nil {
    return err
}

// Optional: custom prompt template
matcher, err := match.Compile(rules, match.WithTpl(customTemplate))
</code></pre>
<h2 id="matching"><a class="header" href="#matching">Matching</a></h2>
<h3 id="basic-match"><a class="header" href="#basic-match">Basic Match</a></h3>
<pre><code class="language-go">// Build model context with user input
mcb := &amp;genx.ModelContextBuilder{}
mcb.UserText("user", "æˆ‘æƒ³å¬å‘¨æ°ä¼¦çš„ç¨»é¦™")
mctx := mcb.Build()

// Match against rules
for result, err := range matcher.Match(ctx, "gpt-4", mctx) {
    if err != nil {
        return err
    }
    
    fmt.Printf("Rule: %s\n", result.Rule)
    for name, arg := range result.Args {
        if arg.HasValue {
            fmt.Printf("  %s = %v\n", name, arg.Value)
        }
    }
}
</code></pre>
<h3 id="with-custom-generator"><a class="header" href="#with-custom-generator">With Custom Generator</a></h3>
<pre><code class="language-go">gen := generators.NewOpenAIGenerator(apiKey)

for result, err := range matcher.Match(ctx, "gpt-4", mctx, 
    match.WithGenerator(gen)) {
    // ...
}
</code></pre>
<h3 id="collect-all-results"><a class="header" href="#collect-all-results">Collect All Results</a></h3>
<pre><code class="language-go">results, err := match.Collect(matcher.Match(ctx, "gpt-4", mctx))
if err != nil {
    return err
}
for _, r := range results {
    fmt.Println(r.Rule)
}
</code></pre>
<h2 id="result-structure"><a class="header" href="#result-structure">Result Structure</a></h2>
<pre><code class="language-go">type Result struct {
    // Rule is the matched rule name. Empty if no rule matched.
    Rule string
    
    // Args holds the extracted arguments, keyed by variable name.
    Args map[string]Arg
    
    // RawText holds the original line when no rule matched.
    RawText string
}

type Arg struct {
    // Value is the extracted value, typed according to Var.Type.
    Value any
    
    // Var is the variable definition from the rule.
    Var Var
    
    // HasValue indicates whether a value was successfully extracted.
    HasValue bool
}
</code></pre>
<h2 id="processing-results"><a class="header" href="#processing-results">Processing Results</a></h2>
<pre><code class="language-go">for result, err := range matcher.Match(ctx, model, mctx) {
    if err != nil {
        return err
    }
    
    switch result.Rule {
    case "weather":
        handleWeather()
        
    case "music":
        title := ""
        artist := ""
        if arg, ok := result.Args["title"]; ok &amp;&amp; arg.HasValue {
            title = arg.Value.(string)
        }
        if arg, ok := result.Args["artist"]; ok &amp;&amp; arg.HasValue {
            artist = arg.Value.(string)
        }
        handleMusic(artist, title)
        
    case "":
        // No rule matched
        if result.RawText != "" {
            handleUnknown(result.RawText)
        }
    }
}
</code></pre>
<h2 id="yaml-rule-format"><a class="header" href="#yaml-rule-format">YAML Rule Format</a></h2>
<pre><code class="language-yaml"># rule.yaml
name: music
vars:
  title:
    label: æ­Œæ›²å
    type: string
  artist:
    label: æ­Œæ‰‹
    type: string
patterns:
  # Simple patterns (no variables)
  - æ’­æ”¾æ­Œæ›²
  - æˆ‘æƒ³å¬æ­Œ
  
  # Patterns with variables (array format)
  - ["æˆ‘æƒ³å¬[title]", "title=[æ­Œæ›²å]"]
  - ["æˆ‘æƒ³å¬[artist]çš„æ­Œ", "artist=[æ­Œæ‰‹]"]
  - ["æˆ‘æƒ³å¬[artist]çš„[title]", "artist=[æ­Œæ‰‹], title=[æ­Œæ›²å]"]

examples:
  - input: "æˆ‘æƒ³å¬å‘¨æ°ä¼¦çš„ç¨»é¦™"
    output: "music: artist=å‘¨æ°ä¼¦, title=ç¨»é¦™"
  - input: "æ¥é¦–æ­Œ"
    output: "music"
</code></pre>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<pre><code class="language-go">// Get the compiled system prompt
prompt := matcher.SystemPrompt()
fmt.Println(prompt)
</code></pre>
<h2 id="custom-prompt-template"><a class="header" href="#custom-prompt-template">Custom Prompt Template</a></h2>
<pre><code class="language-go">customTpl := `
ä½ æ˜¯ä¸€ä¸ªæ„å›¾è¯†åˆ«åŠ©æ‰‹ã€‚
{{range .Rules}}
## {{.Name}}
{{range .Patterns}}
- {{.Input}} â†’ {{.Output}}
{{end}}
{{end}}
`

matcher, err := match.Compile(rules, match.WithTpl(customTpl))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genx-match---known-issues"><a class="header" href="#genx-match---known-issues">GenX Match - Known Issues</a></h1>
<h2 id="-major-issues-8"><a class="header" href="#-major-issues-8">ğŸ”´ Major Issues</a></h2>
<h3 id="mth-001-no-rust-implementation"><a class="header" href="#mth-001-no-rust-implementation">MTH-001: No Rust implementation</a></h3>
<p><strong>Description:</strong><br />
No Rust pattern matching implementation exists.</p>
<p><strong>Impact:</strong> Cannot use pattern matching in Rust.</p>
<hr />
<h2 id="-minor-issues-20"><a class="header" href="#-minor-issues-20">ğŸŸ¡ Minor Issues</a></h2>
<h3 id="mth-002-llm-dependent-accuracy"><a class="header" href="#mth-002-llm-dependent-accuracy">MTH-002: LLM-dependent accuracy</a></h3>
<p><strong>Description:</strong><br />
Match quality depends on LLM capability. May produce unexpected results with weaker models.</p>
<p><strong>Impact:</strong> Inconsistent matching across different LLMs.</p>
<p><strong>Suggestion:</strong> Add model-specific prompt tuning.</p>
<hr />
<h3 id="mth-003-no-offline-matching"><a class="header" href="#mth-003-no-offline-matching">MTH-003: No offline matching</a></h3>
<p><strong>Description:</strong><br />
All matching requires LLM API call. No local/offline fallback.</p>
<p><strong>Impact:</strong> Latency and cost for every match operation.</p>
<p><strong>Suggestion:</strong> Add regex-based fast path for simple patterns.</p>
<hr />
<h3 id="mth-004-pattern-syntax-not-documented"><a class="header" href="#mth-004-pattern-syntax-not-documented">MTH-004: Pattern syntax not documented</a></h3>
<p><strong>Description:</strong><br />
The <code>[variable]</code> syntax in patterns has implicit rules not fully documented.</p>
<p><strong>Files:</strong></p>
<ul>
<li><code>go/pkg/genx/match/rule.go</code></li>
</ul>
<hr />
<h2 id="-enhancements-17"><a class="header" href="#-enhancements-17">ğŸ”µ Enhancements</a></h2>
<h3 id="mth-005-add-pattern-validation"><a class="header" href="#mth-005-add-pattern-validation">MTH-005: Add pattern validation</a></h3>
<p><strong>Description:</strong><br />
No validation that patterns are syntactically correct.</p>
<p><strong>Suggestion:</strong> Validate <code>[var]</code> references match defined vars.</p>
<hr />
<h3 id="mth-006-add-confidence-scores"><a class="header" href="#mth-006-add-confidence-scores">MTH-006: Add confidence scores</a></h3>
<p><strong>Description:</strong><br />
No confidence score for matches.</p>
<p><strong>Suggestion:</strong> Ask LLM to include confidence in output.</p>
<hr />
<h3 id="mth-007-add-multi-intent-detection"><a class="header" href="#mth-007-add-multi-intent-detection">MTH-007: Add multi-intent detection</a></h3>
<p><strong>Description:</strong><br />
Currently matches one intent per input.</p>
<p><strong>Suggestion:</strong> Support detecting multiple intents in one input.</p>
<hr />
<h3 id="mth-008-add-caching"><a class="header" href="#mth-008-add-caching">MTH-008: Add caching</a></h3>
<p><strong>Description:</strong><br />
No caching of match results.</p>
<p><strong>Suggestion:</strong> Cache identical inputs for performance.</p>
<hr />
<h3 id="mth-009-add-negation-patterns"><a class="header" href="#mth-009-add-negation-patterns">MTH-009: Add negation patterns</a></h3>
<p><strong>Description:</strong><br />
No way to specify "not this pattern".</p>
<p><strong>Suggestion:</strong> Add <code>!pattern</code> syntax for exclusions.</p>
<hr />
<h2 id="-notes-17"><a class="header" href="#-notes-17">âšª Notes</a></h2>
<h3 id="mth-010-streaming-output"><a class="header" href="#mth-010-streaming-output">MTH-010: Streaming output</a></h3>
<p><strong>Description:</strong><br />
Results are streamed as LLM generates them:</p>
<pre><code class="language-go">for result, err := range matcher.Match(ctx, model, mctx) {
    // Process as they arrive
}
</code></pre>
<p>Good for responsive UIs.</p>
<hr />
<h3 id="mth-011-variable-typing"><a class="header" href="#mth-011-variable-typing">MTH-011: Variable typing</a></h3>
<p><strong>Description:</strong><br />
Supports typed variables with automatic parsing:</p>
<ul>
<li><code>string</code> (default)</li>
<li><code>int</code></li>
<li><code>float</code></li>
<li><code>bool</code></li>
</ul>
<hr />
<h3 id="mth-012-example-driven-learning"><a class="header" href="#mth-012-example-driven-learning">MTH-012: Example-driven learning</a></h3>
<p><strong>Description:</strong><br />
Rules can include examples for better LLM understanding:</p>
<pre><code class="language-yaml">examples:
  - input: "æˆ‘æƒ³å¬å‘¨æ°ä¼¦çš„ç¨»é¦™"
    output: "music: artist=å‘¨æ°ä¼¦, title=ç¨»é¦™"
</code></pre>
<hr />
<h3 id="mth-013-clean-result-api"><a class="header" href="#mth-013-clean-result-api">MTH-013: Clean Result API</a></h3>
<p><strong>Description:</strong><br />
Well-designed Result structure:</p>
<pre><code class="language-go">type Result struct {
    Rule    string
    Args    map[string]Arg
    RawText string
}
</code></pre>
<p>With <code>HasValue</code> flag for optional extraction.</p>
<hr />
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Severity</th><th>Status</th><th>Component</th></tr></thead><tbody>
<tr><td>MTH-001</td><td>ğŸ”´ Major</td><td>Open</td><td>Rust</td></tr>
<tr><td>MTH-002</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-003</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-004</td><td>ğŸŸ¡ Minor</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-005</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-006</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-007</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-008</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-009</td><td>ğŸ”µ Enhancement</td><td>Open</td><td>Go</td></tr>
<tr><td>MTH-010</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>MTH-011</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>MTH-012</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
<tr><td>MTH-013</td><td>âšª Note</td><td>N/A</td><td>Go</td></tr>
</tbody></table>
</div>
<p><strong>Overall:</strong> Useful LLM-based pattern matching. Main limitations are LLM dependency (latency/cost) and Go-only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32-å¼€å‘æ–¹æ¡ˆå¯¹æ¯”åˆ†æ"><a class="header" href="#esp32-å¼€å‘æ–¹æ¡ˆå¯¹æ¯”åˆ†æ">ESP32 å¼€å‘æ–¹æ¡ˆå¯¹æ¯”åˆ†æ</a></h1>
<p>æœ¬æ–‡æ¡£å¯¹æ¯”äº† ESP32 åµŒå…¥å¼å¼€å‘çš„äº”ç§æŠ€æœ¯æ–¹æ¡ˆï¼Œå¸®åŠ©é€‰æ‹©æœ€é€‚åˆé¡¹ç›®éœ€æ±‚çš„å¼€å‘æ–¹å¼ã€‚</p>
<h2 id="ç›®å½•"><a class="header" href="#ç›®å½•">ç›®å½•</a></h2>
<ul>
<li><a href="esp/esp32-dev-comparison.html#%E6%96%B9%E6%A1%88%E6%A6%82%E8%A7%88">æ–¹æ¡ˆæ¦‚è§ˆ</a></li>
<li><a href="esp/esp32-dev-comparison.html#%E6%80%BB%E4%BD%93%E5%AF%B9%E6%AF%94%E8%A1%A8">æ€»ä½“å¯¹æ¯”è¡¨</a></li>
<li><a href="esp/esp32-dev-comparison.html#%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94">è¯¦ç»†å¯¹æ¯”</a>
<ul>
<li><a href="esp/esp32-dev-comparison.html#1-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">æ€§èƒ½å¯¹æ¯”</a></li>
<li><a href="esp/esp32-dev-comparison.html#2-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%AF%B9%E6%AF%94">å†…å­˜å ç”¨å¯¹æ¯”</a></li>
<li><a href="esp/esp32-dev-comparison.html#3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF%E5%AF%B9%E6%AF%94">äºŒè¿›åˆ¶ä½“ç§¯å¯¹æ¯”</a></li>
<li><a href="esp/esp32-dev-comparison.html#4-%E5%8A%9F%E8%80%97%E5%AF%B9%E6%AF%94">åŠŸè€—å¯¹æ¯”</a></li>
<li><a href="esp/esp32-dev-comparison.html#5-%E5%AE%89%E5%85%A8%E6%80%A7%E5%AF%B9%E6%AF%94">å®‰å…¨æ€§å¯¹æ¯”</a></li>
<li><a href="esp/esp32-dev-comparison.html#6-c-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7%E5%AF%B9%E6%AF%94">C äº’æ“ä½œæ€§å¯¹æ¯”</a></li>
<li><a href="esp/esp32-dev-comparison.html#7-%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C%E5%AF%B9%E6%AF%94">å¼€å‘ä½“éªŒå¯¹æ¯”</a></li>
</ul>
</li>
<li><a href="esp/esp32-dev-comparison.html#%E5%90%84%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3">å„æ–¹æ¡ˆè¯¦è§£</a>
<ul>
<li><a href="esp/esp32-dev-comparison.html#esp-rs--freertos-std">esp-rs + FreeRTOS</a></li>
<li><a href="esp/esp32-dev-comparison.html#embassy-no_std-async">Embassy</a></li>
<li><a href="esp/esp32-dev-comparison.html#c--esp-idf">C + ESP-IDF</a></li>
<li><a href="esp/esp32-dev-comparison.html#c--esp-idf-1">C++ + ESP-IDF</a></li>
<li><a href="esp/esp32-dev-comparison.html#zig--freertos">Zig + FreeRTOS</a></li>
</ul>
</li>
<li><a href="esp/esp32-dev-comparison.html#%E5%86%B3%E7%AD%96%E5%BB%BA%E8%AE%AE">å†³ç­–å»ºè®®</a></li>
<li><a href="esp/esp32-dev-comparison.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">å‚è€ƒèµ„æº</a></li>
</ul>
<hr />
<h2 id="æ–¹æ¡ˆæ¦‚è§ˆ"><a class="header" href="#æ–¹æ¡ˆæ¦‚è§ˆ">æ–¹æ¡ˆæ¦‚è§ˆ</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ–¹æ¡ˆ</th><th>æŠ€æœ¯æ ˆ</th><th>æ ¸å¿ƒç‰¹ç‚¹</th></tr></thead><tbody>
<tr><td><strong>esp-rs + FreeRTOS</strong></td><td>Rust + ESP-IDF + FreeRTOS</td><td>å†…å­˜å®‰å…¨ + åŒæ ¸ + ç”Ÿæ€å®Œæ•´</td></tr>
<tr><td><strong>Embassy</strong></td><td>Rust + embassy-executor</td><td>æè‡´åŠŸè€— + å•æ ¸å¼‚æ­¥</td></tr>
<tr><td><strong>C + ESP-IDF</strong></td><td>C + FreeRTOS</td><td>åŸç”Ÿæ€§èƒ½ + æœ€æˆç†Ÿ</td></tr>
<tr><td><strong>C++ + ESP-IDF</strong></td><td>C++ + FreeRTOS</td><td>é¢å‘å¯¹è±¡ + RAII + æ€§èƒ½</td></tr>
<tr><td><strong>Zig + FreeRTOS</strong></td><td>Zig + ESP-IDF</td><td>C çº§æ€§èƒ½ + æ›´å®‰å…¨ + ç¼–è¯‘å¿«</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="æ€»ä½“å¯¹æ¯”è¡¨"><a class="header" href="#æ€»ä½“å¯¹æ¯”è¡¨">æ€»ä½“å¯¹æ¯”è¡¨</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æŒ‡æ ‡</th><th>esp-rs + FreeRTOS</th><th>Embassy</th><th>C</th><th>C++</th><th>Zig</th></tr></thead><tbody>
<tr><td><strong>ç›¸å¯¹ C æ€§èƒ½</strong></td><td>93%</td><td>82%</td><td>100%</td><td>97%</td><td>98%</td></tr>
<tr><td><strong>Binary ä½“ç§¯</strong></td><td>ğŸ”´ å¤§ (~1.8MB)</td><td>ğŸŸ¢ å° (~1.1MB)</td><td>ğŸŸ¢ å° (~1.0MB)</td><td>ğŸŸ¡ ä¸­ (~1.1MB)</td><td>ğŸŸ¢ å° (~1.0MB)</td></tr>
<tr><td><strong>å†…å­˜å ç”¨</strong></td><td>ğŸ”´ é«˜ (~180KB)</td><td>ğŸŸ¢ ä½ (~100KB)</td><td>ğŸŸ¢ ä½ (~120KB)</td><td>ğŸŸ¡ ä¸­ (~140KB)</td><td>ğŸŸ¢ ä½ (~120KB)</td></tr>
<tr><td><strong>åŠŸè€—</strong></td><td>ğŸŸ¡ ä¸€èˆ¬</td><td>ğŸŸ¢ æœ€ä¼˜</td><td>ğŸŸ¡ ä¸€èˆ¬</td><td>ğŸŸ¡ ä¸€èˆ¬</td><td>ğŸŸ¡ ä¸€èˆ¬</td></tr>
<tr><td><strong>åŒæ ¸ SMP</strong></td><td>âœ…</td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td>âœ…</td></tr>
<tr><td><strong>å†…å­˜å®‰å…¨</strong></td><td>ğŸŸ¢ ç¼–è¯‘æ—¶</td><td>ğŸŸ¢ ç¼–è¯‘æ—¶</td><td>ğŸ”´ æ— </td><td>ğŸŸ¡ éƒ¨åˆ†</td><td>ğŸŸ¡ è¿è¡Œæ—¶</td></tr>
<tr><td><strong>C äº’æ“ä½œ</strong></td><td>ğŸŸ¡ FFI</td><td>ğŸ”´ å›°éš¾</td><td>âœ… åŸç”Ÿ</td><td>âœ… åŸç”Ÿ</td><td>âœ… åŸç”Ÿ</td></tr>
<tr><td><strong>ç¼–è¯‘é€Ÿåº¦</strong></td><td>ğŸ”´ æ…¢</td><td>ğŸ”´ æ…¢</td><td>ğŸŸ¢ å¿«</td><td>ğŸŸ¢ å¿«</td><td>ğŸŸ¢ å¿«</td></tr>
<tr><td><strong>ç”Ÿæ€æˆç†Ÿåº¦</strong></td><td>ğŸŸ¢ å®Œæ•´</td><td>ğŸŸ¡ æˆé•¿ä¸­</td><td>ğŸŸ¢ æœ€å®Œæ•´</td><td>ğŸŸ¢ å®Œæ•´</td><td>ğŸ”´ éœ€è‡ªå»º</td></tr>
<tr><td><strong>å­¦ä¹ æ›²çº¿</strong></td><td>ğŸŸ¡ é™¡å³­</td><td>ğŸŸ¡ é™¡å³­</td><td>ğŸŸ¢ å¹³ç¼“</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="è¯¦ç»†å¯¹æ¯”"><a class="header" href="#è¯¦ç»†å¯¹æ¯”">è¯¦ç»†å¯¹æ¯”</a></h2>
<h3 id="1-æ€§èƒ½å¯¹æ¯”"><a class="header" href="#1-æ€§èƒ½å¯¹æ¯”">1. æ€§èƒ½å¯¹æ¯”</a></h3>
<pre><code>æ€§èƒ½åŸºå‡† (ç›¸å¯¹ C = 100):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ C           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%          â”‚
â”‚ Zig         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ 98%           â”‚
â”‚ C++         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ 97%           â”‚
â”‚ esp-rs      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ   93%           â”‚
â”‚ Embassy     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     82%           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>æŒ‡æ ‡</th><th>esp-rs</th><th>Embassy</th><th>C</th><th>C++</th><th>Zig</th></tr></thead><tbody>
<tr><td><strong>CPU åˆ©ç”¨ç‡</strong></td><td>åŒæ ¸ 100%</td><td>å•æ ¸ 100%</td><td>åŒæ ¸ 100%</td><td>åŒæ ¸ 100%</td><td>åŒæ ¸ 100%</td></tr>
<tr><td><strong>ä»»åŠ¡åˆ‡æ¢</strong></td><td>~1-5 Î¼s</td><td>~0.1-0.5 Î¼s</td><td>~1-5 Î¼s</td><td>~1-5 Î¼s</td><td>~1-5 Î¼s</td></tr>
<tr><td><strong>ä¸­æ–­å»¶è¿Ÿ</strong></td><td>~2-10 Î¼s</td><td>~0.5-2 Î¼s</td><td>~2-10 Î¼s</td><td>~2-10 Î¼s</td><td>~2-10 Î¼s</td></tr>
<tr><td><strong>ç½‘ç»œåå</strong></td><td>15-20 Mbps</td><td>8-12 Mbps</td><td>20 Mbps</td><td>18-20 Mbps</td><td>18-20 Mbps</td></tr>
<tr><td><strong>å‡½æ•°è°ƒç”¨å¼€é”€</strong></td><td>~5-10%</td><td>é›¶</td><td>é›¶</td><td>~2-3%</td><td>é›¶</td></tr>
</tbody></table>
</div>
<h3 id="2-å†…å­˜å ç”¨å¯¹æ¯”"><a class="header" href="#2-å†…å­˜å ç”¨å¯¹æ¯”">2. å†…å­˜å ç”¨å¯¹æ¯”</a></h3>
<pre><code>ESP32-S3 å†…å­˜ä½¿ç”¨ (Hello World + WiFi):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ–¹æ¡ˆ          â”‚ é™æ€å†…å­˜  â”‚ å †ä½¿ç”¨   â”‚ æ ˆ/ä»»åŠ¡  â”‚ æ€»è®¡      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Embassy       â”‚ 10 KB    â”‚ 50 KB   â”‚ 30 KB   â”‚ ~90 KB    â”‚
â”‚ C             â”‚ 35 KB    â”‚ 80 KB   â”‚ 50 KB   â”‚ ~165 KB   â”‚
â”‚ Zig           â”‚ 25 KB    â”‚ 75 KB   â”‚ 55 KB   â”‚ ~155 KB   â”‚
â”‚ C++           â”‚ 45 KB    â”‚ 90 KB   â”‚ 55 KB   â”‚ ~190 KB   â”‚
â”‚ esp-rs        â”‚ 60 KB    â”‚ 120 KB  â”‚ 60 KB   â”‚ ~240 KB   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="3-äºŒè¿›åˆ¶ä½“ç§¯å¯¹æ¯”"><a class="header" href="#3-äºŒè¿›åˆ¶ä½“ç§¯å¯¹æ¯”">3. äºŒè¿›åˆ¶ä½“ç§¯å¯¹æ¯”</a></h3>
<pre><code>Binary å¤§å° (å®Œæ•´éŸ³é¢‘åº”ç”¨):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ C                  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ~1.0 MB               â”‚
â”‚ Zig                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ~1.0 MB               â”‚
â”‚ Embassy            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ~1.1 MB             â”‚
â”‚ C++                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ~1.1 MB             â”‚
â”‚ esp-rs + FreeRTOS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ~1.8 MB   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="4-åŠŸè€—å¯¹æ¯”"><a class="header" href="#4-åŠŸè€—å¯¹æ¯”">4. åŠŸè€—å¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ¨¡å¼</th><th>esp-rs</th><th>Embassy</th><th>C</th><th>C++</th><th>Zig</th></tr></thead><tbody>
<tr><td><strong>Active 240MHz</strong></td><td>~100 mA</td><td>~90 mA</td><td>~95 mA</td><td>~95 mA</td><td>~95 mA</td></tr>
<tr><td><strong>Active 80MHz</strong></td><td>~45 mA</td><td>~40 mA</td><td>~43 mA</td><td>~43 mA</td><td>~43 mA</td></tr>
<tr><td><strong>Light Sleep</strong></td><td>~0.8 mA</td><td>~0.4 mA</td><td>~0.8 mA</td><td>~0.8 mA</td><td>~0.8 mA</td></tr>
<tr><td><strong>Deep Sleep</strong></td><td>~15 Î¼A</td><td>~10 Î¼A</td><td>~15 Î¼A</td><td>~15 Î¼A</td><td>~15 Î¼A</td></tr>
<tr><td><strong>å”¤é†’å»¶è¿Ÿ</strong></td><td>~3-5 ms</td><td>~0.5-1 ms</td><td>~3-5 ms</td><td>~3-5 ms</td><td>~3-5 ms</td></tr>
</tbody></table>
</div>
<p>Embassy åŠŸè€—æœ€ä¼˜çš„åŸå› ï¼š</p>
<ul>
<li>æ—  FreeRTOS tick ä¸­æ–­</li>
<li>å¼‚æ­¥æ‰§è¡Œå™¨å¤©ç„¶æ”¯æŒ idle = sleep</li>
<li>æ— ä»»åŠ¡æ ˆå¼€é”€</li>
</ul>
<h3 id="5-å®‰å…¨æ€§å¯¹æ¯”"><a class="header" href="#5-å®‰å…¨æ€§å¯¹æ¯”">5. å®‰å…¨æ€§å¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>é—®é¢˜ç±»å‹</th><th>C</th><th>C++</th><th>Zig</th><th>Rust (esp-rs/Embassy)</th></tr></thead><tbody>
<tr><td><strong>ç¼“å†²åŒºæº¢å‡º</strong></td><td>âŒ</td><td>âš ï¸</td><td>ğŸŸ¢ è¿è¡Œæ—¶</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>æ•°ç»„è¶Šç•Œ</strong></td><td>âŒ</td><td>âš ï¸</td><td>ğŸŸ¢ è¿è¡Œæ—¶</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>ç©ºæŒ‡é’ˆè§£å¼•ç”¨</strong></td><td>âŒ</td><td>âš ï¸</td><td>ğŸŸ¢ ç¼–è¯‘æ—¶</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>Use-after-free</strong></td><td>âŒ</td><td>âš ï¸</td><td>âš ï¸ éƒ¨åˆ†</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>åŒé‡é‡Šæ”¾</strong></td><td>âŒ</td><td>ğŸŸ¢</td><td>ğŸŸ¢ è¿è¡Œæ—¶</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>å†…å­˜æ³„æ¼</strong></td><td>âŒ</td><td>ğŸŸ¢</td><td>ğŸŸ¢ æ£€æµ‹</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>æ•°æ®ç«äº‰</strong></td><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
<tr><td><strong>æ•´æ•°æº¢å‡º</strong></td><td>âŒ</td><td>âŒ</td><td>ğŸŸ¢ è¿è¡Œæ—¶</td><td>âš ï¸ Debug</td></tr>
<tr><td><strong>æœªåˆå§‹åŒ–å†…å­˜</strong></td><td>âŒ</td><td>âŒ</td><td>ğŸŸ¢ å¼ºåˆ¶</td><td>âœ… ç¼–è¯‘æ—¶</td></tr>
</tbody></table>
</div>
<pre><code>å›¾ä¾‹:
âŒ = ä¸é˜²æŠ¤
âš ï¸ = éƒ¨åˆ†é˜²æŠ¤ (éœ€æ­£ç¡®ä½¿ç”¨)
ğŸŸ¢ = è¿è¡Œæ—¶é˜²æŠ¤ (å¯æ£€æµ‹/å¯å…³é—­)
âœ… = ç¼–è¯‘æ—¶é˜²æŠ¤ (æ— æ³•ç»•è¿‡)
</code></pre>
<h4 id="zig-å®‰å…¨æ€§è¯¦è§£"><a class="header" href="#zig-å®‰å…¨æ€§è¯¦è§£">Zig å®‰å…¨æ€§è¯¦è§£</a></h4>
<p>Zig æä¾›äº†å¯é…ç½®çš„å®‰å…¨æ£€æŸ¥ï¼š</p>
<div class="table-wrapper"><table><thead><tr><th>ç¼–è¯‘æ¨¡å¼</th><th>è¾¹ç•Œæ£€æŸ¥</th><th>æº¢å‡ºæ£€æŸ¥</th><th>æ€§èƒ½å½±å“</th></tr></thead><tbody>
<tr><td>Debug</td><td>âœ…</td><td>âœ…</td><td>~20%</td></tr>
<tr><td>ReleaseSafe</td><td>âœ…</td><td>âœ…</td><td>~5-10%</td></tr>
<tr><td>ReleaseFast</td><td>âŒ</td><td>âŒ</td><td>0%</td></tr>
<tr><td>ReleaseSmall</td><td>âŒ</td><td>âŒ</td><td>0%</td></tr>
</tbody></table>
</div>
<h3 id="6-c-äº’æ“ä½œæ€§å¯¹æ¯”"><a class="header" href="#6-c-äº’æ“ä½œæ€§å¯¹æ¯”">6. C äº’æ“ä½œæ€§å¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ç»´åº¦</th><th>esp-rs</th><th>Embassy</th><th>C</th><th>C++</th><th>Zig</th></tr></thead><tbody>
<tr><td><strong>è°ƒç”¨ ESP-IDF</strong></td><td>FFI</td><td>å›°éš¾</td><td>åŸç”Ÿ</td><td>åŸç”Ÿ</td><td><strong>åŸç”Ÿ</strong></td></tr>
<tr><td><strong>è°ƒç”¨ esp_afe</strong></td><td>âš ï¸ bindgen</td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td><strong>âœ…</strong></td></tr>
<tr><td><strong>è°ƒç”¨ LVGL</strong></td><td>lvgl-rs</td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td><strong>âœ…</strong></td></tr>
<tr><td><strong>å¤´æ–‡ä»¶å¯¼å…¥</strong></td><td>bindgen</td><td>âŒ</td><td>åŸç”Ÿ</td><td>åŸç”Ÿ</td><td><strong>@cImport</strong></td></tr>
</tbody></table>
</div>
<h4 id="ä»£ç ç¤ºä¾‹å¯¹æ¯”"><a class="header" href="#ä»£ç ç¤ºä¾‹å¯¹æ¯”">ä»£ç ç¤ºä¾‹å¯¹æ¯”</a></h4>
<p><strong>esp-rs è°ƒç”¨ C åº“ï¼š</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use esp_idf_sys::*;

unsafe {
    let config = afe_config_t { ..Default::default() };
    let afe = esp_afe_create(&amp;config as *const _);
    esp_afe_process(afe, buffer.as_mut_ptr());
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Zig è°ƒç”¨ C åº“ï¼š</strong></p>
<pre><code class="language-zig">const c = @cImport({
    @cInclude("esp_afe_sr_iface.h");
});

var config = c.afe_config_t{};
const afe = c.esp_afe_create(&amp;config);
c.esp_afe_process(afe, &amp;buffer);  // é›¶å¼€é”€ï¼Œä¸ C å®Œå…¨ç›¸åŒ
</code></pre>
<h3 id="7-å¼€å‘ä½“éªŒå¯¹æ¯”"><a class="header" href="#7-å¼€å‘ä½“éªŒå¯¹æ¯”">7. å¼€å‘ä½“éªŒå¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ç»´åº¦</th><th>esp-rs</th><th>Embassy</th><th>C</th><th>C++</th><th>Zig</th></tr></thead><tbody>
<tr><td><strong>ç¼–è¯‘é€Ÿåº¦</strong></td><td>ğŸ”´ 2-3 min</td><td>ğŸ”´ 1-2 min</td><td>ğŸŸ¢ 30s</td><td>ğŸŸ¢ 30s</td><td>ğŸŸ¢ 20-40s</td></tr>
<tr><td><strong>é”™è¯¯æç¤º</strong></td><td>ğŸŸ¢ ä¼˜ç§€</td><td>ğŸŸ¢ ä¼˜ç§€</td><td>ğŸ”´ å·®</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¢ è‰¯å¥½</td></tr>
<tr><td><strong>IDE æ”¯æŒ</strong></td><td>ğŸŸ¢ ä¼˜ç§€</td><td>ğŸŸ¢ ä¼˜ç§€</td><td>ğŸŸ¢ å¥½</td><td>ğŸŸ¢ å¥½</td><td>ğŸŸ¡ ä¸€èˆ¬</td></tr>
<tr><td><strong>è°ƒè¯•</strong></td><td>ğŸŸ¢ GDB</td><td>ğŸŸ¡ probe-rs</td><td>ğŸŸ¢ GDB</td><td>ğŸŸ¢ GDB</td><td>ğŸŸ¡ GDB</td></tr>
<tr><td><strong>æ–‡æ¡£</strong></td><td>ğŸŸ¢ ä¸°å¯Œ</td><td>ğŸŸ¡ æˆé•¿ä¸­</td><td>ğŸŸ¢ æœ€å®Œæ•´</td><td>ğŸŸ¢ ä¸°å¯Œ</td><td>ğŸ”´ ç¨€ç¼º</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="å„æ–¹æ¡ˆè¯¦è§£"><a class="header" href="#å„æ–¹æ¡ˆè¯¦è§£">å„æ–¹æ¡ˆè¯¦è§£</a></h2>
<h3 id="esp-rs--freertos-std"><a class="header" href="#esp-rs--freertos-std">esp-rs + FreeRTOS (std)</a></h3>
<p><strong>æŠ€æœ¯æ ˆï¼š</strong> Rust + ESP-IDF + FreeRTOS</p>
<p><strong>ä¼˜ç‚¹ï¼š</strong></p>
<ul>
<li>âœ… å†…å­˜å®‰å…¨ï¼ˆç¼–è¯‘æ—¶æ£€æŸ¥ï¼‰</li>
<li>âœ… å®Œæ•´çš„ç”Ÿæ€ç³»ç»Ÿ</li>
<li>âœ… åŒæ ¸ SMP æ”¯æŒ</li>
<li>âœ… æ´»è·ƒçš„ç¤¾åŒºæ”¯æŒ</li>
<li>âœ… ä¸°å¯Œçš„æ–‡æ¡£</li>
</ul>
<p><strong>ç¼ºç‚¹ï¼š</strong></p>
<ul>
<li>âŒ Binary ä½“ç§¯å¤§ï¼ˆ~1.8 MBï¼‰</li>
<li>âŒ å†…å­˜å ç”¨é«˜ï¼ˆ~180 KBï¼‰</li>
<li>âŒ ç¼–è¯‘é€Ÿåº¦æ…¢</li>
<li>âŒ FFI è°ƒç”¨æœ‰å¼€é”€</li>
</ul>
<p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
<ul>
<li>å†…å­˜/Flash å……è¶³çš„é¡¹ç›®</li>
<li>éœ€è¦æœ€é«˜å®‰å…¨æ€§ä¿è¯</li>
<li>å›¢é˜Ÿç†Ÿæ‚‰ Rust</li>
</ul>
<h3 id="embassy-no_std-async"><a class="header" href="#embassy-no_std-async">Embassy (no_std async)</a></h3>
<p><strong>æŠ€æœ¯æ ˆï¼š</strong> Rust + embassy-executor</p>
<p><strong>ä¼˜ç‚¹ï¼š</strong></p>
<ul>
<li>âœ… Binary æœ€å°</li>
<li>âœ… å†…å­˜å ç”¨æœ€ä½</li>
<li>âœ… åŠŸè€—æœ€ä¼˜</li>
<li>âœ… å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹</li>
</ul>
<p><strong>ç¼ºç‚¹ï¼š</strong></p>
<ul>
<li>âŒ <strong>ä¸æ”¯æŒåŒæ ¸</strong></li>
<li>âŒ C äº’æ“ä½œå›°éš¾</li>
<li>âŒ æ— æ³•è°ƒç”¨ esp_afe ç­‰é—­æºåº“</li>
<li>âŒ ç”Ÿæ€ä»åœ¨æˆé•¿</li>
</ul>
<p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
<ul>
<li>ç®€å•ä¼ æ„Ÿå™¨èŠ‚ç‚¹</li>
<li>æè‡´åŠŸè€—æ•æ„Ÿçš„ç”µæ± è®¾å¤‡</li>
<li>ä¸éœ€è¦åŒæ ¸è®¡ç®—</li>
</ul>
<h3 id="c--esp-idf"><a class="header" href="#c--esp-idf">C + ESP-IDF</a></h3>
<p><strong>æŠ€æœ¯æ ˆï¼š</strong> C + FreeRTOS</p>
<p><strong>ä¼˜ç‚¹ï¼š</strong></p>
<ul>
<li>âœ… æ€§èƒ½æœ€ä¼˜ï¼ˆbaselineï¼‰</li>
<li>âœ… ç”Ÿæ€æœ€å®Œæ•´</li>
<li>âœ… æ–‡æ¡£æœ€ä¸°å¯Œ</li>
<li>âœ… æ‰€æœ‰åº“åŸç”Ÿæ”¯æŒ</li>
</ul>
<p><strong>ç¼ºç‚¹ï¼š</strong></p>
<ul>
<li>âŒ æ— å†…å­˜å®‰å…¨ä¿æŠ¤</li>
<li>âŒ å¼€å‘æ•ˆç‡è¾ƒä½</li>
<li>âŒ å®¹æ˜“å‡ºç°å†…å­˜ bug</li>
</ul>
<p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
<ul>
<li>æ€§èƒ½æè‡´è¦æ±‚</li>
<li>å›¢é˜Ÿç†Ÿæ‚‰ C</li>
<li>éœ€è¦ä½¿ç”¨æ‰€æœ‰ ESP-IDF åŠŸèƒ½</li>
</ul>
<h3 id="c--esp-idf-1"><a class="header" href="#c--esp-idf-1">C++ + ESP-IDF</a></h3>
<p><strong>æŠ€æœ¯æ ˆï¼š</strong> C++ (17/20) + FreeRTOS</p>
<p><strong>ä¼˜ç‚¹ï¼š</strong></p>
<ul>
<li>âœ… æ€§èƒ½æ¥è¿‘ Cï¼ˆ97%ï¼‰</li>
<li>âœ… RAII é˜²æ­¢èµ„æºæ³„æ¼</li>
<li>âœ… é¢å‘å¯¹è±¡è®¾è®¡</li>
<li>âœ… ä¸ ESP-IDF å®Œç¾å…¼å®¹</li>
<li>âœ… å­¦ä¹ æˆæœ¬é€‚ä¸­</li>
</ul>
<p><strong>ç¼ºç‚¹ï¼š</strong></p>
<ul>
<li>âŒ æ— å€Ÿç”¨æ£€æŸ¥ï¼ˆæ•°æ®ç«äº‰ä¸é˜²æŠ¤ï¼‰</li>
<li>âŒ æ¨¡æ¿è†¨èƒ€å¯èƒ½å¢åŠ ä½“ç§¯</li>
<li>âŒ å¼‚å¸¸/RTTI é»˜è®¤ç¦ç”¨</li>
</ul>
<p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
<ul>
<li>éœ€è¦ OOP è®¾è®¡æ¨¡å¼</li>
<li>å›¢é˜Ÿç†Ÿæ‚‰ C++</li>
<li>æƒ³è¦æ¯” C æ›´å¥½çš„å®‰å…¨æ€§</li>
</ul>
<h3 id="zig--freertos"><a class="header" href="#zig--freertos">Zig + FreeRTOS</a></h3>
<p><strong>æŠ€æœ¯æ ˆï¼š</strong> Zig + ESP-IDF + FreeRTOS</p>
<p><strong>å‰ææ¡ä»¶ï¼š</strong> éœ€è¦ä½¿ç”¨ <a href="https://github.com/haivivi/zig-bootstrap">haivivi/zig-bootstrap</a> æ„å»ºæ”¯æŒ Xtensa çš„ Zig ç¼–è¯‘å™¨ã€‚</p>
<p><strong>ä¼˜ç‚¹ï¼š</strong></p>
<ul>
<li>âœ… æ€§èƒ½æ¥è¿‘ Cï¼ˆ98%ï¼‰</li>
<li>âœ… Binary ä½“ç§¯å°ï¼ˆ~1.0 MBï¼‰</li>
<li>âœ… å†…å­˜å ç”¨ä½ï¼ˆ~120 KBï¼‰</li>
<li>âœ… C äº’æ“ä½œæœ€ä½³ï¼ˆ@cImport é›¶å¼€é”€ï¼‰</li>
<li>âœ… ç¼–è¯‘é€Ÿåº¦å¿«</li>
<li>âœ… åŒæ ¸æ”¯æŒ</li>
<li>âœ… è¿è¡Œæ—¶å®‰å…¨æ£€æŸ¥ï¼ˆå¯é…ç½®ï¼‰</li>
</ul>
<p><strong>ç¼ºç‚¹ï¼š</strong></p>
<ul>
<li>âŒ ç”Ÿæ€éœ€è¦è‡ªå»º</li>
<li>âŒ ç¤¾åŒºæ”¯æŒå‡ ä¹æ²¡æœ‰</li>
<li>âŒ æ–‡æ¡£ç¨€ç¼º</li>
<li>âŒ æ— ç¼–è¯‘æ—¶å€Ÿç”¨æ£€æŸ¥</li>
<li>âŒ éœ€è¦ç»´æŠ¤ zig-bootstrap</li>
</ul>
<p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
<ul>
<li>Flash/å†…å­˜ç´§å¼ çš„é¡¹ç›®</li>
<li>éœ€è¦åŒæ ¸ + é«˜æ€§èƒ½</li>
<li>å¤§é‡è°ƒç”¨ C åº“ï¼ˆesp_afe ç­‰ï¼‰</li>
<li>æ„¿æ„åš DIY å¼€å‘</li>
</ul>
<hr />
<h2 id="å†³ç­–å»ºè®®"><a class="header" href="#å†³ç­–å»ºè®®">å†³ç­–å»ºè®®</a></h2>
<h3 id="å†³ç­–æµç¨‹å›¾"><a class="header" href="#å†³ç­–æµç¨‹å›¾">å†³ç­–æµç¨‹å›¾</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      é€‰æ‹©å†³ç­–æ ‘                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Flash/å†…å­˜ç´§å¼ ? â”€â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€&gt; ç»§ç»­ä¸‹é¢                   â”‚
â”‚        â”‚                                                    â”‚
â”‚       No â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt; esp-rs + FreeRTOS          â”‚
â”‚                                                             â”‚
â”‚  éœ€è¦åŒæ ¸? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€&gt; ç»§ç»­ä¸‹é¢                   â”‚
â”‚        â”‚                                                    â”‚
â”‚       No â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt; Embassy                    â”‚
â”‚                                                             â”‚
â”‚  å¤§é‡è°ƒç”¨ C åº“? â”€â”€â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€&gt; Zig + FreeRTOS æˆ– C/C++   â”‚
â”‚        â”‚                                                    â”‚
â”‚       No                                                    â”‚
â”‚        â”‚                                                    â”‚
â”‚  å›¢é˜Ÿç†Ÿæ‚‰ Rust? â”€â”€â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€&gt; esp-rs (æƒ³åŠæ³•ä¼˜åŒ–ä½“ç§¯)    â”‚
â”‚        â”‚                                                    â”‚
â”‚       No                                                    â”‚
â”‚        â”‚                                                    â”‚
â”‚  æ„¿æ„ DIY æ¢é™©? â”€â”€â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€&gt; Zig + FreeRTOS             â”‚
â”‚        â”‚                                                    â”‚
â”‚       No â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt; C++ + ESP-IDF              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="åœºæ™¯æ¨è"><a class="header" href="#åœºæ™¯æ¨è">åœºæ™¯æ¨è</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åœºæ™¯</th><th>æ¨èæ–¹æ¡ˆ</th><th>åŸå› </th></tr></thead><tbody>
<tr><td><strong>é€šç”¨ IoT è®¾å¤‡</strong></td><td>esp-rs + FreeRTOS</td><td>å®‰å…¨ + ç”Ÿæ€å®Œæ•´</td></tr>
<tr><td><strong>ç”µæ± ä¾›ç”µä¼ æ„Ÿå™¨</strong></td><td>Embassy</td><td>åŠŸè€—æœ€ä¼˜</td></tr>
<tr><td><strong>éŸ³é¢‘å¤„ç†è®¾å¤‡</strong></td><td>Zig æˆ– C</td><td>éœ€è¦åŒæ ¸ + ä½å»¶è¿Ÿ</td></tr>
<tr><td><strong>èµ„æºç´§å¼ è®¾å¤‡</strong></td><td>Zig æˆ– C</td><td>ä½“ç§¯å° + å†…å­˜ä½</td></tr>
<tr><td><strong>å¿«é€ŸåŸå‹å¼€å‘</strong></td><td>C++</td><td>å¼€å‘æ•ˆç‡ + æ€§èƒ½å¹³è¡¡</td></tr>
<tr><td><strong>è°ƒç”¨é—­æº C åº“</strong></td><td>Zig æˆ– C/C++</td><td>C äº’æ“ä½œæœ€ä½³</td></tr>
</tbody></table>
</div>
<h3 id="è¯­éŸ³-iot-è®¾å¤‡æ¨è"><a class="header" href="#è¯­éŸ³-iot-è®¾å¤‡æ¨è">è¯­éŸ³ IoT è®¾å¤‡æ¨è</a></h3>
<p>é’ˆå¯¹éœ€è¦ä»¥ä¸‹åŠŸèƒ½çš„è¯­éŸ³è®¾å¤‡ï¼š</p>
<ul>
<li>I2S éŸ³é¢‘è¾“å…¥è¾“å‡º</li>
<li>Opus ç¼–è§£ç </li>
<li>AEC å›å£°æ¶ˆé™¤ï¼ˆesp_afeï¼‰</li>
<li>BLE é€šä¿¡</li>
<li>LVGL GUI</li>
<li>åŒæ ¸å¤„ç†</li>
</ul>
<p><strong>çº¦æŸæ¡ä»¶åˆ†æï¼š</strong></p>
<div class="table-wrapper"><table><thead><tr><th>çº¦æŸ</th><th>esp-rs</th><th>Embassy</th><th>C</th><th>C++</th><th>Zig</th></tr></thead><tbody>
<tr><td>Flash ç´§å¼ </td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td>âœ…</td><td>âœ…</td></tr>
<tr><td>å†…å­˜ç´§å¼ </td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td>âœ…</td><td>âœ…</td></tr>
<tr><td>éœ€è¦åŒæ ¸</td><td>âœ…</td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td>âœ…</td></tr>
<tr><td>esp_afe è°ƒç”¨</td><td>âš ï¸</td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td>âœ…</td></tr>
<tr><td>LVGL GUI</td><td>âœ…</td><td>âŒ</td><td>âœ…</td><td>âœ…</td><td>âœ…</td></tr>
</tbody></table>
</div>
<p><strong>æ¨èæ’åºï¼š</strong></p>
<ol>
<li>ğŸ¥‡ <strong>Zig + FreeRTOS</strong> - ä½“ç§¯å°ã€æ€§èƒ½é«˜ã€C äº’æ“ä½œæœ€ä½³</li>
<li>ğŸ¥ˆ <strong>C++ + ESP-IDF</strong> - æˆç†Ÿç¨³å®šã€RAII å®‰å…¨</li>
<li>ğŸ¥‰ <strong>C + ESP-IDF</strong> - æ€§èƒ½æœ€ä¼˜ã€ä½†å¼€å‘æ•ˆç‡ä½</li>
</ol>
<hr />
<h2 id="rust-rtos-ç”Ÿæ€è°ƒç ”"><a class="header" href="#rust-rtos-ç”Ÿæ€è°ƒç ”">Rust RTOS ç”Ÿæ€è°ƒç ”</a></h2>
<div class="table-wrapper"><table><thead><tr><th>RTOS</th><th>ç±»å‹</th><th>ESP32 æ”¯æŒ</th><th>åŒæ ¸æ”¯æŒ</th><th>çŠ¶æ€</th></tr></thead><tbody>
<tr><td><strong>RTIC</strong></td><td>ä¸­æ–­é©±åŠ¨æ¡†æ¶</td><td>âŒ ä»… ARM</td><td>âŒ</td><td>æ´»è·ƒ</td></tr>
<tr><td><strong>Embassy</strong></td><td>async æ‰§è¡Œå™¨</td><td>âœ…</td><td>âŒ å®éªŒæ€§</td><td>æ´»è·ƒ</td></tr>
<tr><td><strong>Drone OS</strong></td><td>å®æ—¶ OS</td><td>âŒ ä»… ARM</td><td>âŒ</td><td>åŠæ´»è·ƒ</td></tr>
<tr><td><strong>Tock OS</strong></td><td>å®‰å…¨ OS</td><td>âŒ ä»… ARM</td><td>âŒ</td><td>æ´»è·ƒ</td></tr>
<tr><td><strong>Hubris</strong></td><td>å¾®å†…æ ¸</td><td>âŒ ç‰¹å®šç¡¬ä»¶</td><td>âŒ</td><td>Oxide å†…éƒ¨</td></tr>
</tbody></table>
</div>
<p><strong>ç»“è®ºï¼š</strong> ç›®å‰æ²¡æœ‰çº¯ Rust RTOS æ”¯æŒ ESP32 (Xtensa) åŒæ ¸ã€‚</p>
<hr />
<h2 id="å‚è€ƒèµ„æº"><a class="header" href="#å‚è€ƒèµ„æº">å‚è€ƒèµ„æº</a></h2>
<h3 id="å®˜æ–¹æ–‡æ¡£"><a class="header" href="#å®˜æ–¹æ–‡æ¡£">å®˜æ–¹æ–‡æ¡£</a></h3>
<ul>
<li><a href="https://esp-rs.github.io/book/">esp-rs Book</a></li>
<li><a href="https://embassy.dev/">Embassy Documentation</a></li>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/">ESP-IDF Programming Guide</a></li>
<li><a href="https://ziglang.org/documentation/master/">Zig Language Reference</a></li>
</ul>
<h3 id="å·¥å…·é“¾"><a class="header" href="#å·¥å…·é“¾">å·¥å…·é“¾</a></h3>
<ul>
<li><a href="https://github.com/esp-rs/espup">espup</a> - Rust ESP32 å·¥å…·é“¾å®‰è£…å™¨</li>
<li><a href="https://github.com/esp-rs/espflash">espflash</a> - çƒ§å½•å·¥å…·</li>
<li><a href="https://github.com/haivivi/zig-bootstrap">haivivi/zig-bootstrap</a> - Zig Xtensa ç¼–è¯‘å™¨</li>
</ul>
<h3 id="ç¤¾åŒºèµ„æº"><a class="header" href="#ç¤¾åŒºèµ„æº">ç¤¾åŒºèµ„æº</a></h3>
<ul>
<li><a href="https://matrix.to/#/#esp-rs:matrix.org">esp-rs Matrix Chat</a></li>
<li><a href="https://esp32.com/">ESP32 Forum</a></li>
<li><a href="https://discord.gg/zig">Zig Discord</a></li>
</ul>
<hr />
<h2 id="æ›´æ–°è®°å½•"><a class="header" href="#æ›´æ–°è®°å½•">æ›´æ–°è®°å½•</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ—¥æœŸ</th><th>å†…å®¹</th></tr></thead><tbody>
<tr><td>2026-01-23</td><td>åˆå§‹ç‰ˆæœ¬ï¼Œå¯¹æ¯”äº”ç§å¼€å‘æ–¹æ¡ˆ</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="esp32-rust-esp-rs-å›ºä»¶å¼€å‘æŒ‡å—"><a class="header" href="#esp32-rust-esp-rs-å›ºä»¶å¼€å‘æŒ‡å—">ESP32 Rust (esp-rs) å›ºä»¶å¼€å‘æŒ‡å—</a></h1>
<p>æœ¬æ–‡æ¡£è®°å½•äº†å°†ç°æœ‰ C/ESP-IDF å›ºä»¶è¿ç§»åˆ° Rust (esp-rs) çš„å¯è¡Œæ€§åˆ†æå’ŒæŠ€æœ¯æ–¹æ¡ˆã€‚</p>
<h2 id="ç›®å½•-1"><a class="header" href="#ç›®å½•-1">ç›®å½•</a></h2>
<ul>
<li><a href="esp/esp-rs-migration.html#%E8%83%8C%E6%99%AF">èƒŒæ™¯</a></li>
<li><a href="esp/esp-rs-migration.html#%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94">æŠ€æœ¯æ ˆå¯¹æ¯”</a></li>
<li><a href="esp/esp-rs-migration.html#%E5%90%84%E6%A8%A1%E5%9D%97%E8%BF%81%E7%A7%BB%E5%88%86%E6%9E%90">å„æ¨¡å—è¿ç§»åˆ†æ</a></li>
<li><a href="esp/esp-rs-migration.html#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88">ä¾èµ–ç®¡ç†æ–¹æ¡ˆ</a></li>
<li><a href="esp/esp-rs-migration.html#aec-%E5%9B%9E%E5%A3%B0%E6%B6%88%E9%99%A4%E6%96%B9%E6%A1%88">AEC å›å£°æ¶ˆé™¤æ–¹æ¡ˆ</a></li>
<li><a href="esp/esp-rs-migration.html#%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7">å¼€å‘å’Œè°ƒè¯•å·¥å…·</a></li>
<li><a href="esp/esp-rs-migration.html#%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%84%E4%BC%B0">å·¥ä½œé‡è¯„ä¼°</a></li>
</ul>
<hr />
<h2 id="èƒŒæ™¯"><a class="header" href="#èƒŒæ™¯">èƒŒæ™¯</a></h2>
<p>ç°æœ‰å›ºä»¶åŸºäº C + ESP-IDF + ESP-ADF å¼€å‘ï¼Œä¸»è¦ç—›ç‚¹ï¼š</p>
<ul>
<li>ESP-ADF ä»£ç è´¨é‡ä¸ä½³ï¼Œç»´æŠ¤å›°éš¾</li>
<li>C è¯­è¨€ç¼ºä¹ç°ä»£è¯­è¨€ç‰¹æ€§ï¼Œå¼€å‘æ•ˆç‡ä½</li>
<li>å†…å­˜å®‰å…¨é—®é¢˜éš¾ä»¥æ’æŸ¥</li>
</ul>
<p>ç›®æ ‡ï¼šä½¿ç”¨ Rust (esp-rs) é‡å†™å›ºä»¶ï¼Œä¿æŒåŠŸèƒ½ä¸å˜ï¼Œæå‡ä»£ç è´¨é‡å’Œå¼€å‘æ•ˆç‡ã€‚</p>
<hr />
<h2 id="æŠ€æœ¯æ ˆå¯¹æ¯”"><a class="header" href="#æŠ€æœ¯æ ˆå¯¹æ¯”">æŠ€æœ¯æ ˆå¯¹æ¯”</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ç»„ä»¶</th><th>ç°æœ‰æ–¹æ¡ˆ (C)</th><th>Rust æ–¹æ¡ˆ</th></tr></thead><tbody>
<tr><td>æ¡†æ¶</td><td>ESP-IDF</td><td>esp-idf-hal + esp-idf-svc</td></tr>
<tr><td>éŸ³é¢‘æ¡†æ¶</td><td>ESP-ADF</td><td>è‡ªè¡Œå®ç°ï¼ˆç§»é™¤ ESP-ADFï¼‰</td></tr>
<tr><td>GUI</td><td>LVGL (C)</td><td>lvgl-rs (binding)</td></tr>
<tr><td>BLE</td><td>NimBLE (C)</td><td>esp32-nimble (Rust)</td></tr>
<tr><td>Opus ç¼–è§£ç </td><td>libopus (C)</td><td>opus crate (binding)</td></tr>
<tr><td>AEC</td><td>esp_afe (é—­æº)</td><td>esp_afe binding / Speex AEC</td></tr>
<tr><td>å†…å­˜ç®¡ç†</td><td>heap_caps_malloc</td><td>esp-alloc + PSRAM æ”¯æŒ</td></tr>
<tr><td>æ„å»ºç³»ç»Ÿ</td><td>CMake (idf.py)</td><td>Cargo + build.rs</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="å„æ¨¡å—è¿ç§»åˆ†æ"><a class="header" href="#å„æ¨¡å—è¿ç§»åˆ†æ">å„æ¨¡å—è¿ç§»åˆ†æ</a></h2>
<h3 id="1-freertos-ä»»åŠ¡ç®¡ç†-"><a class="header" href="#1-freertos-ä»»åŠ¡ç®¡ç†-">1. FreeRTOS ä»»åŠ¡ç®¡ç† âœ…</a></h3>
<p><strong>ç°æœ‰ä»£ç </strong> (<code>hvv_task.c</code>):</p>
<pre><code class="language-c">TaskHandle_t hvv_freertos_task_create(const char *name, hvv_task_func_t func,
                                      void *arg, hvv_task_options_t options) {
    stack = (StackType_t *)heap_caps_malloc(
        stack_size, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);  // PSRAM
    // ...
}
</code></pre>
<p><strong>Rust æ–¹æ¡ˆ</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use esp_idf_hal::task::*;
use esp_idf_sys::*;

fn create_task_psram&lt;F&gt;(name: &amp;str, stack_size: usize, f: F)
where
    F: FnOnce() + Send + 'static,
{
    // esp-idf-hal æ”¯æŒ PSRAM ä»»åŠ¡æ ˆ
    let config = TaskConfig {
        stack_size,
        priority: 5,
        // stack_in_psram: true,  // éœ€è¦æ£€æŸ¥ API
        ..Default::default()
    };
    std::thread::Builder::new()
        .stack_size(stack_size)
        .spawn(f)
        .unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p><strong>å¯è¡Œæ€§</strong>: âœ… å®Œå…¨å¯è¡Œï¼Œesp-idf-hal æ”¯æŒ PSRAM åˆ†é…</p>
<hr />
<h3 id="2-ble-é€šä¿¡-"><a class="header" href="#2-ble-é€šä¿¡-">2. BLE é€šä¿¡ âœ…</a></h3>
<p><strong>ç°æœ‰ä»£ç </strong>: åŸºäº NimBLE çš„è‡ªå®šä¹‰ BLE Serverï¼ŒåŒ…å«å¤æ‚çš„åˆ†å—ä¼ è¾“åè®®ã€‚</p>
<p><strong>Rust æ–¹æ¡ˆ</strong>: ä½¿ç”¨ <code>esp32-nimble</code> crate</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use esp32_nimble::{BLEDevice, BLEServer};

fn init_ble() -&gt; anyhow::Result&lt;()&gt; {
    let device = BLEDevice::take();
    let server = device.get_server();
    
    let service = server.create_service(uuid128!("12345678-..."));
    let characteristic = service.create_characteristic(
        uuid128!("87654321-..."),
        NimbleProperties::READ | NimbleProperties::WRITE | NimbleProperties::NOTIFY,
    );
    
    characteristic.on_write(|args| {
        // å¤„ç†å†™å…¥
    });
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>å¯è¡Œæ€§</strong>: âœ… esp32-nimble åŠŸèƒ½å®Œæ•´ï¼Œå¯ä»¥å®ç°ç°æœ‰çš„åˆ†å—ä¼ è¾“åè®®</p>
<hr />
<h3 id="3-lvgl-gui-"><a class="header" href="#3-lvgl-gui-">3. LVGL GUI âœ…</a></h3>
<p><strong>ç°æœ‰ä»£ç </strong> (<code>lvgl_disp.c</code>): çº¦ 200 è¡Œæ˜¾ç¤ºé©±åŠ¨ä»£ç </p>
<pre><code class="language-c">static void disp_flush_cb(lv_display_t *disp, const lv_area_t *area,
                          uint8_t *px_map) {
    lv_draw_sw_rgb565_swap(px_map, width * height);
    esp_lcd_panel_draw_bitmap(panel, x1, y1, x2 + 1, y2 + 1, px_map);
}
</code></pre>
<p><strong>Rust æ–¹æ¡ˆ</strong>: ä½¿ç”¨ <code>lvgl-rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use lvgl::{Display, DrawBuffer};

extern "C" fn disp_flush_cb(
    disp: *mut lv_display_t,
    area: *const lv_area_t,
    px_map: *mut u8,
) {
    // RGB565 swap
    // esp_lcd_panel_draw_bitmap (é€šè¿‡ FFI)
    unsafe { lv_display_flush_ready(disp) };
}

fn init_display() -&gt; anyhow::Result&lt;()&gt; {
    let buffer = DrawBuffer::&lt;{ 240 * 240 }&gt;::new();
    let display = Display::register(buffer, 240, 240, disp_flush_cb)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>å¯è¡Œæ€§</strong>: âœ… lvgl-rs æ˜¯å®˜æ–¹ bindingï¼Œæ˜¾ç¤ºé©±åŠ¨åªéœ€ç¿»è¯‘çº¦ 50 è¡Œä»£ç </p>
<hr />
<h3 id="4-éŸ³é¢‘å¤„ç†-"><a class="header" href="#4-éŸ³é¢‘å¤„ç†-">4. éŸ³é¢‘å¤„ç† âš ï¸</a></h3>
<p>è¿™æ˜¯æœ€å¤æ‚çš„éƒ¨åˆ†ï¼Œéœ€è¦ç§»é™¤ ESP-ADF å¹¶è‡ªè¡Œå®ç°ã€‚</p>
<h4 id="41-i2s-éŸ³é¢‘è¾“å…¥è¾“å‡º-"><a class="header" href="#41-i2s-éŸ³é¢‘è¾“å…¥è¾“å‡º-">4.1 I2S éŸ³é¢‘è¾“å…¥è¾“å‡º âœ…</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use esp_idf_hal::i2s::*;

fn audio_input_task() -&gt; anyhow::Result&lt;()&gt; {
    let i2s = I2sDriver::new_std_rx(
        peripherals.i2s0,
        &amp;StdRxConfig::new(
            16000,   // sample rate
            I2sSlotMode::Stereo,
            I2sDataBitWidth::Bits16,
        ),
        pins,
    )?;
    
    let mut buffer = [0i16; 320];  // 20ms @ 16kHz
    loop {
        i2s.read(&amp;mut buffer, BLOCK)?;
        // å¤„ç†éŸ³é¢‘...
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="42-opus-ç¼–è§£ç -"><a class="header" href="#42-opus-ç¼–è§£ç -">4.2 Opus ç¼–è§£ç  âœ…</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use opus::{Encoder, Decoder, Application};

let mut encoder = Encoder::new(16000, opus::Channels::Mono, Application::Voip)?;
let mut decoder = Decoder::new(16000, opus::Channels::Mono)?;

// ç¼–ç 
let encoded = encoder.encode(&amp;pcm_data, &amp;mut output)?;

// è§£ç 
let decoded = decoder.decode(&amp;opus_data, &amp;mut pcm_output, false)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="43-é‡é‡‡æ ·-"><a class="header" href="#43-é‡é‡‡æ ·-">4.3 é‡é‡‡æ · âš ï¸</a></h4>
<p><strong>ä¸æ¨è soxr</strong> (æ€§èƒ½å’Œå†…å­˜è¦æ±‚å¤ªé«˜)</p>
<p><strong>æ¨èæ–¹æ¡ˆ</strong>:</p>
<ul>
<li>ESP-ADF å†…ç½® resampler (é€šè¿‡ FFI)</li>
<li>Speex resampler (è½»é‡çº§)</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Speex resampler binding
extern "C" {
    fn speex_resampler_init(
        nb_channels: u32,
        in_rate: u32,
        out_rate: u32,
        quality: i32,
        err: *mut i32,
    ) -&gt; *mut SpeexResamplerState;
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="5-aec-å›å£°æ¶ˆé™¤-"><a class="header" href="#5-aec-å›å£°æ¶ˆé™¤-">5. AEC å›å£°æ¶ˆé™¤ âš ï¸</a></h3>
<h4 id="ç¡¬ä»¶æƒ…å†µ"><a class="header" href="#ç¡¬ä»¶æƒ…å†µ">ç¡¬ä»¶æƒ…å†µ</a></h4>
<p>ES8311 codec <strong>ä¸æ˜¯ç¡¬ä»¶ AEC</strong>ï¼å®ƒåªæ˜¯æŠŠ MIC å’Œ Speaker å‚è€ƒä¿¡å·åŒæ­¥è¾“å‡ºåˆ° I2Sï¼š</p>
<pre><code>ES8311 I2S è¾“å‡º:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Left Channel  â”‚ Right Channel â”‚
â”‚  (MIC åŸå§‹)    â”‚ (Speaker å‚è€ƒ) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
    è¿˜éœ€è¦è½¯ä»¶ AECï¼
</code></pre>
<h4 id="æ–¹æ¡ˆé€‰æ‹©"><a class="header" href="#æ–¹æ¡ˆé€‰æ‹©">æ–¹æ¡ˆé€‰æ‹©</a></h4>
<div class="table-wrapper"><table><thead><tr><th>æ–¹æ¡ˆ</th><th>ä¼˜ç‚¹</th><th>ç¼ºç‚¹</th></tr></thead><tbody>
<tr><td><strong>esp_afe binding</strong></td><td>æ•ˆæœæœ€å¥½ï¼Œå®˜æ–¹ç»´æŠ¤</td><td>é—­æºï¼Œéœ€è¦å†™ bindgen</td></tr>
<tr><td><strong>Speex AEC</strong></td><td>å¼€æºï¼Œè½»é‡</td><td>æ•ˆæœä¸€èˆ¬</td></tr>
<tr><td><strong>è‡ªå·±å®ç° NLMS</strong></td><td>å®Œå…¨å¯æ§</td><td>æ•ˆæœå·®ï¼Œå·¥ä½œé‡å¤§</td></tr>
</tbody></table>
</div>
<p><strong>æ¨è</strong>: esp_afe binding</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// esp_afe FFI binding (é€šè¿‡ bindgen ç”Ÿæˆ)
use esp_afe_sys::*;

fn init_afe() -&gt; *mut esp_afe_sr_iface_t {
    unsafe {
        let config = afe_config_t {
            // ...
        };
        esp_afe_sr_create(&amp;config)
    }
}

fn process_audio(afe: *mut esp_afe_sr_iface_t, mic: &amp;[i16], ref_: &amp;[i16]) -&gt; Vec&lt;i16&gt; {
    unsafe {
        // è°ƒç”¨ esp_afe å¤„ç†
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="ä¾èµ–ç®¡ç†æ–¹æ¡ˆ"><a class="header" href="#ä¾èµ–ç®¡ç†æ–¹æ¡ˆ">ä¾èµ–ç®¡ç†æ–¹æ¡ˆ</a></h2>
<h3 id="bazel-ç®¡ç†-c-ä¾èµ–"><a class="header" href="#bazel-ç®¡ç†-c-ä¾èµ–">Bazel ç®¡ç† C ä¾èµ–</a></h3>
<p>ç°æœ‰é¡¹ç›®å·²ä½¿ç”¨ Bazel ç®¡ç† <code>opus</code>, <code>ogg</code> ç­‰ C ä¾èµ–ã€‚å¯ä»¥ç»§ç»­ä½¿ç”¨ï¼š</p>
<pre><code class="language-python"># WORKSPACE
http_archive(
    name = "opus",
    urls = ["https://github.com/xiph/opus/archive/v1.5.2.tar.gz"],
    strip_prefix = "opus-1.5.2",
)
</code></pre>
<h3 id="esp-idf-cmake-å¼•ç”¨-bazel-è¾“å‡º"><a class="header" href="#esp-idf-cmake-å¼•ç”¨-bazel-è¾“å‡º">ESP-IDF CMake å¼•ç”¨ Bazel è¾“å‡º</a></h3>
<p>ESP-IDF çš„ CMakeLists.txt å¯ä»¥ç›´æ¥å¼•ç”¨ Bazel ä¸‹è½½çš„æºç ï¼š</p>
<pre><code class="language-cmake"># components/opus/CMakeLists.txt

# è·å– Bazel external ç›®å½•
execute_process(
    COMMAND bazel info output_base
    OUTPUT_VARIABLE BAZEL_OUTPUT_BASE
    OUTPUT_STRIP_TRAILING_WHITESPACE
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/../../..
)

# æŒ‡å‘ Bazel ä¸‹è½½çš„ opus æºç 
set(OPUS_DIR "${BAZEL_OUTPUT_BASE}/external/opus")

# ä½¿ç”¨è¿™äº›æºç ç¼–è¯‘
file(GLOB_RECURSE OPUS_SRCS "${OPUS_DIR}/src/*.c")
idf_component_register(
    SRCS ${OPUS_SRCS}
    INCLUDE_DIRS "${OPUS_DIR}/include"
)
</code></pre>
<h3 id="cargo-é“¾æ¥-bazel-æ„å»ºäº§ç‰©"><a class="header" href="#cargo-é“¾æ¥-bazel-æ„å»ºäº§ç‰©">Cargo é“¾æ¥ Bazel æ„å»ºäº§ç‰©</a></h3>
<pre><pre class="playground"><code class="language-rust">// build.rs
fn main() {
    let bazel_output = Command::new("bazel")
        .args(["info", "output_base"])
        .output()
        .expect("bazel not found");
    
    let external_dir = format!(
        "{}/external",
        String::from_utf8_lossy(&amp;bazel_output.stdout).trim()
    );
    
    println!("cargo:rustc-link-search={}/opus/lib", external_dir);
    println!("cargo:rustc-link-lib=static=opus");
}</code></pre></pre>
<hr />
<h2 id="å¼€å‘å’Œè°ƒè¯•å·¥å…·"><a class="header" href="#å¼€å‘å’Œè°ƒè¯•å·¥å…·">å¼€å‘å’Œè°ƒè¯•å·¥å…·</a></h2>
<h3 id="æ„å»ºå’Œçƒ§å½•"><a class="header" href="#æ„å»ºå’Œçƒ§å½•">æ„å»ºå’Œçƒ§å½•</a></h3>
<pre><code class="language-bash"># å®‰è£… esp-rs å·¥å…·é“¾
cargo install espup
espup install

# æ„å»º
cargo build --release

# çƒ§å½• (ä¸éœ€è¦ idf.py)
cargo espflash flash --release --monitor
</code></pre>
<h3 id="æ¨¡æ‹Ÿå™¨"><a class="header" href="#æ¨¡æ‹Ÿå™¨">æ¨¡æ‹Ÿå™¨</a></h3>
<h4 id="qemu-æœ¬åœ°"><a class="header" href="#qemu-æœ¬åœ°">QEMU (æœ¬åœ°)</a></h4>
<pre><code class="language-bash"># å®‰è£… QEMU ESP32 æ”¯æŒ
# (ç›®å‰å®˜æ–¹æ”¯æŒæœ‰é™ï¼Œä¸»è¦ç”¨äºç®€å•æµ‹è¯•)
qemu-system-xtensa -machine esp32 -nographic -drive file=flash.bin,format=raw
</code></pre>
<h4 id="wokwi-åœ¨çº¿"><a class="header" href="#wokwi-åœ¨çº¿">Wokwi (åœ¨çº¿)</a></h4>
<ul>
<li>ç½‘å€: https://wokwi.com/</li>
<li>æ”¯æŒ ESP32/ESP32-S3</li>
<li>å¯ä»¥æ¨¡æ‹Ÿ LEDã€æŒ‰é’®ã€æ˜¾ç¤ºå±ç­‰å¤–è®¾</li>
<li>æ”¯æŒ Rust é¡¹ç›®</li>
</ul>
<pre><code class="language-json">// wokwi.toml
[wokwi]
version = 1
firmware = "target/xtensa-esp32s3-espidf/release/my-project"
elf = "target/xtensa-esp32s3-espidf/release/my-project"

[[parts]]
id = "esp32s3"
x = 0
y = 0
</code></pre>
<p><strong>é™åˆ¶</strong>:</p>
<ul>
<li>ä¸æ”¯æŒçœŸå®çš„ I2S éŸ³é¢‘</li>
<li>BLE æ¨¡æ‹Ÿæœ‰é™</li>
<li>ä¸»è¦ç”¨äº GPIO/æ˜¾ç¤ºé€»è¾‘æµ‹è¯•</li>
</ul>
<hr />
<h2 id="å·¥ä½œé‡è¯„ä¼°"><a class="header" href="#å·¥ä½œé‡è¯„ä¼°">å·¥ä½œé‡è¯„ä¼°</a></h2>
<div class="table-wrapper"><table><thead><tr><th>æ¨¡å—</th><th>å·¥ä½œé‡</th><th>é£é™©</th></tr></thead><tbody>
<tr><td>é¡¹ç›®ç»“æ„æ­å»º</td><td>1 å‘¨</td><td>ä½</td></tr>
<tr><td>FreeRTOS ä»»åŠ¡å°è£…</td><td>1 å‘¨</td><td>ä½</td></tr>
<tr><td>BLE é€šä¿¡</td><td>2 å‘¨</td><td>ä¸­</td></tr>
<tr><td>LVGL æ˜¾ç¤ºé©±åŠ¨</td><td>1 å‘¨</td><td>ä½</td></tr>
<tr><td>UI åº”ç”¨å±‚</td><td>3 å‘¨</td><td>ä¸­</td></tr>
<tr><td>I2S éŸ³é¢‘</td><td>1 å‘¨</td><td>ä½</td></tr>
<tr><td>Opus ç¼–è§£ç </td><td>1 å‘¨</td><td>ä½</td></tr>
<tr><td>AEC (esp_afe binding)</td><td>2 å‘¨</td><td><strong>é«˜</strong></td></tr>
<tr><td>MQTT é€šä¿¡</td><td>1 å‘¨</td><td>ä½</td></tr>
<tr><td>NVS å­˜å‚¨</td><td>0.5 å‘¨</td><td>ä½</td></tr>
<tr><td>æµ‹è¯•å’Œè°ƒè¯•</td><td>2 å‘¨</td><td>ä¸­</td></tr>
<tr><td><strong>æ€»è®¡</strong></td><td><strong>~15 å‘¨</strong></td><td>-</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="å‚è€ƒèµ„æº-1"><a class="header" href="#å‚è€ƒèµ„æº-1">å‚è€ƒèµ„æº</a></h2>
<ul>
<li><a href="https://esp-rs.github.io/book/">esp-rs Book</a></li>
<li><a href="https://github.com/esp-rs/esp-idf-hal">esp-idf-hal</a></li>
<li><a href="https://github.com/esp-rs/esp-idf-svc">esp-idf-svc</a></li>
<li><a href="https://github.com/taks/esp32-nimble">esp32-nimble</a></li>
<li><a href="https://github.com/lvgl/lv_binding_rust">lvgl-rs</a></li>
<li><a href="https://wokwi.com/">Wokwi Simulator</a></li>
</ul>
<hr />
<h2 id="ä¸‹ä¸€æ­¥"><a class="header" href="#ä¸‹ä¸€æ­¥">ä¸‹ä¸€æ­¥</a></h2>
<ol>
<li>âœ… åˆ›å»º giztoy Rust é¡¹ç›®éª¨æ¶</li>
<li>âœ… æ•´åˆ opus/ogg ç»„ä»¶åˆ° <code>esp/components/</code></li>
<li>âœ… åˆ›å»º ESP-RS hello world ç¤ºä¾‹ (<code>esp/rust/hello/</code>)</li>
<li>âœ… åˆ›å»º Opus codec Rust ç¤ºä¾‹ (<code>esp/rust/opus-example/</code>)</li>
<li>âœ… <strong>Hello World åœ¨ ESP32-S3 ä¸Šè¿è¡ŒæˆåŠŸ</strong> (2026-01-22)
<ul>
<li>å †å†…å­˜: 8.7MB (PSRAM å·²å¯ç”¨)</li>
<li>ESP-IDF v5.3 + Rust 1.90.0</li>
</ul>
</li>
<li>â¬œ å®ç° LED é—ªçƒ Demo</li>
<li>â¬œ ç§»æ¤ LVGL æ˜¾ç¤ºé©±åŠ¨</li>
<li>â¬œ ç§»æ¤ BLE é€šä¿¡</li>
<li>â¬œ ç§»æ¤éŸ³é¢‘è¾“å…¥è¾“å‡º (I2S)</li>
<li>â¬œ é›†æˆ esp_afe AEC</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-vs-rust-åŒ…å¯¹æ¯”æ–‡æ¡£"><a class="header" href="#go-vs-rust-åŒ…å¯¹æ¯”æ–‡æ¡£">Go vs Rust åŒ…å¯¹æ¯”æ–‡æ¡£</a></h1>
<p>æœ¬æ–‡æ¡£å¯¹æ¯” Go å’Œ Rust ä¸¤è¾¹çš„åŒ…å®ç°ï¼Œåˆ†æåŠŸèƒ½è¦ç‚¹ã€éš¾ç‚¹å’Œå·®å¼‚ã€‚</p>
<h2 id="-æ¦‚è§ˆ"><a class="header" href="#-æ¦‚è§ˆ">ğŸ“Š æ¦‚è§ˆ</a></h2>
<div class="table-wrapper"><table><thead><tr><th>åŒ…å</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>çŠ¶æ€</th></tr></thead><tbody>
<tr><td>audio</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>Rust ç¼ºå°‘ portaudio</td></tr>
<tr><td>buffer</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>åŸºæœ¬ä¸€è‡´</td></tr>
<tr><td>chatgear</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td>cli</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td><td>Rust ç¼ºå°‘å¤šæ•°åŠŸèƒ½</td></tr>
<tr><td>dashscope</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>åŸºæœ¬ä¸€è‡´</td></tr>
<tr><td>doubaospeech</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>åŸºæœ¬ä¸€è‡´</td></tr>
<tr><td>encoding</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td>genx</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td><td>Rust ç¼ºå°‘ agent æ¡†æ¶</td></tr>
<tr><td>jsontime</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td>minimax</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>åŸºæœ¬ä¸€è‡´</td></tr>
<tr><td>mqtt0</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>åŸºæœ¬ä¸€è‡´</td></tr>
<tr><td>speech</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td>trie</td><td style="text-align: center">âœ…</td><td style="text-align: center">âš ï¸</td><td>Rust å†…åµŒåœ¨ mqtt0</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-audio---éŸ³é¢‘å¤„ç†"><a class="header" href="#-audio---éŸ³é¢‘å¤„ç†">ğŸ“¦ audio - éŸ³é¢‘å¤„ç†</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹"><a class="header" href="#åŠŸèƒ½è¦ç‚¹">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>pcm</strong>: PCM éŸ³é¢‘æ ¼å¼å¤„ç†ã€æ··éŸ³ã€é™éŸ³ç”Ÿæˆ</li>
<li><strong>codec</strong>: éŸ³é¢‘ç¼–è§£ç ï¼ˆOggã€Opusã€MP3ã€Lameï¼‰</li>
<li><strong>opusrt</strong>: Opus å®æ—¶ç¼–è§£ç å™¨ï¼Œé’ˆå¯¹ä½å»¶è¿Ÿåœºæ™¯ä¼˜åŒ–</li>
<li><strong>resampler</strong>: é‡‡æ ·ç‡è½¬æ¢ï¼ˆåŸºäº soxr åº“ï¼‰</li>
<li><strong>songs</strong>: å†…ç½®æµ‹è¯•æ—‹å¾‹ï¼ˆç”¨äºéªŒè¯éŸ³é¢‘æ’­æ”¾ï¼‰</li>
<li><strong>portaudio</strong>: å®æ—¶å½•éŸ³/æ’­æ”¾ï¼ˆGo ç‹¬æœ‰ï¼‰</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>C åº“ç»‘å®š</strong>: éœ€è¦ç»‘å®š libopusã€libsoxrã€libmp3lame ç­‰ C åº“</li>
<li><strong>å†…å­˜ç®¡ç†</strong>: éŸ³é¢‘æ•°æ®é€šå¸¸å¾ˆå¤§ï¼Œéœ€è¦é¿å…ä¸å¿…è¦çš„æ‹·è´</li>
<li><strong>å®æ—¶æ€§</strong>: opusrt éœ€è¦ä¿è¯ä½å»¶è¿Ÿï¼Œé¿å…é˜»å¡</li>
<li><strong>æ ¼å¼è½¬æ¢</strong>: ä¸åŒé‡‡æ ·ç‡ã€å£°é“æ•°ã€ä½æ·±çš„è½¬æ¢</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚"><a class="header" href="#go-vs-rust-å·®å¼‚">Go vs Rust å·®å¼‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŠŸèƒ½</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td>pcm</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>codec</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>opusrt</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>resampler</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>songs</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td><strong>portaudio</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust ç¼ºå¤±å®æ—¶å½•éŸ³/æ’­æ”¾</td></tr>
</tbody></table>
</div>
<h3 id="rust-å¾…å®ç°"><a class="header" href="#rust-å¾…å®ç°">Rust å¾…å®ç°</a></h3>
<pre><code>rust/audio/src/
  â””â”€â”€ portaudio/     # éœ€è¦ç»‘å®š libportaudio
        â”œâ”€â”€ mod.rs
        â”œâ”€â”€ stream.rs   # è¾“å…¥/è¾“å‡ºæµ
        â””â”€â”€ device.rs   # è®¾å¤‡æšä¸¾
</code></pre>
<hr />
<h2 id="-buffer---çº¿ç¨‹å®‰å…¨-buffer"><a class="header" href="#-buffer---çº¿ç¨‹å®‰å…¨-buffer">ğŸ“¦ buffer - çº¿ç¨‹å®‰å…¨ Buffer</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-1"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-1">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>Buffer</strong>: å¯å¢é•¿çš„åŠ¨æ€ bufferï¼Œæ°¸ä¸é˜»å¡å†™å…¥</li>
<li><strong>BlockBuffer</strong>: å›ºå®šå¤§å°é˜»å¡ bufferï¼Œæä¾›èƒŒå‹æœºåˆ¶</li>
<li><strong>RingBuffer</strong>: å›ºå®šå¤§å°ç¯å½¢ bufferï¼Œæ»¡æ—¶è¦†ç›–æ—§æ•°æ®</li>
<li><strong>bytes</strong>: é¢„å®šä¹‰å¤§å°çš„ä¾¿æ·æ„é€ å‡½æ•°ï¼ˆ1KBã€4KBã€16KB ç­‰ï¼‰</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-1"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-1">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>å¹¶å‘å®‰å…¨</strong>: å¤šç”Ÿäº§è€…/å¤šæ¶ˆè´¹è€…åœºæ™¯ä¸‹çš„æ•°æ®ä¸€è‡´æ€§</li>
<li><strong>é˜»å¡/å”¤é†’</strong>: BlockBuffer éœ€è¦é«˜æ•ˆçš„æ¡ä»¶å˜é‡å®ç°</li>
<li><strong>å…³é—­è¯­ä¹‰</strong>: åŒºåˆ† <code>close_write</code>ï¼ˆå…è®¸è¯»å–å‰©ä½™æ•°æ®ï¼‰å’Œ <code>close_with_error</code>ï¼ˆç«‹å³å…³é—­ï¼‰</li>
<li><strong>æ³›å‹è®¾è®¡</strong>: æ”¯æŒä»»æ„å…ƒç´ ç±»å‹ <code>T</code></li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-1"><a class="header" href="#go-vs-rust-å·®å¼‚-1">Go vs Rust å·®å¼‚</a></h3>
<p>âœ… <strong>å®ç°åŸºæœ¬ä¸€è‡´</strong></p>
<p>Go ä½¿ç”¨ <code>sync.Mutex</code> + <code>sync.Cond</code>ï¼ŒRust ä½¿ç”¨ <code>Mutex&lt;T&gt;</code> + <code>Condvar</code>ã€‚</p>
<hr />
<h2 id="-chatgear---è®¾å¤‡é€šä¿¡æ¡†æ¶--rust-ç¼ºå¤±"><a class="header" href="#-chatgear---è®¾å¤‡é€šä¿¡æ¡†æ¶--rust-ç¼ºå¤±">ğŸ“¦ chatgear - è®¾å¤‡é€šä¿¡æ¡†æ¶ âš ï¸ Rust ç¼ºå¤±</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-2"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-2">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>GearState</strong>: è®¾å¤‡çŠ¶æ€æœºï¼ˆsleeping â†’ ready â†’ recording â†’ streamingï¼‰</li>
<li><strong>GearStateEvent</strong>: çŠ¶æ€å˜æ›´äº‹ä»¶ï¼Œæ”¯æŒåˆå¹¶å’Œå…‹éš†</li>
<li><strong>Command</strong>: è®¾å¤‡å‘½ä»¤ç³»ç»Ÿ</li>
<li><strong>Port</strong>: ç«¯å£æŠ½è±¡ï¼ˆClientPortã€ServerPortï¼‰</li>
<li><strong>Conn</strong>: è¿æ¥ç®¡ç†</li>
<li><strong>Stats</strong>: ç»Ÿè®¡æ•°æ®æ”¶é›†</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-2"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-2">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>çŠ¶æ€æœºè®¾è®¡</strong>: éœ€è¦å®šä¹‰æ¸…æ™°çš„çŠ¶æ€è½¬æ¢è§„åˆ™</li>
<li><strong>äº‹ä»¶åˆå¹¶</strong>: å¤„ç†ä¹±åºäº‹ä»¶ï¼Œä¿è¯æœ€ç»ˆä¸€è‡´æ€§</li>
<li><strong>JSON åºåˆ—åŒ–</strong>: æšä¸¾ç±»å‹éœ€è¦åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²</li>
<li><strong>åŒå‘é€šä¿¡</strong>: ç«¯å£æŠ½è±¡éœ€è¦æ”¯æŒè¯·æ±‚/å“åº”æ¨¡å¼</li>
</ol>
<h3 id="çŠ¶æ€æµè½¬å›¾"><a class="header" href="#çŠ¶æ€æµè½¬å›¾">çŠ¶æ€æµè½¬å›¾</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  sleeping  â”‚â”€â”€â”€â”€â–¶â”‚   ready   â”‚â”€â”€â”€â”€â–¶â”‚ recording  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â–²                  â”‚                 â”‚
      â”‚                  â–¼                 â–¼
      â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ resetting â”‚â—€â”€â”€â”€â”€â”‚ streaming  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="rust-å¾…å®ç°-1"><a class="header" href="#rust-å¾…å®ç°-1">Rust å¾…å®ç°</a></h3>
<pre><code>rust/chatgear/
  â”œâ”€â”€ Cargo.toml
  â””â”€â”€ src/
        â”œâ”€â”€ lib.rs
        â”œâ”€â”€ state.rs      # GearState æšä¸¾å’Œäº‹ä»¶
        â”œâ”€â”€ command.rs    # å‘½ä»¤ç±»å‹
        â”œâ”€â”€ port.rs       # ç«¯å£æŠ½è±¡
        â”œâ”€â”€ conn.rs       # è¿æ¥ç®¡ç†
        â””â”€â”€ stats.rs      # ç»Ÿè®¡æ•°æ®
</code></pre>
<hr />
<h2 id="-cli---cli-å·¥å…·åº“"><a class="header" href="#-cli---cli-å·¥å…·åº“">ğŸ“¦ cli - CLI å·¥å…·åº“</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-3"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-3">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>config</strong>: é…ç½®ç®¡ç†ï¼Œæ”¯æŒå¤š contextï¼ˆç±»ä¼¼ kubectlï¼‰</li>
<li><strong>output</strong>: è¾“å‡ºæ ¼å¼åŒ–ï¼ˆJSONã€YAMLã€Tableï¼‰</li>
<li><strong>request</strong>: è¯·æ±‚æ–‡ä»¶åŠ è½½ï¼ˆYAML/JSONï¼‰</li>
<li><strong>paths</strong>: è·¯å¾„å·¥å…·å‡½æ•°</li>
<li><strong>tui</strong>: ç»ˆç«¯ UI ç»„ä»¶</li>
<li><strong>log_writer</strong>: æ—¥å¿—å†™å…¥å™¨</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-3"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-3">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>é…ç½®ç›®å½•</strong>: éœ€è¦å¤„ç† <code>~/.giztoy/&lt;app&gt;/</code> ç›®å½•ç»“æ„</li>
<li><strong>å¤šæ ¼å¼è¾“å‡º</strong>: æ ¹æ®ç”¨æˆ·é€‰æ‹©è¾“å‡ºä¸åŒæ ¼å¼</li>
<li><strong>TUI äº¤äº’</strong>: ç»ˆç«¯é¢œè‰²ã€è¿›åº¦æ¡ç­‰</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-2"><a class="header" href="#go-vs-rust-å·®å¼‚-2">Go vs Rust å·®å¼‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŠŸèƒ½</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td>config</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>output</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td><strong>request</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust ç¼ºå¤±è¯·æ±‚æ–‡ä»¶åŠ è½½</td></tr>
<tr><td><strong>paths</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust ç¼ºå¤±è·¯å¾„å·¥å…·</td></tr>
<tr><td><strong>tui</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust ç¼ºå¤± TUI ç»„ä»¶</td></tr>
<tr><td><strong>log_writer</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust ç¼ºå¤±æ—¥å¿—å†™å…¥å™¨</td></tr>
<tr><td><strong>format</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust ç¼ºå¤±æ ¼å¼åŒ–å·¥å…·</td></tr>
</tbody></table>
</div>
<h3 id="rust-å¾…å®ç°-2"><a class="header" href="#rust-å¾…å®ç°-2">Rust å¾…å®ç°</a></h3>
<pre><code>rust/cli/src/
  â”œâ”€â”€ request.rs    # è¯·æ±‚æ–‡ä»¶åŠ è½½
  â”œâ”€â”€ paths.rs      # è·¯å¾„å·¥å…·
  â”œâ”€â”€ tui.rs        # TUI ç»„ä»¶
  â”œâ”€â”€ log_writer.rs # æ—¥å¿—å†™å…¥å™¨
  â””â”€â”€ format.rs     # æ ¼å¼åŒ–å·¥å…·
</code></pre>
<hr />
<h2 id="-dashscope---é˜¿é‡Œäº‘-dashscope-sdk"><a class="header" href="#-dashscope---é˜¿é‡Œäº‘-dashscope-sdk">ğŸ“¦ dashscope - é˜¿é‡Œäº‘ DashScope SDK</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-4"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-4">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>Client</strong>: HTTP å®¢æˆ·ç«¯ï¼Œæ”¯æŒ API Key å’Œ Workspace è®¤è¯</li>
<li><strong>Realtime</strong>: Qwen-Omni-Realtime WebSocket ä¼šè¯</li>
<li><strong>Event</strong>: äº‹ä»¶ç±»å‹å®šä¹‰å’Œè§£æ</li>
<li><strong>Types</strong>: è¯·æ±‚/å“åº”ç±»å‹</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-4"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-4">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>WebSocket ç®¡ç†</strong>: ä¿æŒé•¿è¿æ¥ã€å¿ƒè·³ã€é‡è¿</li>
<li><strong>äº‹ä»¶è§£æ</strong>: æœåŠ¡ç«¯æ¨é€çš„å¤šç§äº‹ä»¶ç±»å‹</li>
<li><strong>éŸ³é¢‘æµ</strong>: å®æ—¶å‘é€/æ¥æ”¶éŸ³é¢‘æ•°æ®</li>
<li><strong>å¹¶å‘æ§åˆ¶</strong>: åŒæ—¶å‘é€å’Œæ¥æ”¶æ¶ˆæ¯</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-3"><a class="header" href="#go-vs-rust-å·®å¼‚-3">Go vs Rust å·®å¼‚</a></h3>
<p>âœ… <strong>å®ç°åŸºæœ¬ä¸€è‡´</strong></p>
<hr />
<h2 id="-doubaospeech---è±†åŒ…è¯­éŸ³-sdk"><a class="header" href="#-doubaospeech---è±†åŒ…è¯­éŸ³-sdk">ğŸ“¦ doubaospeech - è±†åŒ…è¯­éŸ³ SDK</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-5"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-5">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>TTS</strong>: è¯­éŸ³åˆæˆï¼ˆåŒæ­¥ã€æµå¼ã€å¼‚æ­¥ï¼‰</li>
<li><strong>ASR</strong>: è¯­éŸ³è¯†åˆ«ï¼ˆä¸€å¥è¯ã€æµå¼ã€æ–‡ä»¶ï¼‰</li>
<li><strong>Voice Clone</strong>: å£°éŸ³å¤åˆ»</li>
<li><strong>Realtime</strong>: ç«¯åˆ°ç«¯å®æ—¶è¯­éŸ³å¯¹è¯</li>
<li><strong>Meeting</strong>: ä¼šè®®è½¬å†™å’Œçºªè¦</li>
<li><strong>Podcast</strong>: å¤šäººæ’­å®¢åˆæˆ</li>
<li><strong>Translation</strong>: åŒå£°ä¼ è¯‘</li>
<li><strong>Media</strong>: éŸ³è§†é¢‘å­—å¹•æå–</li>
<li><strong>Console</strong>: æ§åˆ¶å° APIï¼ˆAK/SK ç­¾åè®¤è¯ï¼‰</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-5"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-5">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>å¤šç§è®¤è¯</strong>: API Keyã€Bearer Tokenã€AK/SK ç­¾å</li>
<li><strong>æµå¼åè®®</strong>: è‡ªå®šä¹‰äºŒè¿›åˆ¶åè®®ï¼ŒåŒ…å«å¤´éƒ¨æ ‡è¯†</li>
<li><strong>WebSocket ä¼šè¯</strong>: å¤šç§èµ„æºç±»å‹ï¼Œä¸åŒçš„ URL æ¨¡å¼</li>
<li><strong>å¼‚æ­¥ä»»åŠ¡</strong>: æäº¤ä»»åŠ¡ã€è½®è¯¢çŠ¶æ€ã€è·å–ç»“æœ</li>
</ol>
<h3 id="åè®®æ ¼å¼"><a class="header" href="#åè®®æ ¼å¼">åè®®æ ¼å¼</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Header (4 bytes)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Payload Size (4 bytes)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Payload (variable)                               â”‚
â”‚  - JSON for text responses                       â”‚
â”‚  - Binary for audio data                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="go-vs-rust-å·®å¼‚-4"><a class="header" href="#go-vs-rust-å·®å¼‚-4">Go vs Rust å·®å¼‚</a></h3>
<p>âœ… <strong>å®ç°åŸºæœ¬ä¸€è‡´</strong></p>
<hr />
<h2 id="-encoding---json-ç¼–ç ç±»å‹--rust-ç¼ºå¤±"><a class="header" href="#-encoding---json-ç¼–ç ç±»å‹--rust-ç¼ºå¤±">ğŸ“¦ encoding - JSON ç¼–ç ç±»å‹ âš ï¸ Rust ç¼ºå¤±</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-6"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-6">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>StdBase64Data</strong>: æ ‡å‡† Base64 ç¼–ç çš„å­—èŠ‚åˆ‡ç‰‡</li>
<li><strong>HexData</strong>: åå…­è¿›åˆ¶ç¼–ç çš„å­—èŠ‚åˆ‡ç‰‡</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-6"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-6">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>JSON åºåˆ—åŒ–</strong>: è‡ªå®šä¹‰åºåˆ—åŒ–/ååºåˆ—åŒ–</li>
<li><strong>ç©ºå€¼å¤„ç†</strong>: å¤„ç† <code>null</code> å€¼</li>
</ol>
<h3 id="rust-å¾…å®ç°-3"><a class="header" href="#rust-å¾…å®ç°-3">Rust å¾…å®ç°</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rust/encoding/src/lib.rs

use serde::{Deserialize, Serialize, Deserializer, Serializer};
use base64::{Engine, engine::general_purpose::STANDARD};

#[derive(Debug, Clone, Default)]
pub struct StdBase64Data(pub Vec&lt;u8&gt;);

impl Serialize for StdBase64Data {
    fn serialize&lt;S: Serializer&gt;(&amp;self, s: S) -&gt; Result&lt;S::Ok, S::Error&gt; {
        s.serialize_str(&amp;STANDARD.encode(&amp;self.0))
    }
}

impl&lt;'de&gt; Deserialize&lt;'de&gt; for StdBase64Data {
    fn deserialize&lt;D: Deserializer&lt;'de&gt;&gt;(d: D) -&gt; Result&lt;Self, D::Error&gt; {
        let s = String::deserialize(d)?;
        let bytes = STANDARD.decode(s).map_err(serde::de::Error::custom)?;
        Ok(StdBase64Data(bytes))
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="-genx---llm-ç»Ÿä¸€æ¥å£"><a class="header" href="#-genx---llm-ç»Ÿä¸€æ¥å£">ğŸ“¦ genx - LLM ç»Ÿä¸€æ¥å£</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-7"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-7">åŠŸèƒ½è¦ç‚¹</a></h3>
<h4 id="æ ¸å¿ƒ-go--rust"><a class="header" href="#æ ¸å¿ƒ-go--rust">æ ¸å¿ƒ (Go &amp; Rust)</a></h4>
<ul>
<li><strong>Message/Contents</strong>: æ¶ˆæ¯å’Œå†…å®¹ç±»å‹</li>
<li><strong>FuncTool</strong>: å‡½æ•°å·¥å…·ï¼ˆJSON Schemaï¼‰</li>
<li><strong>Stream</strong>: æµå¼å“åº”å¤„ç†</li>
<li><strong>Generator</strong>: LLM ç”Ÿæˆå™¨ trait</li>
<li><strong>ModelContext</strong>: æ¨¡å‹ä¸Šä¸‹æ–‡</li>
</ul>
<h4 id="é«˜çº§åŠŸèƒ½-go-ç‹¬æœ‰"><a class="header" href="#é«˜çº§åŠŸèƒ½-go-ç‹¬æœ‰">é«˜çº§åŠŸèƒ½ (Go ç‹¬æœ‰)</a></h4>
<ul>
<li><strong>agent/</strong>: Agent æ¡†æ¶
<ul>
<li>ReActAgent: æ¨ç†-è¡ŒåŠ¨å¾ªç¯</li>
<li>MatchAgent: æ„å›¾åŒ¹é…è·¯ç”±</li>
<li>Tool ç³»ç»Ÿ: BuiltinToolã€GeneratorToolã€HTTPToolã€CompositeTool</li>
</ul>
</li>
<li><strong>agentcfg/</strong>: Agent é…ç½®ç³»ç»Ÿ
<ul>
<li>YAML/JSON é…ç½®åŠ è½½</li>
<li>$ref å¼•ç”¨ç³»ç»Ÿ</li>
<li>çŠ¶æ€åºåˆ—åŒ–</li>
</ul>
</li>
<li><strong>match/</strong>: è§„åˆ™åŒ¹é…å¼•æ“
<ul>
<li>æ¨¡å¼å®šä¹‰</li>
<li>å˜é‡æå–</li>
</ul>
</li>
<li><strong>generators/</strong>: Generator å®ç°é›†åˆ</li>
<li><strong>modelcontexts/</strong>: ModelContext å®ç°é›†åˆ</li>
<li><strong>playground/</strong>: æµ‹è¯•å’Œè°ƒè¯•å·¥å…·</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-7"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-7">æŠ€æœ¯éš¾ç‚¹</a></h3>
<h4 id="æ ¸å¿ƒ"><a class="header" href="#æ ¸å¿ƒ">æ ¸å¿ƒ</a></h4>
<ol>
<li><strong>JSON Schema ç”Ÿæˆ</strong>: ä»ç±»å‹å®šä¹‰è‡ªåŠ¨ç”Ÿæˆ JSON Schema</li>
<li><strong>æµå¼å¤„ç†</strong>: å¤„ç† SSE æˆ– WebSocket æµ</li>
<li><strong>å¤šæ¨¡æ€</strong>: æ–‡æœ¬ã€å›¾ç‰‡ã€éŸ³é¢‘çš„ç»Ÿä¸€å¤„ç†</li>
</ol>
<h4 id="agent-æ¡†æ¶"><a class="header" href="#agent-æ¡†æ¶">Agent æ¡†æ¶</a></h4>
<ol>
<li><strong>çŠ¶æ€ç®¡ç†</strong>: Agent æ‰§è¡Œè¿‡ç¨‹ä¸­çš„çŠ¶æ€ä¿å­˜å’Œæ¢å¤</li>
<li><strong>å·¥å…·ç¼–æ’</strong>: å¤šå·¥å…·ç»„åˆã€é¡ºåºæ‰§è¡Œã€æ¡ä»¶åˆ†æ”¯</li>
<li><strong>åŒ¹é…å¼•æ“</strong>: è§„åˆ™è§£æã€å˜é‡æå–ã€ä¼˜å…ˆçº§å¤„ç†</li>
<li><strong>é…ç½®ç³»ç»Ÿ</strong>: å¼•ç”¨è§£æã€ç±»å‹éªŒè¯ã€çƒ­é‡è½½</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-5"><a class="header" href="#go-vs-rust-å·®å¼‚-5">Go vs Rust å·®å¼‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŠŸèƒ½</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td>Message/Contents</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>FuncTool</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>Stream</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>Generator</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>OpenAI é€‚é…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td>Gemini é€‚é…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>å®ç°ä¸€è‡´</td></tr>
<tr><td><strong>agent/</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td><strong>agentcfg/</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td><strong>match/</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td><strong>generators/</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td><strong>modelcontexts/</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
<tr><td><strong>playground/</strong></td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å®Œå…¨ç¼ºå¤±</td></tr>
</tbody></table>
</div>
<h3 id="agent-æ¶æ„å›¾"><a class="header" href="#agent-æ¶æ„å›¾">Agent æ¶æ„å›¾</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Router Agent (Match)                    â”‚
â”‚                   Rules: chat, fortune, music                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             â”‚                     â”‚                         â”‚
â”‚             â–¼                     â–¼                         â–¼
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚   Chat Agent    â”‚   â”‚  Fortune Agent  â”‚   â”‚   Music Agent   â”‚
â”‚   â”‚    (ReAct)      â”‚   â”‚    (ReAct)      â”‚   â”‚    (ReAct)      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                  â”‚                     â”‚
â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          â”‚ lunar_cal     â”‚     â”‚ search_song   â”‚
â”‚                          â”‚ calculate     â”‚     â”‚ play_song     â”‚
â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="rust-å¾…å®ç°-4"><a class="header" href="#rust-å¾…å®ç°-4">Rust å¾…å®ç°</a></h3>
<pre><code>rust/genx/src/
  â”œâ”€â”€ agent/
  â”‚     â”œâ”€â”€ mod.rs
  â”‚     â”œâ”€â”€ react.rs      # ReAct Agent
  â”‚     â”œâ”€â”€ match_agent.rs # Match Agent
  â”‚     â”œâ”€â”€ state.rs      # çŠ¶æ€ç®¡ç†
  â”‚     â””â”€â”€ tools/
  â”‚           â”œâ”€â”€ mod.rs
  â”‚           â”œâ”€â”€ builtin.rs
  â”‚           â”œâ”€â”€ generator.rs
  â”‚           â”œâ”€â”€ http.rs
  â”‚           â””â”€â”€ composite.rs
  â”œâ”€â”€ agentcfg/
  â”‚     â”œâ”€â”€ mod.rs
  â”‚     â”œâ”€â”€ agent.rs      # Agent é…ç½®
  â”‚     â”œâ”€â”€ tool.rs       # Tool é…ç½®
  â”‚     â”œâ”€â”€ context.rs    # Context é…ç½®
  â”‚     â””â”€â”€ refs.rs       # å¼•ç”¨è§£æ
  â””â”€â”€ match/
        â”œâ”€â”€ mod.rs
        â”œâ”€â”€ rule.rs       # è§„åˆ™å®šä¹‰
        â”œâ”€â”€ pattern.rs    # æ¨¡å¼è§£æ
        â””â”€â”€ matcher.rs    # åŒ¹é…å¼•æ“
</code></pre>
<hr />
<h2 id="-jsontime---json-æ—¶é—´ç±»å‹--rust-ç¼ºå¤±"><a class="header" href="#-jsontime---json-æ—¶é—´ç±»å‹--rust-ç¼ºå¤±">ğŸ“¦ jsontime - JSON æ—¶é—´ç±»å‹ âš ï¸ Rust ç¼ºå¤±</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-8"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-8">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>Duration</strong>: æ—¶é—´é—´éš”ï¼Œåºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²æˆ–çº³ç§’æ•°</li>
<li><strong>Milli</strong>: æ¯«ç§’æ—¶é—´æˆ³</li>
<li><strong>Unix</strong>: Unix æ—¶é—´æˆ³ï¼ˆç§’ï¼‰</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-8"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-8">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>çµæ´»ååºåˆ—åŒ–</strong>: æ”¯æŒå­—ç¬¦ä¸² <code>"1h30m"</code> æˆ–æ•°å­— <code>5400000000000</code></li>
<li><strong>ç²¾åº¦å¤„ç†</strong>: æ¯«ç§’/ç§’/çº³ç§’è½¬æ¢</li>
</ol>
<h3 id="rust-å¾…å®ç°-5"><a class="header" href="#rust-å¾…å®ç°-5">Rust å¾…å®ç°</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rust/jsontime/src/lib.rs

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::time::Duration as StdDuration;

#[derive(Debug, Clone, Copy, Default)]
pub struct Duration(pub StdDuration);

impl Serialize for Duration {
    fn serialize&lt;S: Serializer&gt;(&amp;self, s: S) -&gt; Result&lt;S::Ok, S::Error&gt; {
        s.serialize_str(&amp;format_duration(self.0))
    }
}

impl&lt;'de&gt; Deserialize&lt;'de&gt; for Duration {
    fn deserialize&lt;D: Deserializer&lt;'de&gt;&gt;(d: D) -&gt; Result&lt;Self, D::Error&gt; {
        // æ”¯æŒå­—ç¬¦ä¸²æˆ–æ•°å­—
        // ...
    }
}

#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]
pub struct Milli(pub i64);

#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]  
pub struct Unix(pub i64);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="-minimax---minimax-sdk"><a class="header" href="#-minimax---minimax-sdk">ğŸ“¦ minimax - MiniMax SDK</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-9"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-9">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>Text</strong>: æ–‡æœ¬ç”Ÿæˆï¼ˆChatCompletionï¼‰ã€æµå¼è¾“å‡º</li>
<li><strong>Speech</strong>: è¯­éŸ³åˆæˆï¼ˆåŒæ­¥ã€å¼‚æ­¥ï¼‰</li>
<li><strong>Video</strong>: è§†é¢‘ç”Ÿæˆï¼ˆT2Vã€I2Vã€Agentï¼‰</li>
<li><strong>Image</strong>: å›¾ç‰‡ç”Ÿæˆ</li>
<li><strong>Music</strong>: éŸ³ä¹ç”Ÿæˆ</li>
<li><strong>File</strong>: æ–‡ä»¶ä¸Šä¼ /ç®¡ç†</li>
<li><strong>Voice</strong>: éŸ³è‰²åˆ—è¡¨ã€å…‹éš†ã€è®¾è®¡</li>
<li><strong>Task</strong>: å¼‚æ­¥ä»»åŠ¡è½®è¯¢</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-9"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-9">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>æµå¼è§£æ</strong>: SSE æ ¼å¼è§£æ</li>
<li><strong>å¼‚æ­¥ä»»åŠ¡</strong>: è½®è¯¢æœºåˆ¶ã€è¶…æ—¶å¤„ç†</li>
<li><strong>æ–‡ä»¶ä¸Šä¼ </strong>: multipart/form-data</li>
<li><strong>é”™è¯¯å¤„ç†</strong>: API é”™è¯¯ç æ˜ å°„</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-6"><a class="header" href="#go-vs-rust-å·®å¼‚-6">Go vs Rust å·®å¼‚</a></h3>
<p>âœ… <strong>å®ç°åŸºæœ¬ä¸€è‡´</strong></p>
<hr />
<h2 id="-mqtt0---è½»é‡çº§-mqtt"><a class="header" href="#-mqtt0---è½»é‡çº§-mqtt">ğŸ“¦ mqtt0 - è½»é‡çº§ MQTT</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-10"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-10">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>Client</strong>: QoS 0 MQTT å®¢æˆ·ç«¯</li>
<li><strong>Broker</strong>: QoS 0 MQTT æœåŠ¡ç«¯</li>
<li><strong>Authenticator</strong>: è®¤è¯æ¥å£</li>
<li><strong>ACL</strong>: å‘å¸ƒ/è®¢é˜…æƒé™æ§åˆ¶</li>
<li><strong>Transport</strong>: TCPã€TLSã€WebSocketã€WSS</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-10"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-10">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>åè®®è§£æ</strong>: MQTT 3.1.1 / 5.0 æŠ¥æ–‡è§£æ</li>
<li><strong>Topic åŒ¹é…</strong>: é€šé…ç¬¦ <code>+</code> å’Œ <code>#</code> çš„å¤„ç†</li>
<li><strong>è¿æ¥ç®¡ç†</strong>: å®¢æˆ·ç«¯æ–­å¼€ã€é‡è¿ã€å¿ƒè·³</li>
<li><strong>TLS æ”¯æŒ</strong>: è¯ä¹¦åŠ è½½ã€éªŒè¯</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-7"><a class="header" href="#go-vs-rust-å·®å¼‚-7">Go vs Rust å·®å¼‚</a></h3>
<p>âœ… <strong>å®ç°åŸºæœ¬ä¸€è‡´</strong></p>
<p>Rust çš„ trie å®ç°å†…åµŒåœ¨ mqtt0 ä¸­ï¼ŒGo çš„ trie æ˜¯ç‹¬ç«‹åŒ…ã€‚</p>
<hr />
<h2 id="-speech---è¯­éŸ³æŠ½è±¡å±‚--rust-ç¼ºå¤±"><a class="header" href="#-speech---è¯­éŸ³æŠ½è±¡å±‚--rust-ç¼ºå¤±">ğŸ“¦ speech - è¯­éŸ³æŠ½è±¡å±‚ âš ï¸ Rust ç¼ºå¤±</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-11"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-11">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>Speech</strong>: è¯­éŸ³æµæ¥å£ï¼ˆéŸ³é¢‘ + æ–‡æœ¬è½¬å†™ï¼‰</li>
<li><strong>SpeechSegment</strong>: å•ä¸ªè¯­éŸ³ç‰‡æ®µ</li>
<li><strong>Voice</strong>: çº¯éŸ³é¢‘æµæ¥å£</li>
<li><strong>VoiceSegment</strong>: å•ä¸ªéŸ³é¢‘ç‰‡æ®µ</li>
<li><strong>TTS/ASR</strong>: æŠ½è±¡æ¥å£</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-11"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-11">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>æŠ½è±¡è®¾è®¡</strong>: ç»Ÿä¸€ä¸åŒ TTS/ASR æä¾›å•†çš„æ¥å£</li>
<li><strong>æµå¼å¤„ç†</strong>: è¾¹ç”Ÿæˆè¾¹æ’­æ”¾</li>
<li><strong>èµ„æºç®¡ç†</strong>: æ­£ç¡®å…³é—­æµå’Œé‡Šæ”¾èµ„æº</li>
</ol>
<h3 id="æ¥å£è®¾è®¡"><a class="header" href="#æ¥å£è®¾è®¡">æ¥å£è®¾è®¡</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Speech                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Segment 1 â”‚â”€â”€â–¶â”‚ Segment 2 â”‚â”€â”€â–¶â”‚ Segment 3 â”‚  â”‚
â”‚  â”‚ Audio +   â”‚   â”‚ Audio +   â”‚   â”‚ Audio +   â”‚  â”‚
â”‚  â”‚ Text      â”‚   â”‚ Text      â”‚   â”‚ Text      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Voice                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Segment 1 â”‚â”€â”€â–¶â”‚ Segment 2 â”‚â”€â”€â–¶â”‚ Segment 3 â”‚  â”‚
â”‚  â”‚ Audio     â”‚   â”‚ Audio     â”‚   â”‚ Audio     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="rust-å¾…å®ç°-6"><a class="header" href="#rust-å¾…å®ç°-6">Rust å¾…å®ç°</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rust/speech/src/lib.rs

use giztoy_audio::pcm::Format;
use std::io::Read;

pub trait Speech {
    type Segment: SpeechSegment;
    
    fn next(&amp;mut self) -&gt; Result&lt;Option&lt;Self::Segment&gt;, Error&gt;;
    fn close(&amp;mut self) -&gt; Result&lt;(), Error&gt;;
}

pub trait SpeechSegment {
    fn decode(&amp;self, format: Format) -&gt; VoiceSegment;
    fn transcribe(&amp;self) -&gt; Box&lt;dyn Read&gt;;
    fn close(&amp;mut self) -&gt; Result&lt;(), Error&gt;;
}

pub trait Voice {
    type Segment: VoiceSegment;
    
    fn next(&amp;mut self) -&gt; Result&lt;Option&lt;Self::Segment&gt;, Error&gt;;
    fn close(&amp;mut self) -&gt; Result&lt;(), Error&gt;;
}

pub trait VoiceSegment {
    fn format(&amp;self) -&gt; Format;
    fn samples(&amp;self) -&gt; &amp;[i16];
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="-trie---æ³›å‹-trie-æ•°æ®ç»“æ„"><a class="header" href="#-trie---æ³›å‹-trie-æ•°æ®ç»“æ„">ğŸ“¦ trie - æ³›å‹ Trie æ•°æ®ç»“æ„</a></h2>
<h3 id="åŠŸèƒ½è¦ç‚¹-12"><a class="header" href="#åŠŸèƒ½è¦ç‚¹-12">åŠŸèƒ½è¦ç‚¹</a></h3>
<ul>
<li><strong>è·¯å¾„å­˜å‚¨</strong>: åŸºäº <code>/</code> åˆ†éš”çš„è·¯å¾„</li>
<li><strong>é€šé…ç¬¦åŒ¹é…</strong>: <code>+</code>ï¼ˆå•çº§ï¼‰å’Œ <code>#</code>ï¼ˆå¤šçº§ï¼‰</li>
<li><strong>æ³›å‹å€¼</strong>: æ”¯æŒä»»æ„ç±»å‹ <code>T</code></li>
<li><strong>éå†</strong>: Walk æ–¹æ³•éå†æ‰€æœ‰èŠ‚ç‚¹</li>
</ul>
<h3 id="æŠ€æœ¯éš¾ç‚¹-12"><a class="header" href="#æŠ€æœ¯éš¾ç‚¹-12">æŠ€æœ¯éš¾ç‚¹</a></h3>
<ol>
<li><strong>åŒ¹é…ä¼˜å…ˆçº§</strong>: ç²¾ç¡®åŒ¹é… &gt; å•çº§é€šé…ç¬¦ &gt; å¤šçº§é€šé…ç¬¦</li>
<li><strong>è·¯å¾„è§£æ</strong>: å¤„ç†ç©ºæ®µã€å°¾éƒ¨æ–œæ </li>
<li><strong>æ³›å‹è®¾è®¡</strong>: æ”¯æŒä»»æ„å…ƒç´ ç±»å‹</li>
</ol>
<h3 id="go-vs-rust-å·®å¼‚-8"><a class="header" href="#go-vs-rust-å·®å¼‚-8">Go vs Rust å·®å¼‚</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŠŸèƒ½</th><th style="text-align: center">Go</th><th style="text-align: center">Rust</th><th>è¯´æ˜</th></tr></thead><tbody>
<tr><td>ç‹¬ç«‹åŒ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âŒ</td><td>Rust å†…åµŒåœ¨ mqtt0</td></tr>
<tr><td>æ³›å‹æ”¯æŒ</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td>éƒ½æ”¯æŒæ³›å‹</td></tr>
</tbody></table>
</div>
<h3 id="rust-å¾…å®ç°ç‹¬ç«‹åŒ…"><a class="header" href="#rust-å¾…å®ç°ç‹¬ç«‹åŒ…">Rust å¾…å®ç°ï¼ˆç‹¬ç«‹åŒ…ï¼‰</a></h3>
<pre><code>rust/trie/
  â”œâ”€â”€ Cargo.toml
  â””â”€â”€ src/
        â””â”€â”€ lib.rs    # ä» mqtt0/src/trie.rs æå–
</code></pre>
<hr />
<h2 id="-ä¼˜å…ˆçº§å»ºè®®"><a class="header" href="#-ä¼˜å…ˆçº§å»ºè®®">ğŸ¯ ä¼˜å…ˆçº§å»ºè®®</a></h2>
<h3 id="p0---æ ¸å¿ƒåŠŸèƒ½"><a class="header" href="#p0---æ ¸å¿ƒåŠŸèƒ½">P0 - æ ¸å¿ƒåŠŸèƒ½</a></h3>
<ol>
<li><strong>genx/agent/</strong> - Agent æ¡†æ¶æ˜¯æ™ºèƒ½åº”ç”¨çš„æ ¸å¿ƒ</li>
<li><strong>chatgear/</strong> - è®¾å¤‡é€šä¿¡æ˜¯ IoT åœºæ™¯å¿…éœ€</li>
</ol>
<h3 id="p1---é‡è¦åŠŸèƒ½"><a class="header" href="#p1---é‡è¦åŠŸèƒ½">P1 - é‡è¦åŠŸèƒ½</a></h3>
<ol start="3">
<li><strong>speech/</strong> - è¯­éŸ³æŠ½è±¡å±‚æä¾›ç»Ÿä¸€æ¥å£</li>
<li><strong>genx/match/</strong> - è§„åˆ™åŒ¹é…æ”¯æŒæ„å›¾è¯†åˆ«</li>
<li><strong>cli/</strong> è¡¥å…¨ - TUIã€æ—¥å¿—ç­‰ç”¨æˆ·ä½“éªŒåŠŸèƒ½</li>
</ol>
<h3 id="p2---å·¥å…·ç±»"><a class="header" href="#p2---å·¥å…·ç±»">P2 - å·¥å…·ç±»</a></h3>
<ol start="6">
<li><strong>jsontime/</strong> - JSON åºåˆ—åŒ–ä¾¿æ·ç±»å‹</li>
<li><strong>encoding/</strong> - ç¼–ç å·¥å…·ç±»å‹</li>
<li><strong>trie/</strong> - ç‹¬ç«‹åŒ…ï¼Œä¾¿äºå¤ç”¨</li>
<li><strong>audio/portaudio</strong> - å®æ—¶éŸ³é¢‘é‡‡é›†</li>
</ol>
<hr />
<h2 id="-æ€»ç»“"><a class="header" href="#-æ€»ç»“">ğŸ“ æ€»ç»“</a></h2>
<p><strong>æ›´æ–° (2026-01-23)</strong>: Rust å®ç°å·²å¤§å¹…è¡¥å…¨ï¼Œç°å·²è¦†ç›–ï¼š</p>
<h3 id="-å·²å®Œæˆè¿ç§»"><a class="header" href="#-å·²å®Œæˆè¿ç§»">âœ… å·²å®Œæˆè¿ç§»</a></h3>
<ol>
<li><strong>API å®¢æˆ·ç«¯</strong>: minimaxã€dashscopeã€doubaospeech - å®Œæ•´å®ç°</li>
<li><strong>åŸºç¡€è®¾æ–½</strong>: bufferã€audio codecã€mqtt0 - å®Œæ•´å®ç°</li>
<li><strong>è®¾å¤‡é€šä¿¡</strong>: chatgear - å®Œæ•´å®ç°ï¼ˆstate, command, stats, port traits, pipe for testingï¼‰</li>
<li><strong>é«˜å±‚æŠ½è±¡</strong>: speech - å®Œæ•´å®ç°ï¼ˆTTS/ASR interfaces, Mux, SentenceSegmenterï¼‰</li>
<li><strong>å·¥å…·ç±»</strong>: jsontime, encoding, trie, cli - å®Œæ•´å®ç°</li>
</ol>
<h3 id="-å¾…å®Œæˆ"><a class="header" href="#-å¾…å®Œæˆ">â³ å¾…å®Œæˆ</a></h3>
<ol>
<li><strong>Agent æ¡†æ¶ (genx/agent)</strong>: è¿™æ˜¯ä¸»è¦å·®è·ï¼ŒGo ç‰ˆæœ¬æœ‰å®Œæ•´çš„ Agent ç³»ç»Ÿæ”¯æŒ ReAct å’Œ Match æ¨¡å¼</li>
<li><strong>audio/portaudio</strong>: å®æ—¶éŸ³é¢‘é‡‡é›†ï¼ˆéœ€è¦ C ç»‘å®šï¼‰</li>
</ol>
<h3 id="-æµ‹è¯•è¦†ç›–"><a class="header" href="#-æµ‹è¯•è¦†ç›–">ğŸ“Š æµ‹è¯•è¦†ç›–</a></h3>
<p>æ‰€æœ‰ Rust åŒ…éƒ½æœ‰å®Œæ•´çš„å•å…ƒæµ‹è¯•ï¼Œé€šè¿‡ <code>bazel test //rust/...</code> éªŒè¯ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>This document describes the <code>examples/</code> directory layout and how to run the
included example programs and CLI scripts. Examples are grouped by language
and by SDK.</p>
<h2 id="directory-layout"><a class="header" href="#directory-layout">Directory Layout</a></h2>
<pre><code>examples/
â”œâ”€â”€ cmd/                     # CLI test scripts (shell)
â”‚   â”œâ”€â”€ minimax/
â”‚   â”‚   â”œâ”€â”€ run.sh
â”‚   â”‚   â””â”€â”€ commands/
â”‚   â””â”€â”€ doubaospeech/
â”‚       â”œâ”€â”€ run.sh
â”‚       â””â”€â”€ commands/
â”œâ”€â”€ go/                      # Go examples (single module)
â”‚   â”œâ”€â”€ go.mod
â”‚   â”œâ”€â”€ audio/
â”‚   â”œâ”€â”€ dashscope/
â”‚   â”œâ”€â”€ doubaospeech/
â”‚   â”œâ”€â”€ genx/
â”‚   â””â”€â”€ minimax/
â””â”€â”€ rust/                    # Rust examples
    â””â”€â”€ minimax/
        â”œâ”€â”€ Cargo.toml
        â””â”€â”€ src/bin/
</code></pre>
<h2 id="how-to-run"><a class="header" href="#how-to-run">How to Run</a></h2>
<h3 id="cli-script-examples"><a class="header" href="#cli-script-examples">CLI Script Examples</a></h3>
<ul>
<li>Minimax CLI test runner:
<ul>
<li><code>./examples/cmd/minimax/run.sh go 1</code></li>
<li>Bazel: <code>bazel run //examples/cmd/minimax:run -- go 1</code></li>
</ul>
</li>
<li>Doubao Speech CLI test runner:
<ul>
<li><code>./examples/cmd/doubaospeech/run.sh tts</code></li>
<li>Bazel: <code>bazel run //examples/cmd/doubaospeech:run -- tts</code></li>
</ul>
</li>
</ul>
<h3 id="go-examples"><a class="header" href="#go-examples">Go Examples</a></h3>
<p>All Go examples share one module at <code>examples/go/go.mod</code> and depend on the
local <code>go/</code> module via <code>replace</code>.</p>
<ul>
<li>Build all Go examples:
<ul>
<li><code>cd examples/go &amp;&amp; go build ./...</code></li>
</ul>
</li>
</ul>
<h3 id="rust-examples"><a class="header" href="#rust-examples">Rust Examples</a></h3>
<p>Rust examples are independent crates.</p>
<ul>
<li>Build the MiniMax Rust examples:
<ul>
<li><code>cd examples/rust/minimax &amp;&amp; cargo build --release</code></li>
</ul>
</li>
</ul>
<h2 id="notes-2"><a class="header" href="#notes-2">Notes</a></h2>
<ul>
<li>Example binaries often depend on environment variables for API keys.</li>
<li>Refer to the SDK docs under <code>docs/lib/{sdk}/</code> for configuration details.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bazel-build"><a class="header" href="#bazel-build">Bazel Build</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
