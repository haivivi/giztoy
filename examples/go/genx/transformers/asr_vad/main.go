// Package main tests the EoS (End-of-Stream) propagation through the transform pipeline.
//
// This test validates that EoS markers are correctly:
// 1. Generated by CompositeSeq between streams
// 2. Converted by TTS from text EoS to audio EoS
// 3. Converted by codec from audio/mp3 EoS to audio/ogg EoS
// 4. Converted by ASR from audio EoS to text EoS
//
// Pipeline:
//
//	[Text1] [EoS] [Text2] [EoS] [Text3]
//	  -> TTS -> [Audio1] [Audio EoS] [Audio2] [Audio EoS] [Audio3]
//	  -> Codec -> [OGG1] [OGG EoS] [OGG2] [OGG EoS] [OGG3]
//	  -> ASR -> [Text1] [Text EoS] [Text2] [Text EoS] [Text3]
package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"time"

	"github.com/haivivi/giztoy/go/pkg/doubaospeech"
	"github.com/haivivi/giztoy/go/pkg/genx"
	"github.com/haivivi/giztoy/go/pkg/genx/transformers"
	"github.com/haivivi/giztoy/go/pkg/minimax"
)

// Test sentences - distinct sentences to verify EoS boundaries
var sentences = []string{
	"今天天气真好，阳光明媚，非常适合出门散步。",
	"我喜欢读书，每天都会花一个小时阅读。",
	"科技改变生活，人工智能正在改变世界。",
}

var (
	timeout = flag.Duration("timeout", 5*time.Minute, "Test timeout duration")
)

func main() {
	flag.Parse()

	ctx, cancel := context.WithTimeout(context.Background(), *timeout)
	defer cancel()

	fmt.Println("=== EoS Transform Pipeline Test ===")
	fmt.Printf("Test sentences:\n")
	for i, s := range sentences {
		fmt.Printf("  [%d] %s\n", i+1, s)
	}
	fmt.Println()

	// Initialize clients
	doubaoClient, err := initDoubaoClient()
	if err != nil {
		log.Fatalf("Failed to init Doubao client: %v", err)
	}

	minimaxClient, err := initMinimaxClient()
	if err != nil {
		log.Fatalf("Failed to init MiniMax client: %v", err)
	}

	// Run the EoS pipeline test
	runEoSPipelineTest(ctx, doubaoClient, minimaxClient)
}

func initDoubaoClient() (*doubaospeech.Client, error) {
	appID := os.Getenv("DOUBAO_APP_ID")
	token := os.Getenv("DOUBAO_TOKEN")
	if appID == "" || token == "" {
		return nil, fmt.Errorf("DOUBAO_APP_ID and DOUBAO_TOKEN must be set")
	}
	return doubaospeech.NewClient(appID, doubaospeech.WithBearerToken(token)), nil
}

func initMinimaxClient() (*minimax.Client, error) {
	apiKey := os.Getenv("MINIMAX_API_KEY")
	if apiKey == "" {
		return nil, fmt.Errorf("MINIMAX_API_KEY must be set")
	}
	return minimax.NewClient(apiKey), nil
}

func runEoSPipelineTest(ctx context.Context, doubaoClient *doubaospeech.Client, minimaxClient *minimax.Client) {
	fmt.Println("--- Test: CompositeSeq -> TTS -> Codec -> ASR with EoS markers ---")

	// Create transformers
	tts := transformers.NewMinimaxTTS(minimaxClient, "female-shaonv",
		transformers.WithMinimaxTTSFormat("mp3"),
		transformers.WithMinimaxTTSSampleRate(24000),
	)
	codec := transformers.NewMP3ToOgg()
	asr := transformers.NewDoubaoASRSAUC(doubaoClient,
		transformers.WithDoubaoASRSAUCSampleRate(24000),
	)

	// Create text streams for each sentence
	fmt.Println("[1] Creating text streams with CompositeSeq...")
	textStreams := make([]genx.Stream, len(sentences))
	for i, sentence := range sentences {
		textStreams[i] = textToStream(sentence)
	}

	// Combine with EoS markers using CompositeSeq
	combined := genx.CompositeSeq(textStreams...)

	// Transform through TTS
	fmt.Println("[2] TTS transform (text -> audio)...")
	audioStream, err := tts.Transform(ctx, combined)
	if err != nil {
		log.Fatalf("TTS transform error: %v", err)
	}

	// Transform through Codec
	fmt.Println("[3] Codec transform (MP3 -> OGG)...")
	oggStream, err := codec.Transform(ctx, audioStream)
	if err != nil {
		log.Fatalf("Codec transform error: %v", err)
	}

	// Transform through ASR
	fmt.Println("[4] ASR transform (audio -> text)...")
	textStream, err := asr.Transform(ctx, oggStream)
	if err != nil {
		log.Fatalf("ASR transform error: %v", err)
	}

	// Collect results and count EoS markers
	fmt.Println("[5] Collecting results...")
	textResults, eosCount, err := collectResults(textStream)
	if err != nil {
		log.Fatalf("Failed to collect results: %v", err)
	}

	// Print results
	fmt.Println("\n=== Results ===")
	fmt.Printf("Text segments received: %d\n", len(textResults))
	for i, text := range textResults {
		fmt.Printf("  [%d] %s\n", i+1, truncate(text, 80))
	}
	fmt.Printf("EoS markers received: %d\n", eosCount)
	fmt.Printf("Expected EoS markers: %d (for %d sentences)\n", len(sentences)-1, len(sentences))

	// Verify results
	fmt.Println("\n=== Verification ===")
	if len(textResults) == len(sentences) {
		fmt.Println("✓ Correct number of text segments")
	} else {
		fmt.Printf("✗ Expected %d text segments, got %d\n", len(sentences), len(textResults))
	}

	if eosCount == len(sentences)-1 {
		fmt.Println("✓ Correct number of EoS markers")
	} else {
		fmt.Printf("✗ Expected %d EoS markers, got %d\n", len(sentences)-1, eosCount)
	}

	// Calculate overall similarity
	allOriginal := strings.Join(sentences, "")
	allReceived := strings.Join(textResults, "")
	similarity := calculateSimilarity(allOriginal, allReceived)
	fmt.Printf("Overall similarity: %.1f%%\n", similarity*100)
}

// collectResults reads all chunks from a stream and returns text results and EoS count
func collectResults(stream genx.Stream) ([]string, int, error) {
	var results []string
	var currentText strings.Builder
	eosCount := 0

	for {
		chunk, err := stream.Next()
		if err != nil {
			if err == io.EOF {
				// Flush any remaining text
				if currentText.Len() > 0 {
					results = append(results, currentText.String())
				}
				break
			}
			return nil, 0, err
		}

		if chunk == nil {
			continue
		}

		// Check for EoS marker
		if chunk.IsEndOfStream() {
			fmt.Printf("  [EoS] %s\n", getMIMEType(chunk))
			// Flush current text segment
			if currentText.Len() > 0 {
				results = append(results, currentText.String())
				currentText.Reset()
			}
			eosCount++
			continue
		}

		// Collect text
		if text, ok := chunk.Part.(genx.Text); ok {
			fmt.Printf("  [Text] %s\n", truncate(string(text), 60))
			currentText.WriteString(string(text))
		}
	}

	return results, eosCount, nil
}

func getMIMEType(chunk *genx.MessageChunk) string {
	if chunk == nil || chunk.Part == nil {
		return "unknown"
	}
	if text, ok := chunk.Part.(genx.Text); ok {
		_ = text
		return "text/plain"
	}
	if blob, ok := chunk.Part.(*genx.Blob); ok {
		return blob.MIMEType
	}
	return "unknown"
}

// textToStream converts a text string to a genx.Stream
func textToStream(text string) genx.Stream {
	return &singleTextStream{
		text: text,
		done: false,
	}
}

type singleTextStream struct {
	text string
	done bool
}

func (s *singleTextStream) Next() (*genx.MessageChunk, error) {
	if s.done {
		return nil, io.EOF
	}
	s.done = true
	return &genx.MessageChunk{
		Role: genx.RoleUser,
		Part: genx.Text(s.text),
	}, nil
}

func (s *singleTextStream) Close() error {
	s.done = true
	return nil
}

func (s *singleTextStream) CloseWithError(err error) error {
	s.done = true
	return nil
}

// memoryStream wraps collected audio data as a stream
type memoryStream struct {
	data     []byte
	mimeType string
	done     bool
}

func (s *memoryStream) Next() (*genx.MessageChunk, error) {
	if s.done {
		return nil, io.EOF
	}
	s.done = true
	return &genx.MessageChunk{
		Part: &genx.Blob{
			MIMEType: s.mimeType,
			Data:     s.data,
		},
	}, nil
}

func (s *memoryStream) Close() error {
	s.done = true
	return nil
}

func (s *memoryStream) CloseWithError(err error) error {
	s.done = true
	return nil
}

func truncate(s string, maxLen int) string {
	runes := []rune(s)
	if len(runes) <= maxLen {
		return s
	}
	return string(runes[:maxLen]) + "..."
}

func calculateSimilarity(a, b string) float64 {
	cleanA := cleanText(a)
	cleanB := cleanText(b)

	if len(cleanA) == 0 && len(cleanB) == 0 {
		return 1.0
	}
	if len(cleanA) == 0 || len(cleanB) == 0 {
		return 0.0
	}

	matches := 0
	runesA := []rune(cleanA)
	runesB := []rune(cleanB)

	charMap := make(map[rune]int)
	for _, r := range runesB {
		charMap[r]++
	}

	for _, r := range runesA {
		if charMap[r] > 0 {
			matches++
			charMap[r]--
		}
	}

	maxLen := len(runesA)
	if len(runesB) > maxLen {
		maxLen = len(runesB)
	}

	return float64(matches) / float64(maxLen)
}

func cleanText(s string) string {
	var sb strings.Builder
	for _, r := range s {
		if r >= 0x4e00 && r <= 0x9fff ||
			(r >= 'a' && r <= 'z') ||
			(r >= 'A' && r <= 'Z') ||
			(r >= '0' && r <= '9') {
			sb.WriteRune(r)
		}
	}
	return sb.String()
}
